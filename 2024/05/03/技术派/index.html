<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>技术派个人总结 | Xing's Blog</title><meta name="author" content="Xing"><meta name="copyright" content="Xing"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="这是一个简单的技术派项目个人总结，创建于博主学技术初期。">
<meta property="og:type" content="article">
<meta property="og:title" content="技术派个人总结">
<meta property="og:url" content="https://xingliu99.github.io/2024/05/03/%E6%8A%80%E6%9C%AF%E6%B4%BE/index.html">
<meta property="og:site_name" content="Xing's Blog">
<meta property="og:description" content="这是一个简单的技术派项目个人总结，创建于博主学技术初期。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xingliu99.github.io/img/cover/20.jpg">
<meta property="article:published_time" content="2024-05-03T08:49:00.000Z">
<meta property="article:modified_time" content="2024-08-06T03:53:06.000Z">
<meta property="article:author" content="Xing">
<meta property="article:tag" content="项目">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xingliu99.github.io/img/cover/20.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xingliu99.github.io/2024/05/03/%E6%8A%80%E6%9C%AF%E6%B4%BE/index.html"><link rel="preconnect" href="https://cdn.staticfile.org"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/node-snackbar/0.1.16/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/5.0.33/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"距离文章发布过去了","messageNext":"天，请注意查阅最新资料。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功 记得下次光顾哦',
    error: '出错啦 请稍后再试',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":20,"languages":{"author":"作者: Xing","link":"链接: ","source":"来源: Xing's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-right"},
  infinitegrid: {
    js: 'https://cdn.staticfile.org/egjs-infinitegrid/4.11.1/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '技术派个人总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-06 11:53:06'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/rightmenu.css"><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/fonts/font.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://codebyzach.github.io/pace/assets/css/templates/pace-theme-bounce.tmpl.css"><script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('/img/cover/20.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Xing's Blog"><span class="site-name">Xing's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">技术派个人总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-03T08:49:00.000Z" title="发表于 2024-05-03 16:49:00">2024-05-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-06T03:53:06.000Z" title="更新于 2024-08-06 11:53:06">2024-08-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="技术派个人总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('/img/cover/20.jpg');"></div><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer">

<h3 id="网关实现JWT的认证"><a href="#网关实现JWT的认证" class="headerlink" title="网关实现JWT的认证"></a>网关实现JWT的认证</h3><p>之前就是简单的实现了在网关通过过滤器进行认证，前端发账号密码过来后，进行校验认证，认证成功的话给前端发送生成的<code>JWT</code>令牌，同时设置过期时间后放入Redis中。<br>引入双Token刷新机制，我们可以做如下改变：在生成Token时，同时生成<code>Access_Token</code>和<code>Refresh_Token</code>并返回给前端，其他依旧把<code>Access_Token</code>放入Redis中，作为校验的一种认证手段。<br>刷新过程：前端请求时携带<code>Access_Token</code>访问服务器，当<code>Access_Token</code>过期时，服务器会告诉前端这个Token过期了（401错误），需要进行刷新，这时候前端需要携带<code>Refresh_Token</code>去请求Token刷新接口，获取新的<code>Access_Token</code>，如果没有过期则可以成功获取。</p>
<ol>
<li><p>为什么要使用双Token刷新机制？</p>
<blockquote>
<p>首先来说，为了安全考虑token的有效期不会很长，但是又不想用户经常进行登录操作，那么就可以使用刷新机制，让用户无感刷新，这样设置可以防止用户长时间使用同一个token，同时Refresh_Token只在网络中传输若干次，减少了令牌泄露的风险。</p>
</blockquote>
</li>
<li><p>为什么不使用单token机制</p>
<blockquote>
<p>单令牌在被盗后容易被无限刷新访问资源；<br>而且如果每个请求都进行判断是否要续期会有一部分开销。<br>双token则只需要在过期时才进行续期。</p>
</blockquote>
</li>
</ol>
<h3 id="会员券抢购功能-缓存问题"><a href="#会员券抢购功能-缓存问题" class="headerlink" title="会员券抢购功能 &amp; 缓存问题"></a>会员券抢购功能 &amp; 缓存问题</h3><ol>
<li><p>怎么解决数据的一致性</p>
<blockquote>
<p>首先对于数据库是采用更新操作，对于缓存则可以选择删除缓存<br><code>删除缓存，更新数据库：</code>可能会出现数据库还未更新就发生缓存重建，可以采取延时双删<br><code>更新数据库，删除缓存：</code>可能会删除缓存失败，可以采取删除重试机制<br>采用先更新数据库再删缓存，可以保证数据的最终一致性</p>
</blockquote>
</li>
<li><p>缓存穿透</p>
<blockquote>
<p>查询的数据在缓存和数据库都没有，但是两个都要查一遍<br>可以采取缓存空值或者使用布隆过滤器</p>
</blockquote>
</li>
<li><p>缓存击穿</p>
<blockquote>
<p>某个热点key过期，大量请求到达数据库<br>加互斥锁进行缓存重建；设置键逻辑过期<br>两者都有缓存重建过程，前者会重试获取数据，适合数据一致性要求高一些的；后者会返回逻辑过期数据，适合数据一致性要求不高的</p>
</blockquote>
</li>
<li><p>缓存雪崩</p>
<blockquote>
<p>同一时间大量key过期<br>设置过期值时添加随机过期时间；使用队列访问，比较慢；采用熔断机制</p>
</blockquote>
</li>
<li><p>超卖问题</p>
<blockquote>
<p>采用乐观锁进行判断，但是不能使用CAS进行判断，会只有一个扣减成功应该在扣减库存时判断库存大于0即可</p>
</blockquote>
</li>
<li><p>一人一单</p>
<blockquote>
<p>根据用户ID进行加锁，保证用户只能有一次下单机会</p>
</blockquote>
</li>
</ol>
<h3 id="使用Caffeine加Redis构建多级缓存"><a href="#使用Caffeine加Redis构建多级缓存" class="headerlink" title="使用Caffeine加Redis构建多级缓存"></a>使用Caffeine加Redis构建多级缓存</h3><p>有一些信息（侧边栏信息）访问及其频繁，可以考虑放到<code>Java</code>的本地内存缓存中<br>主要借助<code>Caffeine</code> + <code>@Cacheable</code>来使用，首先构建<code>CacheManager</code>的Bean，将其作为本地缓存，然后在类或者方法上添加注解</p>
<ol>
<li><p>为什么要构建多级缓存</p>
<blockquote>
<p>对于一些访问频繁且变动及其少的数据，可以选择放入<code>Java</code>内存中，提高响应速度</p>
</blockquote>
</li>
<li><p>还有哪些本地缓存方式</p>
<blockquote>
<p>HashMap：实现相对比较简单，需要考虑一些并发问题，不适用与复杂的场景<br>Guava Cache：比较优异的缓存工具，可以认为是<code>Caffeine</code> 前一个版本<br>Encahe：功能更加丰富，扩展性更强，但是性能是最差的<br>总结：对于本地缓存的方案中，推荐Caffeine，性能上遥遥领先。虽然Encache功能更为丰富，甚至提供了持久化和集群的功能，但是这些功能完全可以依靠其他方式实现。真实的业务工程中，建议使用Caffeine作为本地缓存，另外使用Redis或者<code>Memcache</code>作为分布式缓存，构造多级缓存体系，保证性能和可靠性。</p>
</blockquote>
</li>
<li><p>能否放多个 @Cacheable 注解</p>
<blockquote>
<p>可以放，访问顺序按照放入的顺序进行访问，最后找不到才执行方法内代码</p>
</blockquote>
</li>
<li><p><code>Caffeine</code> 缓存的过期时间设置</p>
<blockquote>
<p>如果需要不同的过期时间策略的缓存，那么可以声明不同的<code>CacheManager</code>的Bean，配合注解指定即可</p>
</blockquote>
</li>
</ol>
<h3 id="使用-ControllerAdvice-全局异常处理"><a href="#使用-ControllerAdvice-全局异常处理" class="headerlink" title="使用 ControllerAdvice  全局异常处理"></a>使用 ControllerAdvice  全局异常处理</h3><p>使用<code>@RestControllerAdvice</code>和<code>@ExceptionHandler</code>两个注解，进行全局异常处理<br>将所有异常放在某个规范类中，按照不同的异常类型分开写为枚举类型<br><code>@ExceptionHandler</code>将自动进行拦截对应的异常类型，从而进行对应的代码处理</p>
<ol>
<li>你还知道什么处理方案吗<blockquote>
<p>继承<code>ResponseEntityExceptionHandler</code>重写里面的异常处理方法，但是只能处理Spring内部抛出的异常<br>实现<code>HandlerExceptionResolver</code>重写方法，但是没有那么方便</p>
</blockquote>
</li>
</ol>
<h3 id="ThreadLocal-封装用户信息"><a href="#ThreadLocal-封装用户信息" class="headerlink" title="ThreadLocal  封装用户信息"></a>ThreadLocal  封装用户信息</h3><p>在项目里面用户进行访问时，会获取用户信息，将这些信息存在<code>ThreadLocal</code>中。</p>
<ol>
<li><p>什么是 ThreadLocal  ？为什么要用？</p>
<blockquote>
<p> ThreadLocal 是线程本地变量，每个线程都有一个_ThreadLocalMap_，里面存的是<code>Entry ( ThreadLocal &lt;?&gt; k , Object v ) </code>；<br>每个线程操作这个变量时，实际上是操作自己的本地变量，起到线程隔离的作用；<br>从程序上来说，进行用户信息存储后，在全局位置随时可以获取这个信息，更方便。</p>
</blockquote>
</li>
<li><p>将用户信息封装到了 <code>ThreadLocal </code> ，如果线程池并行执行多个操作都要使用用户信息怎么办？</p>
<blockquote>
<ul>
<li>比较简单的就是将这些信息作为参数进行传递</li>
<li><code>inheritableThreadLocals</code>，父线程的此变量不为空时会赋给子线程的<code>inheritableThreadLocals</code></li>
</ul>
</blockquote>
</li>
<li><p>ThreadLocal 还有哪些应用场景</p>
<blockquote>
<ul>
<li>数据库连接管理，避免多个线程共享连接时出现的同步问题</li>
<li>用户会话管理，存储每个请求对应的用户会话数据</li>
<li>对象池（线程池、数据库连接池…）的线程隔离，为每个线程提供独立的对象池实例</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="日志访问控制"><a href="#日志访问控制" class="headerlink" title="日志访问控制"></a>日志访问控制</h3><p>这个实际上是使用<code>logback</code>进行日志记录，实际上是依赖加配置文件，或许可以去掉。</p>
<h3 id="RedisTemplate使用"><a href="#RedisTemplate使用" class="headerlink" title="RedisTemplate使用"></a>RedisTemplate使用</h3><p><img src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712661589227-b24d1a2c-a425-41aa-8d72-7d0675e0a143.png#averageHue=%23d1bebe&amp;clientId=u11e6c484-f59c-4&amp;from=paste&amp;height=236&amp;id=u61e36f70&amp;originHeight=389&amp;originWidth=1122&amp;originalType=binary&amp;ratio=1.6500000953674316&amp;rotation=0&amp;showTitle=false&amp;size=241494&amp;status=done&amp;style=none&amp;taskId=u6139ae5f-f6f8-4b66-9717-0a4e970cc6d&amp;title=&amp;width=680" alt="image.png"><br>导入依赖</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>配置</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">10.166</span><span class="number">.33</span><span class="number">.175</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">2000</span></span><br></pre></td></tr></tbody></table></figure>
<p>代码</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTemplateConfig</span> {</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span>{</span><br><span class="line">        RedisTemplate&lt;String,Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">// 设置序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置key的序列化为string</span></span><br><span class="line">        redisTemplate.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        redisTemplate.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置value的序列化为JSON</span></span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 设置序列化工具，防止序列化为乱码</span></span><br><span class="line"><span class="comment">// 这种方式不行，存的内容还包括类的包名，占空间</span></span><br><span class="line"><span class="comment">// 进行手动的序列化和反序列化</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate; <span class="comment">// key和value序列化都是string</span></span><br><span class="line"><span class="comment">// 序列化工具</span></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">MAPPER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>(); </span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> MAPPER.writeValueAsString(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">"liu"</span>, <span class="number">18</span>));</span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> MAPPER.readValue(s, User.class);</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AichatUserApplicationTests</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> {</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"name"</span>,<span class="string">"haha"</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">"name"</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712661458669-c6cd546f-767f-4dac-b4a7-22e705deda35.png#averageHue=%23f6f6f6&amp;clientId=u11e6c484-f59c-4&amp;from=paste&amp;height=290&amp;id=u0d62d42b&amp;originHeight=479&amp;originWidth=783&amp;originalType=binary&amp;ratio=1.6500000953674316&amp;rotation=0&amp;showTitle=false&amp;size=94432&amp;status=done&amp;style=none&amp;taskId=uc7a64295-672d-4cd3-9e1d-aae8ab563ae&amp;title=&amp;width=474.5454271174675" alt="image.png"></p>
<h3 id="短信登录"><a href="#短信登录" class="headerlink" title="短信登录"></a>短信登录</h3><ol>
<li>发送验证码</li>
</ol>
<ul>
<li>校验手机号<ul>
<li>不正确返回错误信息</li>
<li>正确校验验证码<ul>
<li>将验证码存入Redis并设置有效期</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>验证码登录、注册</li>
</ol>
<ul>
<li>校验手机号<ul>
<li>不正确返回错误信息</li>
<li>正确校验验证码<ul>
<li>不一致报错</li>
<li>一致查询用户是否存在<ul>
<li>用户不存在创建</li>
<li>存在继续执行程序</li>
</ul>
</li>
<li>保存用户信息到session中</li>
<li>生成UUID作为token登录令牌，并保存token在Redis有效期</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>校验登录状态</li>
</ol>
<ul>
<li>cookie中获取token <ul>
<li>判断用户是否登录或登录是否过期<ul>
<li>未登录拦截</li>
<li>登录则保存用户信息到threadLocal，刷新登录过期时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/jpeg/43109882/1712986438427-27d3158e-f0d3-4631-a848-5f93d89b78ed.jpeg"></p>
<h3 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h3><ul>
<li>本地用高并发</li>
</ul>
<p>Static final ConcurrentHashMap&lt;K,V&gt; map = new ConcurrentHashMap&lt;&gt;();</p>
<ul>
<li>用于Redis等缓存</li>
</ul>
<p>static final Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.newBuilder().build();</p>
<ul>
<li>本地缓存</li>
</ul>
<p>Static final Map&lt;K,V&gt; map =  new HashMap();</p>
<ol>
<li>缓存作用</li>
</ol>
<ul>
<li>降低后端成本</li>
<li>提高读写效率，降低响应时间</li>
</ul>
<ol start="2">
<li>缓存成本</li>
</ol>
<ul>
<li>数据一致性成本</li>
<li>代码维护成本</li>
<li>运维成本（服务器集群）</li>
</ul>
<p><strong>多级缓存</strong><br>浏览器缓存：要是存在于浏览器端的缓存<br>应用层缓存：可以分为toncat本地缓存，例如之前提到的map或者是使用Redis作为缓存<br>数据库缓存：：在数据库中有一片空间是buffer pool，增改查数据都会先加载到mysql的缓存中<br>CPU缓存：当代计算机最大的问题就是CPU性能提升了，但是内存读写速度没有跟上，所以为了适应当下的情况，增加了CPU的L1，L2，L3级的缓存<br><img src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712977565700-eacc0ee6-ca2e-464f-8612-ece22560c1e9.png#averageHue=%23b8aaa7&amp;clientId=ucf8221e1-1d28-4&amp;from=paste&amp;height=275&amp;id=u98f1cc31&amp;originHeight=977&amp;originWidth=937&amp;originalType=binary&amp;ratio=1.6500000953674316&amp;rotation=0&amp;showTitle=false&amp;size=404141&amp;status=done&amp;style=none&amp;taskId=u52a060d1-bae2-43f7-a399-131e4c7e4fc&amp;title=&amp;width=263.87120056152344" alt="image.png"></p>
<h6 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h6><ul>
<li>内存淘汰：Redis自动进行，当Redis内存大到我们设定的 max-memery 时，会自动触发淘汰机制，淘汰掉一些不重要的数据（可以自己设置策略方式）</li>
<li>超时剔除：当我们给Redis设置了过期时间TTL之后，Redis会将超时的数据进行删除，方便我们继续使用缓存</li>
<li>主动更新：我们可以手动调用方法把缓存删除掉，通常用于解决缓存和数据库不一致问题<blockquote>
<p>采用双写方案：缓存调用者在更新完数据库之后再更新缓存</p>
</blockquote>
</li>
</ul>
<p><strong>先删除缓存，再更新数据库</strong><br>线程1删除缓存，还没来得及更新数据库，线程2来查询，缓存没有去数据库查到脏数据<br><img src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712978465435-af807914-2033-4e0d-ac32-724cfd35d4c1.png#averageHue=%23bebebe&amp;clientId=ucf8221e1-1d28-4&amp;from=paste&amp;height=324&amp;id=u078123ed&amp;originHeight=940&amp;originWidth=731&amp;originalType=binary&amp;ratio=1.6500000953674316&amp;rotation=0&amp;showTitle=false&amp;size=197478&amp;status=done&amp;style=none&amp;taskId=ueb626447-2310-4921-901e-11f2d8c69a1&amp;title=&amp;width=252.02459716796875" alt="image.png"><br><strong>先更新数据库，再删除缓存</strong><br>删除缓存的操作很快，但是更新数据库的操作相对较慢，如果此时有一个线程2刚好进来查询缓存，由于我们刚刚才删除缓存，所以线程2需要查询数据库，并写入缓存，但是我们更新数据库的操作还未完成，所以线程2查询到的数据是脏数据，出现线程安全问题<br>导致数据不一致，但是这个出现线程安全问题概率较小<br><img src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712978489223-427ec784-e887-4410-b9f3-a5ddfc7091e2.png#averageHue=%23bdbdbd&amp;clientId=ucf8221e1-1d28-4&amp;from=paste&amp;height=328&amp;id=uHKeC&amp;originHeight=937&amp;originWidth=715&amp;originalType=binary&amp;ratio=1.6500000953674316&amp;rotation=0&amp;showTitle=false&amp;size=197398&amp;status=done&amp;style=none&amp;taskId=uaa31363d-9778-4faa-8758-a8407539bd4&amp;title=&amp;width=250.32763671875" alt="image.png"><br><img src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712978740327-ae9d6808-9739-4536-99a7-27bfc660ae49.png#averageHue=%235d6262&amp;clientId=ucf8221e1-1d28-4&amp;from=paste&amp;height=140&amp;id=u0ff30755&amp;originHeight=255&amp;originWidth=941&amp;originalType=binary&amp;ratio=1.6500000953674316&amp;rotation=0&amp;showTitle=false&amp;size=110027&amp;status=done&amp;style=none&amp;taskId=u64208416-abb4-494e-8fad-f6411c377b4&amp;title=&amp;width=516.302978515625" alt="image.png"></p>
<h6 id="缓存穿透问题解决"><a href="#缓存穿透问题解决" class="headerlink" title="缓存穿透问题解决"></a>缓存穿透问题解决</h6><ul>
<li>缓存穿透：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远都不会生效（只有数据库查到了，才会让redis缓存，但现在的问题是查不到），会频繁的去访问数据库。</li>
<li>常见的结局方案有两种<ol>
<li>缓存空对象<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：额外的内存消耗，可能造成短期的不一致</li>
</ul>
</li>
<li>布隆过滤<ul>
<li>优点：内存占用少，没有多余的key</li>
<li>缺点：实现复杂，可能存在误判</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>选择缓存空对象：如果数据不存在，则缓存一个空对象在缓存中，并设置有效期<br><img src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712978993359-bfb3a95d-6ca2-427b-b707-c648636e450d.png#averageHue=%23bcc4c6&amp;clientId=ucf8221e1-1d28-4&amp;from=paste&amp;height=234&amp;id=uc2af4ef1&amp;originHeight=510&amp;originWidth=1009&amp;originalType=binary&amp;ratio=1.6500000953674316&amp;rotation=0&amp;showTitle=false&amp;size=71445&amp;status=done&amp;style=none&amp;taskId=u2960594c-1528-43f3-99b8-31035a86bcc&amp;title=&amp;width=463.51513671875" alt="image.png"></p>
<h6 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a>缓存雪崩问题</h6><p><img src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712979057893-7792ded9-56d6-46a2-9b80-62360e051222.png#averageHue=%23212221&amp;clientId=ucf8221e1-1d28-4&amp;from=paste&amp;height=216&amp;id=u374f53a9&amp;originHeight=421&amp;originWidth=1248&amp;originalType=binary&amp;ratio=1.6500000953674316&amp;rotation=0&amp;showTitle=false&amp;size=280822&amp;status=done&amp;style=none&amp;taskId=udd04b4ec-380e-48e3-953c-71122426040&amp;title=&amp;width=640.7802734375" alt="image.png"><br>貌似没有代码体现，还是添加过期时间随机值</p>
<h6 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h6><p>热点key失效，大量请求直接到数据库<br><img src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/jpeg/43109882/1712986527420-ac5bcf5d-7ec6-4c53-9d07-cdbb2fb279ef.jpeg"></p>
<h3 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h3><ul>
<li>首先提交优惠券id，然后查询优惠券信息</li>
<li>之后判断秒杀时间是否开始<ul>
<li>开始了，则判断是否有剩余库存<ul>
<li>有库存，那么删减一个库存<ul>
<li>然后创建订单</li>
</ul>
</li>
<li>无库存，则返回一个错误信息</li>
</ul>
</li>
<li>没开始，则返回一个错误信息</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712987104681-c3fbd3dc-a6bf-4b86-a1a8-ce76eff29353.png#averageHue=%23c6c4c4&amp;clientId=u5d98e9b1-cc09-4&amp;from=paste&amp;height=358&amp;id=ua1f8f83a&amp;originHeight=671&amp;originWidth=1127&amp;originalType=binary&amp;ratio=1.875&amp;rotation=0&amp;showTitle=false&amp;size=251133&amp;status=done&amp;style=none&amp;taskId=ubea029b5-d163-43c4-b8c3-9f0e1c0ce53&amp;title=&amp;width=601.0666666666667" alt="image.png"></p>
<ul>
<li>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案<ol>
<li>悲观锁<ul>
<li>悲观锁认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行</li>
<li>例如Synchronized、Lock等，都是悲观锁</li>
</ul>
</li>
<li>乐观锁<ul>
<li>乐观锁认为线程安全问题不一定会发生，因此不加锁，只是在更新数据的时候再去判断有没有其他线程对数据进行了修改<ul>
<li>如果没有修改，则认为自己是安全的，自己才可以更新数据</li>
<li>如果已经被其他线程修改，则说明发生了安全问题，此时可以重试或者异常</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>悲观锁：悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</li>
<li>乐观锁：乐观锁会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如CAS</li>
<li>乐观锁的典型代表：就是CAS(Compare-And-Swap)，利用CAS进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 == 内存值，则代表中间没有被人修改过，此时就将新值去替换内存值</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/jpeg/43109882/1712989869230-1bc2f3f1-84c7-42a6-9614-2877443f791c.jpeg"></p>
<h6 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h6><p>只剩一张优惠券时，多个线程判断库存大于1，同时进行扣减，发生超卖问题<br>乐观锁：</p>
<ul>
<li>判断库存查询前后是否发生变化 -&gt; 多个线程拿到同一个库存，扣减成功的只有一个线程（失败）</li>
<li>修改数据库时判断库存大于0即可（优化）</li>
</ul>
<h6 id="一人一单失败"><a href="#一人一单失败" class="headerlink" title="一人一单失败"></a>一人一单失败</h6><p>用户开多个线程，在判断是否存在订单时，都判断不存在，导致一人一单失败<br>优化：把判断订单是否存在以及后续操作进行用户ID加锁<br>问题：集群下这样的锁是独立的，本地锁</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p><img src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/jpeg/43109882/1712992735044-a461bd3a-7076-4954-b55a-4b26cb2d8509.jpeg"></p>
<h6 id="误删锁①"><a href="#误删锁①" class="headerlink" title="误删锁①"></a>误删锁①</h6><p>自己的锁过期了，释放锁时把别人的锁释放了<br>优化：存锁时放入自己的线程标识，释放锁时判断一下</p>
<h6 id="误删锁②"><a href="#误删锁②" class="headerlink" title="误删锁②"></a>误删锁②</h6><p>极端情况下，在释放锁时判断是自己的锁，发生阻塞，在TTL过期后，其它进程拿到锁，再释放时误删<br>优化：把判断是否自己的锁和删除锁的操作放入lua脚本中</p>
<h3 id="分布式锁-Redisson"><a href="#分布式锁-Redisson" class="headerlink" title="分布式锁-Redisson"></a>分布式锁-Redisson</h3><p>SETNX存在以下问题</p>
<ul>
<li>重入问题：重入问题是指获取锁的线程，可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁</li>
<li>不可重试：获取锁时缺少重试机制，只能获取一次</li>
<li>超时释放：锁到时就释放，不能续锁</li>
<li>如果Redis提供了主从集群，那么当我们向集群写数据时，主机需要异步的将数据同步给从机，万一在同步之前，主机宕机了(主从同步存在延迟，虽然时间很短，但还是发生了)，那么又会出现死锁问题</li>
</ul>
<h6 id="解决可重入问题"><a href="#解决可重入问题" class="headerlink" title="解决可重入问题"></a>解决可重入问题</h6><p>利用锁计数计算重入次数；重入锁时，判断是否有锁，有的话就判断是否自己的锁，是的话锁计数加1；释放锁时类似<br><img src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712995804828-1b79dc5d-45b0-4b85-8a93-f56f560d4c8c.png#averageHue=%23bab3b3&amp;clientId=u5d98e9b1-cc09-4&amp;from=paste&amp;height=369&amp;id=u54c032ea&amp;originHeight=925&amp;originWidth=857&amp;originalType=binary&amp;ratio=1.875&amp;rotation=0&amp;showTitle=false&amp;size=451188&amp;status=done&amp;style=none&amp;taskId=u7f476801-d3d8-4a06-a57d-2ea241e8d59&amp;title=&amp;width=342.0666809082031" alt="image.png"></p>
<h6 id="Redisson锁重试和WatchDog机制"><a href="#Redisson锁重试和WatchDog机制" class="headerlink" title="Redisson锁重试和WatchDog机制"></a>Redisson锁重试和WatchDog机制</h6><p><img src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712996132092-04cf68f8-0c08-4550-ba00-ff84787a9346.png#averageHue=%23c8c5c5&amp;clientId=u5d98e9b1-cc09-4&amp;from=paste&amp;height=319&amp;id=ueacf7d4e&amp;originHeight=599&amp;originWidth=1260&amp;originalType=binary&amp;ratio=1.875&amp;rotation=0&amp;showTitle=false&amp;size=291001&amp;status=done&amp;style=none&amp;taskId=u0af0126f-278f-45a7-ba6f-7136300c7e4&amp;title=&amp;width=672" alt="image.png"><br>这部分有源码，复杂。。。</p>
<h6 id="Redisson锁的MutiLock原理"><a href="#Redisson锁的MutiLock原理" class="headerlink" title="Redisson锁的MutiLock原理"></a>Redisson锁的MutiLock原理</h6><p>使用联锁：<br>我们就需要将加锁的逻辑写入到每一个主从节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获取锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性</p>
<h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><ol>
<li>不可重入Redis分布式锁<ul>
<li>原理：利用SETNX的互斥性；利用EX避免死锁；释放锁时判断线程标识</li>
<li>缺陷：不可重入、无法重试、锁超时失效</li>
</ul>
</li>
<li>可重入Redis分布式锁<ul>
<li>原理：利用Hash结构，记录线程标识与重入次数；利用WatchDog延续锁时间；利用信号量控制锁重试等待</li>
<li>缺陷：Redis宕机引起锁失效问题</li>
</ul>
</li>
<li>Redisson的multiLock<ul>
<li>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功</li>
</ul>
</li>
</ol>
<h3 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h3><p><img src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712996694899-0795ff5b-033a-4871-9939-893034ce9d59.png#averageHue=%23c7c4c4&amp;clientId=u5d98e9b1-cc09-4&amp;from=paste&amp;height=258&amp;id=ucf0546a8&amp;originHeight=572&amp;originWidth=1202&amp;originalType=binary&amp;ratio=1.875&amp;rotation=0&amp;showTitle=false&amp;size=299166&amp;status=done&amp;style=none&amp;taskId=ue50006e3-0a93-454e-95f7-9cf69cc3cff&amp;title=&amp;width=541.1333618164062" alt="image.png"><br><img src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712996826487-c49e8dc7-2c8f-4113-b6cf-efd99c6933f0.png#averageHue=%23c2bebe&amp;clientId=u5d98e9b1-cc09-4&amp;from=paste&amp;height=255&amp;id=u880a2105&amp;originHeight=588&amp;originWidth=1255&amp;originalType=binary&amp;ratio=1.875&amp;rotation=0&amp;showTitle=false&amp;size=293812&amp;status=done&amp;style=none&amp;taskId=u3eb2ca76-439a-484b-a5fb-b1759ff1133&amp;title=&amp;width=544.1333618164062" alt="image.png"><br>把判断库存是否充足、判断是否下单过、扣减库存（在Redis的set中表示用户已经下过单了）这几个功能加入lua脚本中，返回结果表示是否下单成功<br>外面调用脚本获得结果，如果下单成功则将订单信息加入Redis缓存，再进行异步下单</p>
<h6 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h6><ul>
<li>秒杀业务的优化思路是什么？<ol>
<li>先利用Redis完成库存容量、一人一单的判断，完成抢单业务</li>
<li>再将下单业务放入阻塞队列，利用独立线程异步下单</li>
</ol>
</li>
<li>基于阻塞队列的异步秒杀存在哪些问题？<ol>
<li>内存限制问题：<ul>
<li>我们现在使用的是JDK里的阻塞队列，它使用的是JVM的内存，如果在高并发的条件下，无数的订单都会放在阻塞队列里，可能就会造成内存溢出，所以我们在创建阻塞队列时，设置了一个长度，但是如果真的存满了，再有新的订单来往里塞，那就塞不进去了，存在内存限制问题</li>
</ul>
</li>
<li>数据安全问题：<ul>
<li>经典服务器宕机了，用户明明下单了，但是数据库里没看到</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h3><p>基于List、PubSub、Stream的消息队列</p>
<h6 id="基于List实现消息队列"><a href="#基于List实现消息队列" class="headerlink" title="基于List实现消息队列"></a>基于List实现消息队列</h6><ul>
<li>基于List结构模拟消息队列</li>
<li>消息队列(Message Queue)，字面意思就是存放消息的队列，而Redis的list数据结构是一个双向链表，很容易模拟出队列的效果</li>
<li>队列的入口和出口不在同一边，所以我们可以利用：LPUSH结合RPOP或者RPUSH结合LPOP来实现消息队列。</li>
<li>不过需要注意的是，当队列中没有消息时，RPOP和LPOP操作会返回NULL，而不像JVM阻塞队列那样会阻塞，并等待消息，所以我们这里应该使用BRPOP或者BLPOP来实现阻塞效果</li>
<li>基于List的消息队列有哪些优缺点？<ul>
<li>优点<ol>
<li>利用Redis存储，不受限于JVM内存上限</li>
<li>基于Redis的持久化机制，数据安全性有保障</li>
<li>可以满足消息有序性</li>
</ol>
</li>
<li>缺点<ol>
<li>无法避免消息丢失(经典服务器宕机)</li>
<li>只支持单消费者(一个消费者把消息拿走了，其他消费者就看不到这条消息了)</li>
</ol>
</li>
</ul>
</li>
</ul>
<h6 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a>基于PubSub的消息队列</h6><ul>
<li>PubSub(发布订阅)是Redis2.0版本引入的消息传递模型。顾名思义，消费和可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息</li>
<li>SUBSCRIBE channel [channel]：订阅一个或多个频道</li>
<li>PUBLISH channel msg：向一个频道发送消息</li>
<li>PSUBSCRIBE pattern [pattern]：订阅与pattern格式匹配的所有频道</li>
<li>基于PubSub的消息队列有哪些优缺点<ul>
<li>优点：<ol>
<li>采用发布订阅模型，支持多生产，多消费</li>
</ol>
</li>
<li>缺点：<ol>
<li>不支持数据持久化</li>
<li>无法避免消息丢失（如果向频道发送了消息，却没有人订阅该频道，那发送的这条消息就丢失了）</li>
<li>消息堆积有上限，超出时数据丢失（消费者拿到数据的时候处理的太慢，而发送消息发的太快）</li>
</ol>
</li>
</ul>
</li>
</ul>
<h6 id="基于Stream的消息队列–消费者组"><a href="#基于Stream的消息队列–消费者组" class="headerlink" title="基于Stream的消息队列–消费者组"></a>基于Stream的消息队列–消费者组</h6><ul>
<li>消费者组(Consumer Group)：将多个消费者划分到一个组中，监听同一个队列，具备以下特点<ol>
<li>消息分流<ul>
<li>队列中的消息会分留给组内的不同消费者，而不是重复消费者，从而加快消息处理的速度</li>
</ul>
</li>
<li>消息标识<ul>
<li>消费者会维护一个标识，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标识之后读取消息，确保每一个消息都会被消费</li>
</ul>
</li>
<li>消息确认<ul>
<li>消费者获取消息后，消息处于pending状态，并存入一个pending-list，当处理完成后，需要通过XACK来确认消息，标记消息为已处理，才会从pending-list中移除</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>前一章将订单信息放入阻塞队列，这一章则放入Redis缓存中</p>
<h3 id="Caffeine实现多级缓存"><a href="#Caffeine实现多级缓存" class="headerlink" title="Caffeine实现多级缓存"></a>Caffeine实现多级缓存</h3><p> Caffeine + @Cacheable </p>
<ol>
<li><p>导入依赖</p>
</li>
<li><p>定义CaffeineCacheManager</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义缓存管理器，配合Spring的 <span class="doctag">@Cache</span> 来使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean("caffeineCacheManager")</span></span><br><span class="line"><span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">()</span> {</span><br><span class="line"> <span class="type">CaffeineCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CaffeineCacheManager</span>();</span><br><span class="line"> cacheManager.setCaffeine(Caffeine.newBuilder()</span><br><span class="line"> <span class="comment">// 设置过期时间，写入后五分钟过期</span></span><br><span class="line"> .expireAfterWrite(<span class="number">5</span>, TimeUnit.MINUTES)</span><br><span class="line"> <span class="comment">// 初始化缓存空间大小</span></span><br><span class="line"> .initialCapacity(<span class="number">100</span>)</span><br><span class="line"> <span class="comment">// 最大的缓存条数</span></span><br><span class="line"> .maximumSize(<span class="number">200</span>)</span><br><span class="line"> );</span><br><span class="line"> <span class="keyword">return</span> cacheManager;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>开启 @EnableCaching  注解支持</p>
</li>
<li><p>缓存使用实例</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用caffeine本地缓存，来处理侧边栏不怎么变动的消息</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * cacheNames -&gt; 类似缓存前缀的概念</span></span><br><span class="line"><span class="comment"> * key -&gt; SpEL 表达式，可以从传参中获取，来构建缓存的key</span></span><br><span class="line"><span class="comment"> * cacheManager -&gt; 缓存管理器，如果全局只有一个时，可以省略</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Cacheable(key = "'homeSidebar'", cacheManager = "caffeineCacheManager", cache</span></span><br><span class="line"><span class="meta">public List&lt;SideBarDTO&gt; queryHomeSidebarList() {</span></span><br><span class="line"><span class="meta"> List&lt;SideBarDTO&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="meta"> list.add(noticeSideBar());</span></span><br><span class="line"><span class="meta"> list.add(columnSideBar());</span></span><br><span class="line"><span class="meta"> list.add(hotArticles());</span></span><br><span class="line"><span class="meta"> return list;</span></span><br><span class="line"><span class="meta">}</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Cacheable(key = "'columnSidebar'", cacheManager = "caffeineCacheManager", cac</span></span><br><span class="line"><span class="meta">public List&lt;SideBarDTO&gt; queryColumnSidebarList() {</span></span><br><span class="line"><span class="meta"> List&lt;SideBarDTO&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="meta"> list.add(subscribeSideBar());</span></span><br><span class="line"><span class="meta"> return list;</span></span><br><span class="line"><span class="meta">}</span></span><br><span class="line"><span class="meta">/**</span></span><br><span class="line"><span class="meta"> * 以用户 + 文章维度进行缓存设置</span></span><br><span class="line"><span class="meta"> *</span></span><br><span class="line"><span class="meta"> * @param author 文章作者id</span></span><br><span class="line"><span class="meta"> * @param articleId 文章id</span></span><br><span class="line"><span class="meta"> * @return</span></span><br><span class="line"><span class="meta"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Cacheable(key = "'sideBar_' + #articleId", cacheManager = "caffeineCacheManag</span></span><br><span class="line"><span class="meta">public List&lt;SideBarDTO&gt; queryArticleDetailSidebarList(Long author, Long articl</span></span><br><span class="line"><span class="meta"> List&lt;SideBarDTO&gt; list = new ArrayList&lt;&gt;(2);</span></span><br><span class="line"><span class="meta"> // 不能直接使用 pdfSideBar()的方式调用，会导致缓存不生效</span></span><br><span class="line"><span class="meta"> list.add(SpringUtil.getBean(SidebarServiceImpl.class).pdfSideBar());</span></span><br><span class="line"><span class="meta"> list.add(recommendByAuthor(author, articleId, PageParam.DEFAULT_PAGE_SIZE)</span></span><br><span class="line"><span class="meta"> return list;</span></span><br><span class="line"><span class="meta">}</span></span><br><span class="line"><span class="meta">/**</span></span><br><span class="line"><span class="meta"> * PDF 优质资源</span></span><br><span class="line"><span class="meta"> *</span></span><br><span class="line"><span class="meta"> * @return</span></span><br><span class="line"><span class="meta"> */</span></span><br><span class="line"><span class="meta">@Cacheable(key = "'sideBar'", cacheManager = "caffeineCacheManager", cacheName</span></span><br><span class="line"><span class="meta">public SideBarDTO pdfSideBar() {</span></span><br><span class="line"><span class="meta"> List&lt;ConfigDTO&gt; pdfList = configService.getConfigList(ConfigTypeEnum.PDF);</span></span><br><span class="line"><span class="meta"> List&lt;SideBarItemDTO&gt; items = new ArrayList&lt;&gt;(pdfList.size());</span></span><br><span class="line"><span class="meta"> .... // 省略</span></span><br><span class="line"><span class="meta">}</span></span><br></pre></td></tr></tbody></table></figure>
<p> 注意事项1<br>重点注意上面的缓存注解 @Cacheable</p>
</li>
</ol>
<ul>
<li><p>cacheManager: 指定的就是前面配置类中注册的缓存管理器（so，前面的问题答案是不是有 了？）</p>
</li>
<li><p>cacheNames: 可以简单理解为缓存的前缀，比如上面分别是首页侧边栏，专栏侧边栏，文章 详情页侧边栏 </p>
</li>
<li><p>key: SpEL表达式，可以基于方法参数来生成对应的缓存key；若是常量字符串，用单引号包裹<br>:::success<br> 这个缓存注解，表明是优先从缓存中获取，缓存没有则执行方法内逻辑，并将返回的结果写入缓 存<br>:::<br> 注意事项2<br>其次需要注意的点是同一个service内部，若想要缓存注解生效，请不要直接内部调用，而是需要像 上面的 SpringUtil.getBean(xxx).xxx 的方式来中转一下，走代理调用<br>其它常用注解</p>
</li>
<li><p>@CacheEvict ：删除缓存</p>
</li>
<li><p>@CachePut : 方法执行完毕之后，主动将对应的结果写入缓存  </p>
</li>
<li><p>@Caching : 可以组合多个缓存注解使用</p>
</li>
</ul>
<p>最后小结一下Caffenine结合SpringBoot的使用姿势，非常简单</p>
<ol>
<li>添加jar包依赖</li>
<li>注册缓存管理器Bean: CacheManager</li>
<li>启动类上，添加 <a href="/EnableCaching">@EnableCaching </a> 注解 </li>
<li>在需要缓存的方法上，添加 <a href="/Cacheable">@Cacheable </a> , <a href="/CachePut">@CachePut </a> , <a href="/CacheEvit">@CacheEvit </a> , <a href="/Caching">@Caching </a> 注解 </li>
<li>然后大功告成</li>
</ol>
<h3 id="用户活跃排行榜"><a href="#用户活跃排行榜" class="headerlink" title="用户活跃排行榜"></a>用户活跃排行榜</h3><p>幂等策略：用Redis的hash结构保存记录<br>排行榜：用Redis的Zset实现排行榜<br><img src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/jpeg/43109882/1715246501472-3ba46414-c145-45b4-80b9-9f3c70473c90.jpeg"></p>
<h3 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h3><p>对于一些作者，他的文章发布是不需要审核的，就可以加入白名单<br>利用set结构来实现，具体方法实现不复杂，简单的set操作<br>四个方法： </p>
<ul>
<li>判断作者是否在文章发布的白名单中；  </li>
<li>获取所有的白名单用户  </li>
<li>将用户添加到白名单中  </li>
<li>从白名单中移除用户</li>
</ul>
<p>主要第一个方法，其他三个是后台管理的</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断作者是否再文章发布的白名单中；</span></span><br><span class="line"><span class="comment"> * 这个白名单主要是用于控制作者发文章之后是否需要进行审核</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> authorId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">authorInArticleWhiteList</span><span class="params">(Long authorId)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取所有的白名单用户</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;BaseUserInfoDTO&gt; <span class="title function_">queryAllArticleWhiteListAuthors</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将用户添加到白名单中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addAuthor2ArticleWhitList</span><span class="params">(Long userId)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从白名单中移除用户</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeAuthorFromArticelWhiteList</span><span class="params">(Long userId)</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://xingliu99.github.io">Xing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://xingliu99.github.io/2024/05/03/%E6%8A%80%E6%9C%AF%E6%B4%BE/">https://xingliu99.github.io/2024/05/03/%E6%8A%80%E6%9C%AF%E6%B4%BE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xingliu99.github.io" target="_blank">Xing's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%A1%B9%E7%9B%AE/">项目</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/20.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>欢迎打赏，有任何问题请联系我！</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/wechat.jpg" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/10/JUC/" title="JUC"><img class="cover" src="/img/loading.gif" data-original="/img/cover/7.jpg" onerror="onerror=null;src='/img/background.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JUC</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/20/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/" title="个人教程"><img class="cover" src="/img/loading.gif" data-original="/img/cover/2.jpg" onerror="onerror=null;src='/img/background.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">个人教程</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">Xing</div><div class="author-info__description">平平无奇的技术人</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xingliu-test"><i class="fab fa-github"></i><span>关注</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xingliu-test" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="mailto:948852460@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #hdhfbb;"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=948852460&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq" style="color: #hdhfbb;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">我可以是知识的搬运工，但我更喜欢分享知识。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E5%85%B3%E5%AE%9E%E7%8E%B0JWT%E7%9A%84%E8%AE%A4%E8%AF%81"><span class="toc-number">1.</span> <span class="toc-text">网关实现JWT的认证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%9A%E5%91%98%E5%88%B8%E6%8A%A2%E8%B4%AD%E5%8A%9F%E8%83%BD-%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">会员券抢购功能 &amp; 缓存问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Caffeine%E5%8A%A0Redis%E6%9E%84%E5%BB%BA%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">3.</span> <span class="toc-text">使用Caffeine加Redis构建多级缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-ControllerAdvice-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">使用 ControllerAdvice  全局异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal-%E5%B0%81%E8%A3%85%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-number">5.</span> <span class="toc-text">ThreadLocal  封装用户信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">6.</span> <span class="toc-text">日志访问控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RedisTemplate%E4%BD%BF%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text">RedisTemplate使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95"><span class="toc-number">8.</span> <span class="toc-text">短信登录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%95%86%E6%88%B7%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">9.</span> <span class="toc-text">商户查询缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">9.0.0.1.</span> <span class="toc-text">缓存更新策略</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-number">9.0.0.2.</span> <span class="toc-text">缓存穿透问题解决</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98"><span class="toc-number">9.0.0.3.</span> <span class="toc-text">缓存雪崩问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">9.0.0.4.</span> <span class="toc-text">缓存击穿</span></a></li></ol></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80"><span class="toc-number">10.</span> <span class="toc-text">优惠券秒杀</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-number">10.0.0.1.</span> <span class="toc-text">超卖问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95%E5%A4%B1%E8%B4%A5"><span class="toc-number">10.0.0.2.</span> <span class="toc-text">一人一单失败</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">11.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%AF%E5%88%A0%E9%94%81%E2%91%A0"><span class="toc-number">11.0.0.1.</span> <span class="toc-text">误删锁①</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%AF%E5%88%A0%E9%94%81%E2%91%A1"><span class="toc-number">11.0.0.2.</span> <span class="toc-text">误删锁②</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redisson"><span class="toc-number">12.</span> <span class="toc-text">分布式锁-Redisson</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%8F%AF%E9%87%8D%E5%85%A5%E9%97%AE%E9%A2%98"><span class="toc-number">12.0.0.1.</span> <span class="toc-text">解决可重入问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Redisson%E9%94%81%E9%87%8D%E8%AF%95%E5%92%8CWatchDog%E6%9C%BA%E5%88%B6"><span class="toc-number">12.0.0.2.</span> <span class="toc-text">Redisson锁重试和WatchDog机制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Redisson%E9%94%81%E7%9A%84MutiLock%E5%8E%9F%E7%90%86"><span class="toc-number">12.0.0.3.</span> <span class="toc-text">Redisson锁的MutiLock原理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">12.0.0.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96"><span class="toc-number">13.</span> <span class="toc-text">秒杀优化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">13.0.0.1.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">14.</span> <span class="toc-text">Redis消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EList%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">14.0.0.1.</span> <span class="toc-text">基于List实现消息队列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EPubSub%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">14.0.0.2.</span> <span class="toc-text">基于PubSub的消息队列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EStream%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%93%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84"><span class="toc-number">14.0.0.3.</span> <span class="toc-text">基于Stream的消息队列–消费者组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Caffeine%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">15.</span> <span class="toc-text">Caffeine实现多级缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%B4%BB%E8%B7%83%E6%8E%92%E8%A1%8C%E6%A6%9C"><span class="toc-number">16.</span> <span class="toc-text">用户活跃排行榜</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BD%E5%90%8D%E5%8D%95"><span class="toc-number">17.</span> <span class="toc-text">白名单</span></a></li></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2023 - 2025 By Xing</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">在世界的角落，有一群热爱生活的孩子。<br> <span id="realtime_duration"></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据整理中...</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="关键字呢" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.13.0/js/search/local-search.min.js"></script></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa-solid fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa-solid fa-book"></i><span>阅读模式</span></a><a class="rightMenu-item" href="javascript:rmf.copyPostUrl();"><i class="fa-solid fa-copy"></i><span>复制本文地址</span></a><a class="rightMenu-item" href="/comment/"><i class="fa-solid fa-copy"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:rmf.openLinkInNewWindow();"><i class="fa-solid fa-link"></i><span>打开链接</span></a><a class="rightMenu-item" href="javascript:rmf.switchLanguageMode();"><i class="fa-solid fa-language"></i><span>繁简转换</span></a></div></div><div><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.13.0/js/utils.min.js"></script><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.13.0/js/main.min.js"></script><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.13.0/js/tw_cn.min.js"></script><script src="https://cdn.staticfile.org/medium-zoom/1.1.0/medium-zoom.min.js"></script><script src="https://cdn.staticfile.org/vanilla-lazyload/17.8.8/lazyload.iife.min.js"></script><script src="https://cdn.staticfile.org/node-snackbar/0.1.16/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.staticfile.org/pangu/4.0.7/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script src="https://cdn.staticfile.net/jquery/3.7.1/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script><script type="text/javascript" src="/js/rightmenu.js"></script><script src="https://cdn.jsdelivr.net/npm/vue-notification@1.3.20/dist/index.min.js"></script><script type="text/javascript" src="/js/weather.js"></script><script async="" src="/js/title.js"></script><script async="" src="/js/weather.js"></script><script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.7/dayjs.min.js"></script><script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.7/plugin/duration.min.js"></script><script src="/js/realtime.js"></script><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><div class="aplayer" data-id="26467411" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="none" data-autoplay="false" muted=""></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="141,244,244 " opacity="1" zindex="-1" count="66" mobile="false" src="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/canvas-nest.min.js"></script><script src="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><script src="https://cdn.staticfile.org/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据整理中...</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="关键字呢" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.13.0/js/search/local-search.min.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>