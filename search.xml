<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RabbitMQ八股文之路</title>
      <link href="/2024/07/30/RabbitMQ%E5%85%AB%E8%82%A1/"/>
      <url>/2024/07/30/RabbitMQ%E5%85%AB%E8%82%A1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>参考文章：<a href="https://cloud.tencent.com/developer/article/2233645">爆肝3万字，为你吃透RabbitMQ，最详细的RabbitMQ讲解（VIP典藏版）-腾讯云开发者社区-腾讯云</a></p><h2 id="MQ的概念"><a href="#MQ的概念" class="headerlink" title="MQ的概念"></a>MQ的概念</h2><ul><li><code>publisher</code>：生产者，也就是发送消息的一方</li><li><code>consumer</code>：消费者，也就是消费消息的一方</li><li><code>queue</code>：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li><code>exchange</code>：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。</li><li><code>virtual host</code>：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue<blockquote><p>MQ是一种具有接收数据、储存数据、发送数据等功能的技术服务，是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务，用于上下游传递消息</p></blockquote></li></ul><h2 id="MQ的消息模式"><a href="#MQ的消息模式" class="headerlink" title="MQ的消息模式"></a>MQ的消息模式</h2><h3 id="简单模式"><a href="#简单模式" class="headerlink" title="简单模式"></a>简单模式</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1722259768203-3bbf0078-acd1-4d72-ae60-7c67ccf27f74.png#averageHue=%23fbeeee&clientId=u0b75c34a-308d-4&from=paste&height=161&id=u37c56a7d&originHeight=242&originWidth=513&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=15006&status=done&style=none&taskId=u668693a7-f93d-4fae-b99d-2830d953604&title=&width=342" alt="image.png"></p><blockquote><p>一个生产者，一个消费者，一个队列，采用默认交换机。可以理解为生产者P发送消息到队列Q，一个消费者C接收。</p></blockquote><h3 id="工作模式（WorkQueues）"><a href="#工作模式（WorkQueues）" class="headerlink" title="工作模式（WorkQueues）"></a>工作模式（WorkQueues）</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1722259834708-f15d55de-a277-47fa-a695-ef4611dd6a67.png#averageHue=%23fae8e8&clientId=u0b75c34a-308d-4&from=paste&height=163&id=u481888cf&originHeight=244&originWidth=474&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=22090&status=done&style=none&taskId=u30490729-0e0e-4e6d-9646-deb513c659e&title=&width=316" alt="image.png"></p><blockquote><p>一个生产者，多个消费者，一个队列，采用默认交换机。可以理解为生产者P发送消息到队列Q，可以由多个消费者C1、C2进行接收。</p></blockquote><h3 id="发布订阅模式（fanout）"><a href="#发布订阅模式（fanout）" class="headerlink" title="发布订阅模式（fanout）"></a>发布订阅模式（fanout）</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1722259865344-2982ee6b-84bb-4df8-b3a9-2cf58a8fad01.png#averageHue=%23f8dada&clientId=u0b75c34a-308d-4&from=paste&height=166&id=ud83bd66b&originHeight=249&originWidth=625&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=33911&status=done&style=none&taskId=u36d2db11-abec-4258-869e-e0c9edf9142&title=&width=417" alt="image.png"></p><blockquote><p>一个生产者、一个 fanout 类型的交换机、多个队列、多个消费者。一个生产者发送的消息会被多个消费者获取。其中 fanout 类型就是发布订阅模式，只有订阅该生产者的消费者会收到消息。</p></blockquote><h3 id="路由模式（direct）"><a href="#路由模式（direct）" class="headerlink" title="路由模式（direct）"></a>路由模式（direct）</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1722259913926-7d51536e-488d-47de-ae13-935e895c96f9.png#averageHue=%23f2e3e3&clientId=u0b75c34a-308d-4&from=paste&height=184&id=u8781c4c8&originHeight=276&originWidth=514&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=41582&status=done&style=none&taskId=u13d4c7ab-b568-4bd4-96b2-6a981aa7a64&title=&width=342.6666666666667" alt="image.png"></p><blockquote><p>一个生产者，一个 direct 类型的交换机，多个队列，交换机与队列之间通过 routing-key 进行关联绑定，多个消费者。生产者发送消息到交换机并且要指定routing-key，然后消息根据这交换机与队列之间的 routing-key 绑定规则进行路由被指定消费者消费。</p></blockquote><h3 id="主题模式（topic）"><a href="#主题模式（topic）" class="headerlink" title="主题模式（topic）"></a>主题模式（topic）</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1722259935904-c30f57d5-98d5-44ef-8f9c-3894ce326ccd.png#averageHue=%23f4e5e5&clientId=u0b75c34a-308d-4&from=paste&height=185&id=u630dd7b7&originHeight=278&originWidth=479&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=33623&status=done&style=none&taskId=ub182b310-8479-4ef1-a5dc-49e3d3a88ac&title=&width=319.3333333333333" alt="image.png"></p><blockquote><p>一个生产者，一个 topic 类型的交换机，多个队列，交换机与队列之间通过 routing-key 进行关联绑定，多个消费者。生产者发送消息到交换机并且要指定 routing-key，然后消息根据这交换机与队列之间的 routing-key 绑定规则进行路由被指定消费者消费。与路由模式不同是 routing-key 有指定的队则，可以更加的通用，满足更过的场景。routing-key 的规则如下：</p></blockquote><ul><li><code>#</code>：匹配一个或者多个词，例如<code>lazy.#</code> 可以匹配 lazy.xxx 或者 lazy.xxx.xxx</li><li><code>*</code>：只能匹配一个词，例如<code>lazy.*</code> 只能匹配 lazy.xxx</li></ul><h3 id="参数模式"><a href="#参数模式" class="headerlink" title="参数模式"></a>参数模式</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1722259960852-43f6fc56-812f-46ad-90df-f1e3702710a0.png#averageHue=%23efe4e4&clientId=u0b75c34a-308d-4&from=paste&height=187&id=ued33f3c3&originHeight=281&originWidth=624&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=44560&status=done&style=none&taskId=uef62e762-b128-4530-9084-e8d2e081f95&title=&width=416" alt="image.png"></p><blockquote><p>可以携带参数，根据参数进行过滤：</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1722260385759-f3bbd527-dce7-444c-a333-f94971d531d4.png#averageHue=%23f8f7f7&clientId=u0b75c34a-308d-4&from=paste&height=342&id=u6eb9346b&originHeight=513&originWidth=570&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=36190&status=done&style=none&taskId=u20cc5482-06f7-4880-a73a-4d3b32da9a1&title=&width=380" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1722260416415-d8c268f8-5e69-4c7d-b976-f29521f98ef8.png#averageHue=%23fbfbfb&clientId=u0b75c34a-308d-4&from=paste&height=407&id=u123e045b&originHeight=610&originWidth=1113&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=43103&status=done&style=none&taskId=ue5c7b3db-2e2a-47c8-b756-9bfa8af4e3b&title=&width=742" alt="image.png"></p><blockquote><p>一般来说，都是使用中间四种比较多，也有不一般的时候，面试尽量都提一下</p></blockquote><h2 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h2><h3 id="生产者角度"><a href="#生产者角度" class="headerlink" title="生产者角度"></a>生产者角度</h3><h4 id="生产者重试机制"><a href="#生产者重试机制" class="headerlink" title="生产者重试机制"></a>生产者重试机制</h4><p>出现网络问题时，与MQ的连接中断，可以开启<code>SpringAMQP</code>的重试机制，但是这种重试机制是阻塞的，对性能有要求的话一般不建议开启。（理解模糊的话只需要知道是在连接MQ时超时后进行重试连接就行）</p><h4 id="生产者确认"><a href="#生产者确认" class="headerlink" title="生产者确认"></a>生产者确认</h4><p>这是MQ的收到消息后的确认机制，包括三种模式：关闭确认；同步阻塞等待确认；异步回调确认<br>消息投递回执标识：</p><ul><li>当消息投递到MQ，但是路由失败时，通过<strong>Publisher Return</strong>返回异常信息，同时返回ack的确认信息，代表投递成功</li><li>临时消息投递到了MQ，并且入队成功，返回ACK，告知投递成功</li><li>持久消息投递到了MQ，并且入队完成持久化，返回ACK ，告知投递成功</li><li>其它情况都会返回NACK，告知投递失败</li></ul><p>每个<code>RabbitTemplate</code>只能配置一个<code>ReturnCallback</code>，这个可以处理所有的消息接收失败的情况<br>也可以定义<code>ConfirmCallback</code>，是在调用RabbitTemplate中的convertAndSend方法时，多传递一个参数<code>CorrelationData</code></p><h3 id="MQ角度"><a href="#MQ角度" class="headerlink" title="MQ角度"></a>MQ角度</h3><h4 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h4><p>为了提升性能，默认情况下MQ的数据都是在内存存储的临时数据，重启后就会消失。为了保证数据的可靠性，必须配置数据持久化，包括：</p><ul><li>交换机持久化</li><li>队列持久化</li><li>消息持久化</li></ul><h4 id="LazyQueue"><a href="#LazyQueue" class="headerlink" title="LazyQueue"></a>LazyQueue</h4><p>此方法是为了在出现某些情况后，导致消息堆积问题。<br>为了解决这个问题，从RabbitMQ的3.6.0版本开始，就增加了Lazy Queues的模式，也就是惰性队列。惰性队列的特征如下：</p><ul><li>接收到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存（也就是懒加载）</li><li>支持数百万条的消息存储</li></ul><h3 id="消费者角度"><a href="#消费者角度" class="headerlink" title="消费者角度"></a>消费者角度</h3><h4 id="消费者确认机制"><a href="#消费者确认机制" class="headerlink" title="消费者确认机制"></a>消费者确认机制</h4><p>此机制是为了告诉MQ自己对消息的处理状态，以便MQ对消息进行处理</p><ol><li>成功处理，消息从队列删除</li><li>处理失败，再次投递</li><li>处理失败并拒绝处理，直接删除</li></ol><p>处理方式有不处理、手动处理、自动处理，最后一个是根据抛出的异常进行处理，类似于事务的回滚条件<br>当抛出业务异常时，说明内部执行出现了异常，需要再次投递；<br>当抛出一些特定异常时（如消息转换异常）时，会拒绝处理</p><h4 id="失败重试机制"><a href="#失败重试机制" class="headerlink" title="失败重试机制"></a>失败重试机制</h4><p>在消费失败后，不是将消息直接返回到队列，而是先在本地进行尝试重新消费，在一定次数后会返回拒绝异常，丢弃该消息<br>当然这种实际上并不合适，我们可以自定义消息处理策略，比如将这个消息投递到特定队列转人工处理</p><h4 id="消息幂等性"><a href="#消息幂等性" class="headerlink" title="消息幂等性"></a>消息幂等性</h4><ol><li>每个消息生成唯一id，处理后把id存入数据库，处理前查询数据库是否存在id</li><li>基于业务判断，比如修改某个状态时判断是否修改过了再进行处理</li></ol><h2 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h2><p>死信（dead letter）：</p><ul><li>消费者使用<code>basic.reject</code>或 <code>basic.nack</code>声明消费失败，并且消息的<code>requeue</code>参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul><h3 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h3><p>利用消息在到达消息过期时间后会自动将消息路由到死信交换机的特性，完成延迟队列<br>但是当消息堆积很多的时候，由于处理效率问题，过期消息可能在过期一段时间后才处理</p><h3 id="DelayExchange插件"><a href="#DelayExchange插件" class="headerlink" title="DelayExchange插件"></a>DelayExchange插件</h3><p>官方社区提供了这么一个插件来实现延迟队列，具体代码实现不用过多讲解，知道有这么个东西就行了。</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol><li><p>什么是MQ</p><blockquote><p>MQ是消息队列，一种先进先出的队列，主要用于消息的接收、存储和转发，实现消息通信的解耦</p></blockquote></li><li><p>为什么使用MQ</p><blockquote><ul><li>流量削峰：使用消息队列做缓冲，减少大量请求的冲击</li><li>应用解耦：使用消息队列进行通信，不用关心其他系统的情况</li><li>异步处理：将一些业务流程进行异步执行，而不是阻塞时等待执行完成</li><li>消息分发：将消息按照特定的规则进行分发</li></ul></blockquote></li><li><p>MQ的优缺点</p><blockquote><p>优点：解耦、削峰、异步<br>缺点：</p><ol><li>系统可用性降低，如果消息队列宕机，问题就很大</li><li>系统复杂度提高，引入消息队列需要考虑的东西就更多了，消息重复消费。。。</li><li>一致性问题，不同系统之间的执行状态可能并不是都会成功，一个环节不成功此业务还能算成功吗</li></ol></blockquote></li><li><p>MQ有什么常见问题</p><blockquote><p>消息的顺序问题：保证消息的产生顺序与消费顺序相同<br>使用多个队列和消费者，保证队列和消费者一对一对应，接收到消费者内部进行统一处理<br>消息的重复问题：消息的幂等性问题</p><ul><li>使用唯一ID进行消息区分</li><li>业务逻辑中进行幂等性控制</li></ul></blockquote></li><li><p>MQ有哪些工作模式</p><blockquote><p>简单模式：简单的进行消息的推送和消费<br>工作模式：一个队列有多个消费者<br>发布订阅：<code>fanout</code>交换机，将消息发送给订阅了的消费者<br>路由模式：<code>direct</code>交换机，通过一些关键字进行消息路由<br>主题模式：<code>topic</code>交换机，通过表达式进行路由，功能更加强大<br>参数模式：<code>headers</code>交换机，通过满足参数时进行路由</p></blockquote></li><li><p>消息基于什么传输</p><blockquote><p>由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ 使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制。</p></blockquote></li><li><p>如何确保消息传输的可靠性</p><blockquote><ul><li>生产者存在连接的重试机制，并且还有消息投递的确认机制</li><li>MQ会对交换机、队列、消息进行持久化</li><li>消费者这边会进行消费确认，通知MQ消息消费结果；也可以开启本地的消息消费重试；最后会采用一些办法达到幂等性</li></ul></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ进阶</title>
      <link href="/2024/07/28/MQ%E9%AB%98%E7%BA%A7/"/>
      <url>/2024/07/28/MQ%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>我们必须尽可能确保MQ消息的可靠性，即：消息应该至少被消费者处理1次<br>那么问题来了：</p><ul><li><strong>我们该如何确保MQ消息的可靠性</strong>？</li><li><strong>如果真的发送失败，有没有其它的兜底方案？</strong></li></ul><p>这些问题，在后续的资料中都会找到答案。</p><h1 id="发送者的可靠性"><a href="#发送者的可靠性" class="headerlink" title="发送者的可靠性"></a>发送者的可靠性</h1><p>首先，我们一起分析一下消息丢失的可能性有哪些。<br>消息从发送者发送消息，到消费者处理消息，需要经过的流程是这样的：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1687334552247-cab38ab5-ae63-4f06-9ece-e9f244e3c170.jpeg#averageHue=%23fcf6f0&id=fh2c3&originHeight=487&originWidth=1338&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>消息从生产者到消费者的每一步都可能导致消息丢失：</p><ul><li>发送消息时丢失：<ul><li>生产者发送消息时连接MQ失败</li><li>生产者发送消息到达MQ后未找到<code>Exchange</code></li><li>生产者发送消息到达MQ的<code>Exchange</code>后，未找到合适的<code>Queue</code></li><li>消息到达MQ后，处理消息的进程发生异常</li></ul></li><li>MQ导致消息丢失：<ul><li>消息到达MQ，保存到队列后，尚未消费就突然宕机</li></ul></li><li>消费者处理消息时：<ul><li>消息接收后尚未处理突然宕机</li><li>消息接收后处理过程中抛出异常</li></ul></li></ul><p>综上，我们要解决消息丢失问题，保证MQ的可靠性，就必须从3个方面入手：</p><ul><li>确保生产者一定把消息发送到MQ</li><li>确保MQ不会将消息弄丢</li><li>确保消费者一定要处理消息</li></ul><p>这一章我们先来看如何确保生产者一定能把消息发送到MQ。</p><h2 id="生产者重试机制"><a href="#生产者重试机制" class="headerlink" title="生产者重试机制"></a>生产者重试机制</h2><p>首先第一种情况，就是生产者发送消息时，出现了网络故障，导致与MQ的连接中断。<br>为了解决这个问题，SpringAMQP提供的消息发送时的重试机制。即：当<code>RabbitTemplate</code>与MQ连接超时后，多次重试。<br>修改<code>publisher</code>模块的<code>application.yaml</code>文件，添加下面的内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="string">1s</span> <span class="comment"># 设置MQ的连接超时时间</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启超时重试机制</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 失败后的初始等待时间</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br></pre></td></tr></table></figure><p>我们利用命令停掉RabbitMQ服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop mq</span><br></pre></td></tr></table></figure><p>然后测试发送一条消息，会发现会每隔1秒重试1次，总共重试了3次。消息发送的超时重试机制配置成功了！<br>:::warning<br><strong>注意</strong>：当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率。不过SpringAMQP提供的重试机制是<strong>阻塞式</strong>的重试，也就是说多次重试等待的过程中，当前线程是被阻塞的。<br>如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，当然也可以考虑使用异步线程来执行发送消息的代码。<br>:::</p><h2 id="生产者确认机制"><a href="#生产者确认机制" class="headerlink" title="生产者确认机制"></a>生产者确认机制</h2><p>一般情况下，只要生产者与MQ之间的网路连接顺畅，基本不会出现发送消息丢失的情况，因此大多数情况下我们无需考虑这种问题。<br>不过，在少数情况下，也会出现消息发送到MQ之后丢失的现象，比如：</p><ul><li>MQ内部处理消息的进程发生了异常</li><li>生产者发送消息到达MQ后未找到<code>Exchange</code></li><li>生产者发送消息到达MQ的<code>Exchange</code>后，未找到合适的<code>Queue</code>，因此无法路由</li></ul><p>针对上述情况，RabbitMQ提供了生产者消息确认机制，包括<code>Publisher Confirm</code>和<code>Publisher Return</code>两种。在开启确认机制的情况下，当生产者发送消息给MQ后，MQ会根据消息处理的情况返回不同的<strong>回执</strong>。<br>具体如图所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1690366611659-d5c7f355-7ab1-4eb8-8488-13e1d98843ce.png#averageHue=%23faf7f7&clientId=ucb403171-cc9e-4&from=paste&height=376&id=ue3c6e070&originHeight=466&originWidth=1434&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=81765&status=done&style=none&taskId=ue6af669a-1775-4a0f-ad77-cd9bc059880&title=&width=1156.8402990504578#averageHue=%23faf7f7&id=U970m&originHeight=466&originWidth=1434&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>总结如下：</p><ul><li>当消息投递到MQ，但是路由失败时，通过<strong>Publisher Return</strong>返回异常信息，同时返回ack的确认信息，代表投递成功</li><li>临时消息投递到了MQ，并且入队成功，返回ACK，告知投递成功</li><li>持久消息投递到了MQ，并且入队完成持久化，返回ACK ，告知投递成功</li><li>其它情况都会返回NACK，告知投递失败</li></ul><p>其中<code>ack</code>和<code>nack</code>属于<strong>Publisher Confirm</strong>机制，<code>ack</code>是投递成功；<code>nack</code>是投递失败。而<code>return</code>则属于<strong>Publisher Return</strong>机制。<br>默认两种机制都是关闭状态，需要通过配置文件来开启。</p><h2 id="实现生产者确认"><a href="#实现生产者确认" class="headerlink" title="实现生产者确认"></a>实现生产者确认</h2><h3 id="开启生产者确认"><a href="#开启生产者确认" class="headerlink" title="开启生产者确认"></a>开启生产者确认</h3><p>在publisher模块的<code>application.yaml</code>中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启publisher confirm机制，并设置confirm类型</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 开启publisher return机制</span></span><br></pre></td></tr></table></figure><p>这里<code>publisher-confirm-type</code>有三种模式可选：</p><ul><li><code>none</code>：关闭confirm机制</li><li><code>simple</code>：同步阻塞等待MQ的回执</li><li><code>correlated</code>：MQ异步回调返回回执</li></ul><p>一般我们推荐使用<code>correlated</code>，回调机制。</p><h3 id="定义ReturnCallback"><a href="#定义ReturnCallback" class="headerlink" title="定义ReturnCallback"></a>定义ReturnCallback</h3><p>每个<code>RabbitTemplate</code>只能配置一个<code>ReturnCallback</code>，因此我们可以在配置类中统一设置。我们在publisher模块定义一个配置类：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687341529298-150b401d-67f9-4958-acdb-0d3147b0532b.png#averageHue=%23f9fbf8&clientId=ue4302575-73b6-4&from=paste&height=278&id=u6d09b8df&originHeight=345&originWidth=808&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=33987&status=done&style=none&taskId=uf816a0ec-4ff4-4c09-bffc-766884fb5e7&title=&width=651.8319118778032#averageHue=%23f9fbf8&id=lRngw&originHeight=345&originWidth=808&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.publisher.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.ReturnedMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returned)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;触发return callback,&quot;</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;exchange: &#123;&#125;&quot;</span>, returned.getExchange());</span><br><span class="line">                log.debug(<span class="string">&quot;routingKey: &#123;&#125;&quot;</span>, returned.getRoutingKey());</span><br><span class="line">                log.debug(<span class="string">&quot;message: &#123;&#125;&quot;</span>, returned.getMessage());</span><br><span class="line">                log.debug(<span class="string">&quot;replyCode: &#123;&#125;&quot;</span>, returned.getReplyCode());</span><br><span class="line">                log.debug(<span class="string">&quot;replyText: &#123;&#125;&quot;</span>, returned.getReplyText());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义ConfirmCallback"><a href="#定义ConfirmCallback" class="headerlink" title="定义ConfirmCallback"></a>定义ConfirmCallback</h3><p>由于每个消息发送时的处理逻辑不一定相同，因此ConfirmCallback需要在每次发消息时定义。具体来说，是在调用RabbitTemplate中的convertAndSend方法时，多传递一个参数：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687348187394-21a3698a-277a-478b-8cb8-2ee5bc79207f.png#averageHue=%23f1efed&clientId=ue4302575-73b6-4&from=paste&height=167&id=ubbb0d508&originHeight=207&originWidth=939&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=26725&status=done&style=none&taskId=u0ffba104-eb55-4f79-be54-f249333680d&title=&width=757.5125807589818#averageHue=%23f1efed&id=xCtL7&originHeight=207&originWidth=939&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>这里的CorrelationData中包含两个核心的东西：</p><ul><li><code>id</code>：消息的唯一标示，MQ对不同的消息的回执以此做判断，避免混淆</li><li><code>SettableListenableFuture</code>：回执结果的Future对象</li></ul><p>将来MQ的回执就会通过这个<code>Future</code>来返回，我们可以提前给<code>CorrelationData</code>中的<code>Future</code>添加回调函数来处理消息回执：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687348449866-dee08277-6bc9-4463-9cb8-95013e05a6a2.png#averageHue=%23f3f2f0&clientId=ue4302575-73b6-4&from=paste&height=194&id=u536cb2c1&originHeight=241&originWidth=940&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=26129&status=done&style=none&taskId=u1d347aea-f7e9-43e2-875e-773b69e1bdf&title=&width=758.3193034221969#averageHue=%23f3f2f0&id=jxyLD&originHeight=241&originWidth=940&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>我们新建一个测试，向系统自带的交换机发送消息，并且添加<code>ConfirmCallback</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherConfirm</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建CorrelationData</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>();</span><br><span class="line">    <span class="comment">// 2.给Future添加ConfirmCallback</span></span><br><span class="line">    cd.getFuture().addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">            <span class="comment">// 2.1.Future发生异常时的处理逻辑，基本不会触发</span></span><br><span class="line">            log.error(<span class="string">&quot;send message fail&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(CorrelationData.Confirm result)</span> &#123;</span><br><span class="line">            <span class="comment">// 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容</span></span><br><span class="line">            <span class="keyword">if</span>(result.isAck())&#123; <span class="comment">// result.isAck()，boolean类型，true代表ack回执，false 代表 nack回执</span></span><br><span class="line">                log.debug(<span class="string">&quot;发送消息成功，收到 ack!&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// result.getReason()，String类型，返回nack时的异常描述</span></span><br><span class="line">                log.error(<span class="string">&quot;发送消息失败，收到 nack, reason : &#123;&#125;&quot;</span>, result.getReason());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 3.发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;hmall.direct&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;hello&quot;</span>, cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687351726363-c27337c1-cd6e-497e-96ad-ac55fe4cb9e4.png#averageHue=%23f9f6df&clientId=ue4302575-73b6-4&from=paste&height=321&id=u37548b33&originHeight=398&originWidth=1657&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=224878&status=done&style=none&taskId=u5b86f40b-a7f8-4c5f-8fae-4edb9ab2cee&title=&width=1336.7394529474257#averageHue=%23f9f6df&id=mDDMc&originHeight=398&originWidth=1657&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>可以看到，由于传递的<code>RoutingKey</code>是错误的，路由失败后，触发了<code>return callback</code>，同时也收到了ack。<br>当我们修改为正确的<code>RoutingKey</code>以后，就不会触发<code>return callback</code>了，只收到ack。<br>而如果连交换机都是错误的，则只会收到nack。<br>:::warning<br><strong>注意</strong>：<br>开启生产者确认比较消耗MQ性能，一般不建议开启。而且大家思考一下触发确认的几种情况：</p><ul><li>路由失败：一般是因为RoutingKey错误导致，往往是编程导致</li><li>交换机名称错误：同样是编程错误导致</li><li>MQ内部故障：这种需要处理，但概率往往较低。因此只有对消息可靠性要求非常高的业务才需要开启，而且仅仅需要开启ConfirmCallback处理nack就可以了。<br>:::</li></ul><h1 id="MQ的可靠性"><a href="#MQ的可靠性" class="headerlink" title="MQ的可靠性"></a>MQ的可靠性</h1><p>消息到达MQ以后，如果MQ不能及时保存，也会导致消息丢失，所以MQ的可靠性也非常重要。</p><h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>为了提升性能，默认情况下MQ的数据都是在内存存储的临时数据，重启后就会消失。为了保证数据的可靠性，必须配置数据持久化，包括：</p><ul><li>交换机持久化</li><li>队列持久化</li><li>消息持久化</li></ul><p>我们以控制台界面为例来说明。</p><h3 id="交换机持久化"><a href="#交换机持久化" class="headerlink" title="交换机持久化"></a>交换机持久化</h3><p>在控制台的<code>Exchanges</code>页面，添加交换机时可以配置交换机的<code>Durability</code>参数：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687353601905-9b09c0df-1b03-49e1-95c8-437ef9f3cd81.png#averageHue=%23f9f8f8&clientId=ue4302575-73b6-4&from=paste&height=281&id=Kve5K&originHeight=348&originWidth=922&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=22552&status=done&style=none&taskId=u9ff1f541-056b-4c91-a4e3-ce6890f4d00&title=&width=743.798295484325#averageHue=%23f9f8f8&id=yosmc&originHeight=348&originWidth=922&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>设置为<code>Durable</code>就是持久化模式，<code>Transient</code>就是临时模式。</p><h3 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h3><p>在控制台的Queues页面，添加队列时，同样可以配置队列的<code>Durability</code>参数：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687353771968-5c560b86-a1ae-4649-8597-c7ebfeffa9a5.png#averageHue=%23f8f7f6&clientId=ue4302575-73b6-4&from=paste&height=295&id=I03Rh&originHeight=366&originWidth=1130&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=30872&status=done&style=none&taskId=u7425f64c-6c68-4b86-a558-9c10f825f3f&title=&width=911.5966094330664#averageHue=%23f8f7f6&id=kVs4C&originHeight=366&originWidth=1130&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>除了持久化以外，你可以看到队列还有很多其它参数，有一些我们会在后期学习。</p><h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>在控制台发送消息的时候，可以添加很多参数，而消息的持久化是要配置一个<code>properties</code>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687354083723-84971642-712d-42bc-ba65-6e3b3b33758c.png#averageHue=%23faf8f8&clientId=ue4302575-73b6-4&from=paste&height=423&id=T4xqJ&originHeight=524&originWidth=995&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=17663&status=done&style=none&taskId=u75d6c2e2-1770-43f8-9a9f-9bc5f480099&title=&width=802.6890498990275#averageHue=%23faf8f8&id=CmLxe&originHeight=524&originWidth=995&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>:::warning<br><strong>说明</strong>：在开启持久化机制以后，如果同时还开启了生产者确认，那么MQ会在消息持久化以后才发送ACK回执，进一步确保消息的可靠性。<br>不过出于性能考虑，为了减少IO次数，发送到MQ的消息并不是逐条持久化到数据库的，而是每隔一段时间批量持久化。一般间隔在100毫秒左右，这就会导致ACK有一定的延迟，因此建议生产者确认全部采用异步方式。<br>:::</p><h2 id="LazyQueue"><a href="#LazyQueue" class="headerlink" title="LazyQueue"></a>LazyQueue</h2><p>在默认情况下，RabbitMQ会将接收到的信息保存在内存中以降低消息收发的延迟。但在某些特殊情况下，这会导致消息积压，比如：</p><ul><li>消费者宕机或出现网络故障</li><li>消息发送量激增，超过了消费者处理速度</li><li>消费者处理业务发生阻塞</li></ul><p>一旦出现消息堆积问题，RabbitMQ的内存占用就会越来越高，直到触发内存预警上限。此时RabbitMQ会将内存消息刷到磁盘上，这个行为成为<code>PageOut</code>. <code>PageOut</code>会耗费一段时间，并且会阻塞队列进程。因此在这个过程中RabbitMQ不会再处理新的消息，生产者的所有请求都会被阻塞。<br>为了解决这个问题，从RabbitMQ的3.6.0版本开始，就增加了Lazy Queues的模式，也就是惰性队列。惰性队列的特征如下：</p><ul><li>接收到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存（也就是懒加载）</li><li>支持数百万条的消息存储</li></ul><p>而在3.12版本之后，LazyQueue已经成为所有队列的默认格式。因此官方推荐升级MQ为3.12版本或者所有队列都设置为LazyQueue模式。</p><h3 id="控制台配置Lazy模式"><a href="#控制台配置Lazy模式" class="headerlink" title="控制台配置Lazy模式"></a>控制台配置Lazy模式</h3><p>在添加队列的时候，添加<code>x-queue-mod=lazy</code>参数即可设置队列为Lazy模式：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687421366634-1dfca4a6-2407-43c2-8e65-fd7ba9e660dc.png#averageHue=%23f8f6f5&clientId=ud69cf815-2833-4&from=paste&height=361&id=auTfj&originHeight=447&originWidth=1127&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=34943&status=done&style=none&taskId=ue22630f9-97c2-47c9-989b-e1963580eb6&title=&width=909.1764414434211#averageHue=%23f8f6f5&id=fmJIU&originHeight=447&originWidth=1127&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"></p><h3 id="代码配置Lazy模式"><a href="#代码配置Lazy模式" class="headerlink" title="代码配置Lazy模式"></a>代码配置Lazy模式</h3><p>在利用SpringAMQP声明队列的时候，添加<code>x-queue-mod=lazy</code>参数也可设置队列为Lazy模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">            .durable(<span class="string">&quot;lazy.queue&quot;</span>)</span><br><span class="line">            .lazy() <span class="comment">// 开启Lazy模式</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是通过<code>QueueBuilder</code>的<code>lazy()</code>函数配置Lazy模式，底层源码如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687421880071-2a21369f-00b3-481d-a9bb-ce69a346ccc3.png#averageHue=%23f4f6ed&clientId=ud69cf815-2833-4&from=paste&height=192&id=dCe61&originHeight=238&originWidth=908&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=32577&status=done&style=none&taskId=u17fb9e40-01c9-4605-bc5a-eb906237b36&title=&width=732.5041781993135#averageHue=%23f4f6ed&id=DAX8n&originHeight=238&originWidth=908&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>当然，我们也可以基于注解来声明队列并设置为Lazy模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(</span></span><br><span class="line"><span class="meta">        name = &quot;lazy.queue&quot;,</span></span><br><span class="line"><span class="meta">        durable = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">        arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenLazyQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到 lazy.queue的消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新已有队列为lazy模式"><a href="#更新已有队列为lazy模式" class="headerlink" title="更新已有队列为lazy模式"></a>更新已有队列为lazy模式</h3><p>对于已经存在的队列，也可以配置为lazy模式，但是要通过设置policy实现。<br>可以基于命令行设置policy：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy Lazy &quot;^lazy-queue$&quot; &#x27;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#x27; --apply-to queues  </span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li><code>rabbitmqctl</code> ：RabbitMQ的命令行工具</li><li><code>set_policy</code> ：添加一个策略</li><li><code>Lazy</code> ：策略名称，可以自定义</li><li><code>&quot;^lazy-queue$&quot;</code> ：用正则表达式匹配队列的名字</li><li><code>&#39;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#39;</code> ：设置队列模式为lazy模式</li><li><code>--apply-to queues</code>：策略的作用对象，是所有的队列</li></ul><p>当然，也可以在控制台配置policy，进入在控制台的<code>Admin</code>页面，点击<code>Policies</code>，即可添加配置：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687422619364-b0e414b9-55fc-49f2-b7b5-de52b72a9f56.png#averageHue=%23f7f6f5&clientId=ud69cf815-2833-4&from=paste&height=682&id=pcraA&originHeight=846&originWidth=1365&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=83823&status=done&style=none&taskId=u10b50f65-9311-4fb6-9f0b-ac0bbe2c3c9&title=&width=1101.1764352886157#averageHue=%23f7f6f5&id=muyuT&originHeight=846&originWidth=1365&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"></p><h1 id="消费者的可靠性"><a href="#消费者的可靠性" class="headerlink" title="消费者的可靠性"></a>消费者的可靠性</h1><p>当RabbitMQ向消费者投递消息以后，需要知道消费者的处理状态如何。因为消息投递给消费者并不代表就一定被正确消费了，可能出现的故障有很多，比如：</p><ul><li>消息投递的过程中出现了网络故障</li><li>消费者接收到消息后突然宕机</li><li>消费者接收到消息后，因处理不当导致异常</li><li>…</li></ul><p>一旦发生上述情况，消息也会丢失。因此，RabbitMQ必须知道消费者的处理状态，一旦消息处理失败才能重新投递消息。<br>但问题来了：RabbitMQ如何得知消费者的处理状态呢？<br>本章我们就一起研究一下消费者处理消息时的可靠性解决方案。</p><h2 id="消费者确认机制"><a href="#消费者确认机制" class="headerlink" title="消费者确认机制"></a>消费者确认机制</h2><p>为了确认消费者是否成功处理消息，RabbitMQ提供了消费者确认机制（<strong>Consumer Acknowledgement</strong>）。即：当消费者处理消息结束后，应该向RabbitMQ发送一个回执，告知RabbitMQ自己消息处理状态。回执有三种可选值：</p><ul><li>ack：成功处理消息，RabbitMQ从队列中删除该消息</li><li>nack：消息处理失败，RabbitMQ需要再次投递消息</li><li>reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息</li></ul><p>一般reject方式用的较少，除非是消息格式有问题，那就是开发问题了。因此大多数情况下我们需要将消息处理的代码通过<code>try catch</code>机制捕获，消息处理成功时返回ack，处理失败时返回nack.<br>由于消息回执的处理代码比较统一，因此SpringAMQP帮我们实现了消息确认。并允许我们通过配置文件设置ACK处理方式，有三种模式：</p><ul><li><code>**none**</code>：不处理。即消息投递给消费者后立刻ack，消息会立刻从MQ删除。非常不安全，不建议使用</li><li><code>**manual**</code>：手动模式。需要自己在业务代码中调用api，发送<code>ack</code>或<code>reject</code>，存在业务入侵，但更灵活</li><li><code>**auto**</code>：自动模式。SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回<code>ack</code>.  当业务出现异常时，根据异常判断返回不同结果：<ul><li>如果是<strong>业务异常</strong>，会自动返回<code>nack</code>；</li><li>如果是<strong>消息处理或校验异常</strong>，自动返回<code>reject</code>;</li></ul></li></ul><p>返回Reject的常见异常有：</p><blockquote><p>Starting with version 1.3.2, the default ErrorHandler is now a ConditionalRejectingErrorHandler that rejects (and does not requeue) messages that fail with an irrecoverable error. Specifically, it rejects messages that fail with the following errors:</p><ul><li>o.s.amqp…MessageConversionException: Can be thrown when converting the incoming message payload using a MessageConverter.</li><li>o.s.messaging…MessageConversionException: Can be thrown by the conversion service if additional conversion is required when mapping to a @RabbitListener method.</li><li>o.s.messaging…MethodArgumentNotValidException: Can be thrown if validation (for example, @Valid) is used in the listener and the validation fails.</li><li>o.s.messaging…MethodArgumentTypeMismatchException: Can be thrown if the inbound message was converted to a type that is not correct for the target method. For example, the parameter is declared as Message but Message is received.</li><li>java.lang.NoSuchMethodException: Added in version 1.6.3.</li><li>java.lang.ClassCastException: Added in version 1.6.3.</li></ul></blockquote><p>通过下面的配置可以修改SpringAMQP的ACK处理方式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">none</span> <span class="comment"># 不做处理</span></span><br></pre></td></tr></table></figure><p>修改consumer服务的SpringRabbitListener类中的方法，模拟一个消息处理的异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MessageConversionException</span>(<span class="string">&quot;故意的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;消息处理完成&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试可以发现：当消息处理发生异常时，消息依然被RabbitMQ删除了。</p><p>我们再次把确认机制修改为auto：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span> <span class="comment"># 自动ack</span></span><br></pre></td></tr></table></figure><p>在异常位置打断点，再次发送消息，程序卡在断点时，可以发现此时消息状态为<code>unacked</code>（未确定状态）：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687489262801-36725872-cc98-470a-ab6b-85cfd9c1b0ce.png#averageHue=%23f5f3f3&clientId=uaa251f98-ecdc-4&from=paste&height=194&id=u0edc5b71&originHeight=241&originWidth=1100&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=24869&status=done&style=none&taskId=ufc5a8f88-61f6-4518-ad83-77d7037cd6b&title=&width=887.3949295366134#averageHue=%23f5f3f3&id=A1yTy&originHeight=241&originWidth=1100&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>放行以后，由于抛出的是<strong>消息转换异常</strong>，因此Spring会自动返回<code>reject</code>，所以消息依然会被删除：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687490335196-66d14c99-45c2-4113-8a36-94e33c3ce7d5.png#averageHue=%23f3f3f2&clientId=uaa251f98-ecdc-4&from=paste&height=231&id=u0977f925&originHeight=286&originWidth=1099&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=28753&status=done&style=none&taskId=u60974200-bef2-4eca-a9e8-1b91ce70eb9&title=&width=886.5882068733982#averageHue=%23f3f3f2&id=tKNFc&originHeight=286&originWidth=1099&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>我们将异常改为RuntimeException类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;故意的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;消息处理完成&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在异常位置打断点，然后再次发送消息测试，程序卡在断点时，可以发现此时消息状态为<code>unacked</code>（未确定状态）：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687489262801-36725872-cc98-470a-ab6b-85cfd9c1b0ce.png#averageHue=%23f5f3f3&clientId=uaa251f98-ecdc-4&from=paste&height=194&id=WusVn&originHeight=241&originWidth=1100&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=24869&status=done&style=none&taskId=ufc5a8f88-61f6-4518-ad83-77d7037cd6b&title=&width=887.3949295366134#averageHue=%23f5f3f3&id=CfETp&originHeight=241&originWidth=1100&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none">放行以后，由于抛出的是业务异常，所以Spring返回<code>ack</code>，最终消息恢复至<code>Ready</code>状态，并且没有被RabbitMQ删除：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687490819965-f638194b-f956-4ad3-8cd4-2e03f5e43674.png#averageHue=%23f4f3f2&clientId=uaa251f98-ecdc-4&from=paste&height=237&id=u0f1b8e0c&originHeight=294&originWidth=1110&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=29088&status=done&style=none&taskId=ue0e6353b-c435-43f2-9520-32a58e71098&title=&width=895.4621561687644#averageHue=%23f4f3f2&id=yvytp&originHeight=294&originWidth=1110&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>当我们把配置改为<code>auto</code>时，消息处理失败后，会回到RabbitMQ，并重新投递到消费者。</p><h2 id="失败重试机制"><a href="#失败重试机制" class="headerlink" title="失败重试机制"></a>失败重试机制</h2><p>当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者。如果消费者再次执行依然出错，消息会再次requeue到队列，再次投递，直到消息处理成功为止。<br>极端情况就是消费者一直无法执行成功，那么消息requeue就会无限循环，导致mq的消息处理飙升，带来不必要的压力：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687490923673-6eca30c4-4cd0-4a92-b6d4-2766c0ad1746.png#averageHue=%23f2f1f1&clientId=uaa251f98-ecdc-4&from=paste&height=131&id=ue26e64ed&originHeight=162&originWidth=988&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=56569&status=done&style=none&taskId=u63e3277a-cb8f-4fd8-bdff-fc1dcc685e9&title=&width=797.0419912565218#averageHue=%23f2f1f1&id=oC9Eu&originHeight=162&originWidth=988&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>当然，上述极端情况发生的概率还是非常低的，不过不怕一万就怕万一。为了应对上述情况Spring又提供了消费者失败重试机制：在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列。<br>修改consumer服务的application.yml文件，添加内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure><p>重启consumer服务，重复之前的测试。可以发现：</p><ul><li>消费者在失败后消息没有重新回到MQ无限重新投递，而是在本地重试了3次</li><li>本地重试3次以后，抛出了<code>AmqpRejectAndDontRequeueException</code>异常。查看RabbitMQ控制台，发现消息被删除了，说明最后SpringAMQP返回的是<code>reject</code></li></ul><p>结论：</p><ul><li>开启本地重试时，消息处理过程中抛出异常，不会requeue到队列，而是在消费者本地重试</li><li>重试达到最大次数后，Spring会返回reject，消息会被丢弃</li></ul><h2 id="失败处理策略"><a href="#失败处理策略" class="headerlink" title="失败处理策略"></a>失败处理策略</h2><p>在之前的测试中，本地测试达到最大重试次数后，消息会被丢弃。这在某些对于消息可靠性要求较高的业务场景下，显然不太合适了。<br>因此Spring允许我们自定义重试次数耗尽后的消息处理策略，这个策略是由<code>MessageRecovery</code>接口来定义的，它有3个不同实现：</p><ul><li><code>RejectAndDontRequeueRecoverer</code>：重试耗尽后，直接<code>reject</code>，丢弃消息。默认就是这种方式 </li><li><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，返回<code>nack</code>，消息重新入队 </li><li><code>RepublishMessageRecoverer</code>：重试耗尽后，将失败消息投递到指定的交换机</li></ul><p>比较优雅的一种处理方案是<code>RepublishMessageRecoverer</code>，失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理。</p><p>1）在consumer服务中定义处理失败消息的交换机和队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）定义一个RepublishMessageRecoverer，关联队列和交换机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.retry.MessageRecoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.retry.RepublishMessageRecoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;spring.rabbitmq.listener.simple.retry.enabled&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorMessageConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="业务幂等性"><a href="#业务幂等性" class="headerlink" title="业务幂等性"></a>业务幂等性</h2><p>何为幂等性？<br><strong>幂等</strong>是一个数学概念，用函数表达式来描述是这样的：<code>f(x) = f(f(x))</code>，例如求绝对值函数。<br>在程序开发中，则是指同一个业务，执行一次或多次对业务状态的影响是一致的。例如：</p><ul><li>根据id删除数据</li><li>查询数据</li><li>新增数据</li></ul><p>但数据的更新往往不是幂等的，如果重复执行可能造成不一样的后果。比如：</p><ul><li>取消订单，恢复库存的业务。如果多次恢复就会出现库存重复增加的情况</li><li>退款业务。重复退款对商家而言会有经济损失。</li></ul><p>所以，我们要尽可能避免业务被重复执行。<br>然而在实际业务场景中，由于意外经常会出现业务被重复执行的情况，例如：</p><ul><li>页面卡顿时频繁刷新导致表单重复提交</li><li>服务间调用的重试</li><li>MQ消息的重复投递</li></ul><p>我们在用户支付成功后会发送MQ消息到交易服务，修改订单状态为已支付，就可能出现消息重复投递的情况。如果消费者不做判断，很有可能导致消息被消费多次，出现业务故障。<br>举例：</p><ol><li>假如用户刚刚支付完成，并且投递消息到交易服务，交易服务更改订单为<strong>已支付</strong>状态。</li><li>由于某种原因，例如网络故障导致生产者没有得到确认，隔了一段时间后<strong>重新投递</strong>给交易服务。</li><li>但是，在新投递的消息被消费之前，用户选择了退款，将订单状态改为了<strong>已退款</strong>状态。</li><li>退款完成后，新投递的消息才被消费，那么订单状态会被再次改为<strong>已支付</strong>。业务异常。</li></ol><p>因此，我们必须想办法保证消息处理的幂等性。这里给出两种方案：</p><ul><li>唯一消息ID</li><li>业务状态判断</li></ul><h3 id="唯一消息ID"><a href="#唯一消息ID" class="headerlink" title="唯一消息ID"></a>唯一消息ID</h3><p>这个思路非常简单：</p><ol><li>每一条消息都生成一个唯一的id，与消息一起投递给消费者。</li><li>消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库</li><li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。</li></ol><p>我们该如何给消息添加唯一ID呢？<br>其实很简单，SpringAMQP的MessageConverter自带了MessageID的功能，我们只要开启这个功能即可。<br>以Jackson的消息转换器为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jjmc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jjmc.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jjmc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="业务判断"><a href="#业务判断" class="headerlink" title="业务判断"></a>业务判断</h3><p>业务判断就是基于业务本身的逻辑或状态来判断是否是重复的请求或消息，不同的业务场景判断的思路也不一样。<br>例如我们当前案例中，处理消息的业务逻辑是把订单状态从未支付修改为已支付。因此我们就可以在执行业务时判断订单状态是否是未支付，如果不是则证明订单已经被处理过，无需重复处理。<br>相比较而言，消息ID的方案需要改造原有的数据库，所以我更推荐使用业务判断的方案。<br>以支付修改订单的业务为例，我们需要修改<code>OrderServiceImpl</code>中的<code>markOrderPaySuccess</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markOrderPaySuccess</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">old</span> <span class="operator">=</span> getById(orderId);</span><br><span class="line">    <span class="comment">// 2.判断订单状态</span></span><br><span class="line">    <span class="keyword">if</span> (old == <span class="literal">null</span> || old.getStatus() != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 订单不存在或者订单状态不是1，放弃处理</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.尝试更新订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    order.setId(orderId);</span><br><span class="line">    order.setStatus(<span class="number">2</span>);</span><br><span class="line">    order.setPayTime(LocalDateTime.now());</span><br><span class="line">    updateById(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码逻辑上符合了幂等判断的需求，但是由于判断和更新是两步动作，因此在极小概率下可能存在线程安全问题。<br>我们可以合并上述操作为这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markOrderPaySuccess</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// UPDATE `order` SET status = ? , pay_time = ? WHERE id = ? AND status = 1</span></span><br><span class="line">    lambdaUpdate()</span><br><span class="line">            .set(Order::getStatus, <span class="number">2</span>)</span><br><span class="line">            .set(Order::getPayTime, LocalDateTime.now())</span><br><span class="line">            .eq(Order::getId, orderId)</span><br><span class="line">            .eq(Order::getStatus, <span class="number">1</span>)</span><br><span class="line">            .update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看，上述代码等同于这样的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `<span class="keyword">order</span>` <span class="keyword">SET</span> status <span class="operator">=</span> ? , pay_time <span class="operator">=</span> ? <span class="keyword">WHERE</span> id <span class="operator">=</span> ? <span class="keyword">AND</span> status <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>我们在where条件中除了判断id以外，还加上了status必须为1的条件。如果条件不符（说明订单已支付），则SQL匹配不到数据，根本不会执行。</p><h2 id="兜底方案"><a href="#兜底方案" class="headerlink" title="兜底方案"></a>兜底方案</h2><p>虽然我们利用各种机制尽可能增加了消息的可靠性，但也不好说能保证消息100%的可靠。万一真的MQ通知失败该怎么办呢？<br>有没有其它兜底方案，能够确保订单的支付状态一致呢？<br>其实思想很简单：既然MQ通知不一定发送到交易服务，那么交易服务就必须自己<strong>主动去查询</strong>支付状态。这样即便支付服务的MQ通知失败，我们依然能通过主动查询来保证订单状态的一致。<br>流程如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1687521150465-25b54b36-b64a-4b2d-90b7-8dff12fb075b.jpeg#averageHue=%23f9f9f9&id=WG8vq&originHeight=1184&originWidth=1955&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>图中黄色线圈起来的部分就是MQ通知失败后的兜底处理方案，由交易服务自己主动去查询支付状态。<br>不过需要注意的是，交易服务并不知道用户会在什么时候支付，如果查询的时机不正确（比如查询的时候用户正在支付中），可能查询到的支付状态也不正确。<br>那么问题来了，我们到底该在什么时间主动查询支付状态呢？<br>这个时间是无法确定的，因此，通常我们采取的措施就是利用<strong>定时任务</strong>定期查询，例如每隔20秒就查询一次，并判断支付状态。如果发现订单已经支付，则立刻更新订单状态为已支付即可。<br>定时任务大家之前学习过，具体的实现这里就不再赘述了。<br>至此，消息可靠性的问题已经解决了。<br>综上，支付服务与交易服务之间的订单状态一致性是如何保证的？</p><ul><li>首先，支付服务会正在用户支付成功以后利用MQ消息通知交易服务，完成订单状态同步。</li><li>其次，为了保证MQ消息的可靠性，我们采用了生产者确认机制、消费者确认、消费者失败重试等策略，确保消息投递的可靠性</li><li>最后，我们还在交易服务设置了定时任务，定期查询订单支付状态。这样即便MQ通知失败，还可以利用定时任务作为兜底方案，确保订单支付状态的最终一致性。</li></ul><h1 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h1><p>在电商的支付业务中，对于一些库存有限的商品，为了更好的用户体验，通常都会在用户下单时立刻扣减商品库存。例如电影院购票、高铁购票，下单后就会锁定座位资源，其他人无法重复购买。<br>但是这样就存在一个问题，假如用户下单后一直不付款，就会一直占有库存资源，导致其他客户无法正常交易，最终导致商户利益受损！<br>因此，电商中通常的做法就是：<strong>对于超过一定时间未支付的订单，应该立刻取消订单并释放占用的库存</strong>。<br>例如，订单支付超时时间为30分钟，则我们应该在用户下单后的第30分钟检查订单支付状态，如果发现未支付，应该立刻取消订单，释放库存。<br>但问题来了：如何才能准确的实现在下单后第30分钟去检查支付状态呢？<br>像这种在一段时间以后才执行的任务，我们称之为<strong>延迟任务</strong>，而要实现延迟任务，最简单的方案就是利用MQ的延迟消息了。<br>在RabbitMQ中实现延迟消息也有两种方案：</p><ul><li>死信交换机+TTL</li><li>延迟消息插件</li></ul><p>这一章我们就一起研究下这两种方案的实现方式，以及优缺点。</p><h2 id="死信交换机和延迟消息"><a href="#死信交换机和延迟消息" class="headerlink" title="死信交换机和延迟消息"></a>死信交换机和延迟消息</h2><p>首先我们来学习一下基于死信交换机的延迟消息方案。</p><h3 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h3><p>什么是死信？<br>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用<code>basic.reject</code>或 <code>basic.nack</code>声明消费失败，并且消息的<code>requeue</code>参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul><p>如果一个队列中的消息已经成为死信，并且这个队列通过<code>**dead-letter-exchange**</code>属性指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机就称为<strong>死信交换机</strong>（Dead Letter Exchange）。而此时加入有队列与死信交换机绑定，则最终死信就会被投递到这个队列中。<br>死信交换机有什么作用呢？</p><ol><li>收集那些因处理失败而被拒绝的消息</li><li>收集那些因队列满了而被拒绝的消息</li><li>收集因TTL（有效期）到期的消息</li></ol><h3 id="延迟消息-1"><a href="#延迟消息-1" class="headerlink" title="延迟消息"></a>延迟消息</h3><p>前面两种作用场景可以看做是把死信交换机当做一种消息处理的最终兜底方案，与消费者重试时讲的<code>RepublishMessageRecoverer</code>作用类似。<br>而最后一种场景，大家设想一下这样的场景：<br>如图，有一组绑定的交换机（<code>ttl.fanout</code>）和队列（<code>ttl.queue</code>）。但是<code>ttl.queue</code>没有消费者监听，而是设定了死信交换机<code>hmall.direct</code>，而队列<code>direct.queue1</code>则与死信交换机绑定，RoutingKey是blue：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687573175803-41a1c870-93bc-4307-974f-891de1b5a42d.png#averageHue=%23faf3f2&clientId=u76b62a19-f8dc-4&from=paste&height=340&id=u380f1403&originHeight=422&originWidth=1301&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=59423&status=done&style=none&taskId=ucbcde27e-d210-43e8-8e35-7557d121729&title=&width=1049.546184842849#averageHue=%23faf3f2&id=JuEy5&originHeight=422&originWidth=1301&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>假如我们现在发送一条消息到<code>ttl.fanout</code>，RoutingKey为blue，并设置消息的<strong>有效期</strong>为5000毫秒：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687573506181-f0af9da1-0b0b-4cfb-afca-f5febb306cdf.png#averageHue=%23faf4f4&clientId=u76b62a19-f8dc-4&from=paste&height=349&id=u9604efe2&originHeight=432&originWidth=1421&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=60694&status=done&style=none&taskId=u7e667f84-8779-47db-af73-7598ea5759e&title=&width=1146.3529044286615#averageHue=%23faf4f4&id=F2cPK&originHeight=432&originWidth=1421&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>:::warning<br><strong>注意</strong>：尽管这里的<code>ttl.fanout</code>不需要RoutingKey，但是当消息变为死信并投递到死信交换机时，会沿用之前的RoutingKey，这样<code>hmall.direct</code>才能正确路由消息。<br>:::<br>消息肯定会被投递到<code>ttl.queue</code>之后，由于没有消费者，因此消息无人消费。5秒之后，消息的有效期到期，成为死信：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687573747592-4d95dbb1-3f4d-4174-af24-124cb1346a81.png#averageHue=%23faf4f4&clientId=u76b62a19-f8dc-4&from=paste&height=341&id=u616ad2d4&originHeight=423&originWidth=1502&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=71956&status=done&style=none&taskId=uf4c990b8-e00b-42c0-842d-efdd5485d43&title=&width=1211.6974401490847#averageHue=%23faf4f4&id=D4M4e&originHeight=423&originWidth=1502&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>死信被再次投递到死信交换机<code>hmall.direct</code>，并沿用之前的RoutingKey，也就是<code>blue</code>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687573874094-ebf781c1-6273-474b-b0ed-17243d8370ae.png#averageHue=%23faf4f4&clientId=u76b62a19-f8dc-4&from=paste&height=348&id=u53622578&originHeight=431&originWidth=1421&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=63699&status=done&style=none&taskId=u610a5adf-e615-4fa5-9c50-597a1be139a&title=&width=1146.3529044286615#averageHue=%23faf4f4&id=Tdb5O&originHeight=431&originWidth=1421&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>由于<code>direct.queue1</code>与<code>hmall.direct</code>绑定的key是blue，因此最终消息被成功路由到<code>direct.queue1</code>，如果此时有消费者与<code>direct.queue1</code>绑定， 也就能成功消费消息了。但此时已经是5秒钟以后了：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687574086294-106fe14b-6652-4783-a6c3-3d722d1f5232.png#averageHue=%23fbf5f5&clientId=u76b62a19-f8dc-4&from=paste&height=373&id=ub429262c&originHeight=462&originWidth=1633&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=81718&status=done&style=none&taskId=u244f2a30-7d51-48a2-969b-b880a7f2442&title=&width=1317.3781090302632#averageHue=%23fbf5f5&id=Xt23W&originHeight=462&originWidth=1633&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>也就是说，publisher发送了一条消息，但最终consumer在5秒后才收到消息。我们成功实现了<strong>延迟消息</strong>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>:::warning<br><strong>注意：</strong><br>RabbitMQ的消息过期是基于追溯方式来实现的，也就是说当一个消息的TTL到期以后不一定会被移除或投递到死信交换机，而是在消息恰好处于队首时才会被处理。<br>当队列中消息堆积很多的时候，过期消息可能不会被按时处理，因此你设置的TTL时间不一定准确。<br>:::</p><h2 id="DelayExchange插件"><a href="#DelayExchange插件" class="headerlink" title="DelayExchange插件"></a>DelayExchange插件</h2><p>基于死信队列虽然可以实现延迟消息，但是太麻烦了。因此RabbitMQ社区提供了一个延迟消息插件来实现相同的效果。<br>官方文档说明：<br><a href="https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq">Scheduling Messages with RabbitMQ | RabbitMQ - Blog</a></p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>插件下载地址：<br><a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">GitHub - rabbitmq&#x2F;rabbitmq-delayed-message-exchange: Delayed Messaging for RabbitMQ</a><br>由于我们安装的MQ是<code>3.8</code>版本，因此这里下载<code>3.8.17</code>版本：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687576610561-71355772-460c-4b7a-bf71-904b40bccdf9.png#averageHue=%23fdfdfd&clientId=u76b62a19-f8dc-4&from=paste&height=722&id=u54276885&originHeight=895&originWidth=1183&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=88481&status=done&style=none&taskId=u3b769aca-ef34-4a2c-be13-6729ea0e832&title=&width=954.352910583467#averageHue=%23fdfdfd&id=tPJFK&originHeight=895&originWidth=1183&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>当然，也可以直接使用课前资料提供好的插件：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687611117405-f30b7216-cbef-44fc-a8a9-b62c50ef2a06.png#averageHue=%23f8f8f7&clientId=ua8cb106d-b05e-4&from=paste&height=131&id=u601c044f&originHeight=163&originWidth=855&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=15305&status=done&style=none&taskId=uaae26ad5-bd00-4347-bc5c-5a16a006ef3&title=&width=689.7478770489131#averageHue=%23f8f8f7&id=A11or&originHeight=163&originWidth=855&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>因为我们是基于Docker安装，所以需要先查看RabbitMQ的插件目录对应的数据卷。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect mq-plugins</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2024-06-19T09:22:59+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: null,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/mq-plugins/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;mq-plugins&quot;,</span><br><span class="line">        &quot;Options&quot;: null,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>插件目录被挂载到了<code>/var/lib/docker/volumes/mq-plugins/_data</code>这个目录，我们上传插件到该目录下。<br>接下来执行命令，安装插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mq rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687576988700-43b5d4ad-a77c-4463-bea4-4f3c0888ebe5.png#averageHue=%23031f33&clientId=u76b62a19-f8dc-4&from=paste&height=428&id=u46bbc0d8&originHeight=530&originWidth=1456&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=64423&status=done&style=none&taskId=uecc0751f-db71-4d55-86a5-c859569b939&title=&width=1174.58819764119#averageHue=%23031f33&id=Qmnze&originHeight=530&originWidth=1456&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"></p><h3 id="声明延迟交换机"><a href="#声明延迟交换机" class="headerlink" title="声明延迟交换机"></a>声明延迟交换机</h3><p>基于注解方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        key = &quot;delay&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayMessage</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到delay.queue的延迟消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于<code>@Bean</code>的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayExchangeConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">delayExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder</span><br><span class="line">                .directExchange(<span class="string">&quot;delay.direct&quot;</span>) <span class="comment">// 指定交换机类型和名称</span></span><br><span class="line">                .delayed() <span class="comment">// 设置delay的属性为true</span></span><br><span class="line">                .durable(<span class="literal">true</span>) <span class="comment">// 持久化</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;delay.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">delayQueueBinding</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue()).to(delayExchange()).with(<span class="string">&quot;delay&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="发送延迟消息"><a href="#发送延迟消息" class="headerlink" title="发送延迟消息"></a>发送延迟消息</h3><p>发送消息时，必须通过x-delay属性设定延迟时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherDelayMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, delayed message&quot;</span>;</span><br><span class="line">    <span class="comment">// 2.发送消息，利用消息后置处理器添加消息头</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;delay.direct&quot;</span>, <span class="string">&quot;delay&quot;</span>, message, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">            <span class="comment">// 添加延迟消息属性</span></span><br><span class="line">            message.getMessageProperties().setDelay(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:::warning<br><strong>注意：</strong><br>延迟消息插件内部会维护一个本地数据库表，同时使用Elang Timers功能实现计时。如果消息的延迟时间设置较长，可能会导致堆积的延迟消息非常多，会带来较大的CPU开销，同时延迟消息的时间会存在误差。<br>因此，<strong>不建议设置延迟时间过长的延迟消息</strong>。<br>:::</p><h2 id="订单状态同步问题"><a href="#订单状态同步问题" class="headerlink" title="订单状态同步问题"></a>订单状态同步问题</h2><p>接下来，我们就在交易服务中利用延迟消息实现订单支付状态的同步。其大概思路如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1690343275577-b0f99b4a-40e2-40cf-8da2-11f0dfbd7d7c.jpeg#averageHue=%23fafafa&id=DlQuL&originHeight=988&originWidth=1766&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>假如订单超时支付时间为30分钟，理论上说我们应该在下单时发送一条延迟消息，延迟时间为30分钟。这样就可以在接收到消息时检验订单支付状态，关闭未支付订单。<br>但是大多数情况下用户支付都会在1分钟内完成，我们发送的消息却要在MQ中停留30分钟，额外消耗了MQ的资源。因此，我们最好多检测几次订单支付状态，而不是在最后第30分钟才检测。<br>例如：我们在用户下单后的第10秒、20秒、30秒、45秒、60秒、1分30秒、2分、…30分分别设置延迟消息，如果提前发现订单已经支付，则后续的检测取消即可。<br>这样就可以有效避免对MQ资源的浪费了。<br>优化后的实现思路如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1687593452790-58e296b7-0761-40f6-b4be-9c19bff9cd3e.jpeg#averageHue=%23fafafa&id=iCsRu&originHeight=988&originWidth=2176&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>由于我们要多次发送延迟消息，因此需要先定义一个记录消息延迟时间的消息体，处于通用性考虑，我们将其定义到<code>hm-common</code>模块下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687593306116-2a41b7c0-064c-463f-b109-fa05db8609e8.png#averageHue=%23f9fbf8&clientId=u76b62a19-f8dc-4&from=paste&height=402&id=ueaa6d986&originHeight=498&originWidth=944&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=48824&status=done&style=none&taskId=u025bcf5a-23cc-4146-8ecc-1f6a7126c60&title=&width=761.5461940750573#averageHue=%23f9fbf8&id=PLzR6&originHeight=498&originWidth=944&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.common.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.common.utils.CollUtils;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiDelayMessage</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录延迟时间的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Long&gt; delayMillis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MultiDelayMessage</span><span class="params">(T data, List&lt;Long&gt; delayMillis)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.delayMillis = delayMillis;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; MultiDelayMessage&lt;T&gt; <span class="title function_">of</span><span class="params">(T data, Long ... delayMillis)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MultiDelayMessage</span>&lt;&gt;(data, CollUtils.newArrayList(delayMillis));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取并移除下一个延迟时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 队列中的第一个延迟时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">removeNextDelay</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delayMillis.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否还有下一个延迟时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNextDelay</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !delayMillis.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h3><p>无论是消息发送还是接收都是在交易服务完成，因此我们在<code>trade-service</code>中定义一个常量类，用于记录交换机、队列、RoutingKey等常量：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687593919687-52eb9aa6-6f80-4b49-ba32-bb608018e333.png#averageHue=%23f9fbf8&clientId=u76b62a19-f8dc-4&from=paste&height=328&id=ufb3e5a13&originHeight=406&originWidth=913&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=38538&status=done&style=none&taskId=u54275307-b948-433e-b531-bdf3fc84fac&title=&width=736.5377915153891#averageHue=%23f9fbf8&id=oKKBS&originHeight=406&originWidth=913&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.trade.constants;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MqConstants</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">DELAY_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;trade.delay.topic&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">DELAY_ORDER_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;trade.order.delay.queue&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">DELAY_ORDER_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;order.query&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽取共享mq配置"><a href="#抽取共享mq配置" class="headerlink" title="抽取共享mq配置"></a>抽取共享mq配置</h3><p>我们将mq的配置抽取到nacos中，方便各个微服务共享配置。<br>在nacos中定义一个名为<code>shared-mq.xml</code>的配置文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">$&#123;hm.mq.host:192.168.150.101&#125;</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">$&#123;hm.mq.port:5672&#125;</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">$&#123;hm.mq.vhost:/hmall&#125;</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">$&#123;hm.mq.un:hmall&#125;</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;hm.mq.pw:123&#125;</span> <span class="comment"># 密码</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><p>这里只添加一些基础配置，至于生产者确认，消费者确认配置则由微服务根据业务自己决定。<br>在<code>trade-service</code>模块添加共享配置：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687595291593-378450c1-ef00-4cbf-9be8-235d1eea8e7c.png#averageHue=%23f6f9f5&clientId=u76b62a19-f8dc-4&from=paste&height=515&id=uc4ebf7e5&originHeight=638&originWidth=952&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=129257&status=done&style=none&taskId=uc6221e28-aa92-49da-bc73-1ff8258fda5&title=&width=767.9999753807781#averageHue=%23f6f9f5&id=aaHMr&originHeight=638&originWidth=952&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"></p><h3 id="改造下单业务"><a href="#改造下单业务" class="headerlink" title="改造下单业务"></a>改造下单业务</h3><p>接下来，我们改造下单业务，在下单完成后，发送延迟消息，查询支付状态。<br>1）引入依赖<br>在<code>trade-service</code>模块的<code>pom.xml</code>中引入amqp的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--amqp--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2）改造下单业务<br>修改<code>trade-service</code>模块的<code>com.hmall.trade.service.impl.OrderServiceImpl</code>类的<code>createOrder</code>方法，添加消息发送的代码：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687595921876-005c46d9-4278-411b-bfc1-c5e545949cd5.png#averageHue=%23f6f8f4&clientId=u76b62a19-f8dc-4&from=paste&height=496&id=u29260a5b&originHeight=615&originWidth=1668&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=182037&status=done&style=none&taskId=udb3ccb23-163c-406d-9d8c-bc7087da8f1&title=&width=1345.6134022427918#averageHue=%23f6f8f4&id=Ibqzs&originHeight=615&originWidth=1668&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"></p><h3 id="编写查询支付状态接口"><a href="#编写查询支付状态接口" class="headerlink" title="编写查询支付状态接口"></a>编写查询支付状态接口</h3><p>由于MQ消息处理时需要查询支付状态，因此我们要在pay-service模块定义一个这样的接口，并提供对应的FeignClient.<br>首先，在hm-api模块定义三个类：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1690352506454-23b445b7-3a34-458e-bba2-47528a06ea65.png#averageHue=%23f9fbf7&clientId=u835b609d-4d58-4&from=paste&height=562&id=ud6c48d2c&originHeight=627&originWidth=875&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=63061&status=done&style=none&taskId=u8487842b-c38a-48a4-9a27-3ed9692d7d8&title=&width=784.3137087287431#averageHue=%23f9fbf7&id=Jeau3&originHeight=627&originWidth=875&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>说明：</p><ul><li>PayOrderDTO：支付单的数据传输实体</li><li>PayClient：支付系统的Feign客户端</li><li>PayClientFallback：支付系统的fallback逻辑</li></ul><p>PayOrderDTO代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.api.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 支付订单</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;支付单数据传输实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayOrderDTO</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;业务订单号&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long bizOrderNo;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付单号&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long payOrderNo;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付用户id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long bizUserId;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付渠道编码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String payChannelCode;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付金额，单位分&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer amount;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;付类型，1：h5,2:小程序，3：公众号，4：扫码，5：余额支付&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer payType;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;付状态，0：待提交，1:待支付，2：支付超时或取消，3：支付成功&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;拓展字段，用于传递不同渠道单独处理的字段&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String expandJson;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;第三方返回业务码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String resultCode;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;第三方返回提示信息&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String resultMsg;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付成功时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime paySuccessTime;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付超时时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime payOverTime;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付二维码链接&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String qrCodeUrl;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;创建时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;更新时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>PayClient代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.api.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.api.client.fallback.PayClientFallback;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.dto.PayOrderDTO;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;pay-service&quot;, fallbackFactory = PayClientFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PayClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据交易订单id查询支付单</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 业务订单id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 支付单信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/pay-orders/biz/&#123;id&#125;&quot;)</span></span><br><span class="line">    PayOrderDTO <span class="title function_">queryPayOrderByBizOrderNo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PayClientFallback代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.api.client.fallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.api.client.PayClient;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.dto.PayOrderDTO;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FallbackFactory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayClientFallback</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;PayClient&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PayClient <span class="title function_">create</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PayClient</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> PayOrderDTO <span class="title function_">queryPayOrderByBizOrderNo</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，在pay-service模块的PayController中实现该接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;根据id查询支付单&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/biz/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> PayOrderDTO <span class="title function_">queryPayOrderByBizOrderNo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">    <span class="type">PayOrder</span> <span class="variable">payOrder</span> <span class="operator">=</span> payOrderService.lambdaQuery().eq(PayOrder::getBizOrderNo, id).one();</span><br><span class="line">    <span class="keyword">return</span> BeanUtils.copyBean(payOrder, PayOrderDTO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息监听"><a href="#消息监听" class="headerlink" title="消息监听"></a>消息监听</h3><p>接下来，我们在trader-service编写一个监听器，监听延迟消息，查询订单支付状态：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1690343618777-60200e66-3734-439b-91fe-db8ea3eba148.png#averageHue=%23f9fbf8&clientId=u8e4bad19-60cd-4&from=paste&height=473&id=u1b34de9f&originHeight=528&originWidth=775&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=50673&status=done&style=none&taskId=u3f7707e8-1cb4-4f00-9175-570265974eb&title=&width=694.677856302601#averageHue=%23f9fbf8&id=DZO1d&originHeight=528&originWidth=775&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.trade.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.api.client.PayClient;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.dto.PayOrderDTO;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.domain.MultiDelayMessage;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.constants.MqConstants;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.domain.po.Order;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.service.IOrderService;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.ExchangeTypes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderStatusListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IOrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PayClient payClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = MqConstants.DELAY_ORDER_QUEUE, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = MqConstants.DELAY_EXCHANGE, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">            key = MqConstants.DELAY_ORDER_ROUTING_KEY</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenOrderCheckDelayMessage</span><span class="params">(MultiDelayMessage&lt;Long&gt; msg)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取消息中的订单id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">orderId</span> <span class="operator">=</span> msg.getData();</span><br><span class="line">        <span class="comment">// 2.查询订单，判断状态：1是未支付，大于1则是已支付或已关闭</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderService.getById(orderId);</span><br><span class="line">        <span class="keyword">if</span> (order == <span class="literal">null</span> || order.getStatus() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 订单不存在或交易已经结束，放弃处理</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.可能是未支付，查询支付服务</span></span><br><span class="line">        <span class="type">PayOrderDTO</span> <span class="variable">payOrder</span> <span class="operator">=</span> payClient.queryPayOrderByBizOrderNo(orderId);</span><br><span class="line">        <span class="keyword">if</span> (payOrder != <span class="literal">null</span> &amp;&amp; payOrder.getStatus() == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// 支付成功，更新订单状态</span></span><br><span class="line">            orderService.markOrderPaySuccess(orderId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.确定未支付，判断是否还有剩余延迟时间</span></span><br><span class="line">        <span class="keyword">if</span> (msg.hasNextDelay()) &#123;</span><br><span class="line">            <span class="comment">// 4.1.有延迟时间，需要重发延迟消息，先获取延迟时间的int值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">delayVal</span> <span class="operator">=</span> msg.removeNextDelay().intValue();</span><br><span class="line">            <span class="comment">// 4.2.发送延迟消息</span></span><br><span class="line">            rabbitTemplate.convertAndSend(MqConstants.DELAY_EXCHANGE, MqConstants.DELAY_ORDER_ROUTING_KEY, msg,</span><br><span class="line">                    message -&gt; &#123;</span><br><span class="line">                        message.getMessageProperties().setDelay(delayVal);</span><br><span class="line">                        <span class="keyword">return</span> message;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.没有剩余延迟时间了，说明订单超时未支付，需要取消订单</span></span><br><span class="line">        orderService.cancelOrder(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意，这里要在OrderServiceImpl中实现cancelOrder方法，自行实现。</p>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ基础</title>
      <link href="/2024/07/27/MQ%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/07/27/MQ%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>微服务一旦拆分，必然涉及到服务之间的相互调用，目前我们服务之间调用采用的都是基于OpenFeign的调用。这种调用中，调用者发起请求后需要<strong>等待</strong>服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此我们成这种调用方式为<strong>同步调用</strong>，也可以叫<strong>同步通讯</strong>。但在很多场景下，我们可能需要采用<strong>异步通讯</strong>的方式，为什么呢？<br>我们先来看看什么是同步通讯和异步通讯。如图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1686983181054-f2bcce85-1fce-412f-95cd-1ae829f8406f.png#averageHue=%239dce6d&clientId=uf9c47826-2719-4&from=paste&height=613&id=u84c8f02e&originHeight=760&originWidth=1695&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=112976&status=done&style=none&taskId=u779e4d59-c9a8-4b1f-a49f-59c578c4ccd&title=&width=1367.3949141495996#averageHue=%239dce6d&id=uxgso&originHeight=760&originWidth=1695&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>解读：</p><ul><li>同步通讯：就如同打视频电话，双方的交互都是实时的。因此同一时刻你只能跟一个人打视频电话。</li><li>异步通讯：就如同发微信聊天，双方的交互不是实时的，你不需要立刻给对方回应。因此你可以多线操作，同时跟多人聊天。</li></ul><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发微信可以同时与多个人收发微信，但是往往响应会有延迟。<br>所以，如果我们的业务需要实时得到服务提供方的响应，则应该选择同步通讯（同步调用）。而如果我们追求更高的效率，并且不需要实时响应，则应该选择异步通讯（异步调用）。<br>同步调用的方式我们已经学过了，之前的OpenFeign调用就是。但是：</p><ul><li>异步调用又该如何实现？</li><li>哪些业务适合用异步调用来实现呢？</li></ul><p>通过今天的学习你就能明白这些问题了。</p><blockquote><p>感谢黑马程序员的资料参考。</p></blockquote><h1 id="初识MQ"><a href="#初识MQ" class="headerlink" title="初识MQ"></a>初识MQ</h1><h2 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h2><p>之前说过，我们现在基于OpenFeign的调用都属于是同步调用，那么这种方式存在哪些问题呢？<br>举个例子，<strong>余额支付功能</strong>为例来分析，首先看下整个流程：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1686989758652-29a64761-c029-4ec4-91aa-f1fc85de086c.jpeg#averageHue=%23fbfafa&id=dYOOA&originHeight=643&originWidth=1832&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>目前我们采用的是基于OpenFeign的同步调用，也就是说业务执行流程是这样的：</p><ul><li>支付服务需要先调用用户服务完成余额扣减</li><li>然后支付服务自己要更新支付流水单的状态</li><li>然后支付服务调用交易服务，更新业务订单状态为已支付</li></ul><p>三个步骤依次执行。<br>这其中就存在3个问题：<br><strong>第一</strong>，<strong>拓展性差</strong><br>我们目前的业务相对简单，但是随着业务规模扩大，产品的功能也在不断完善。<br>在大多数电商业务中，用户支付成功后都会以短信或者其它方式通知用户，告知支付成功。假如后期产品经理提出这样新的需求，你怎么办？是不是要在上述业务中再加入通知用户的业务？<br>某些电商项目中，还会有积分或金币的概念。假如产品经理提出需求，用户支付成功后，给用户以积分奖励或者返还金币，你怎么办？是不是要在上述业务中再加入积分业务、返还金币业务？<br>。。。<br>最终你的支付业务会越来越臃肿：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1686984472076-c05b2155-3346-40f5-b85e-5961caa998ab.jpeg#averageHue=%23fbfbfb&id=XNEiV&originHeight=1196&originWidth=1832&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>也就是说每次有新的需求，现有支付逻辑都要跟着变化，代码经常变动，不符合开闭原则，拓展性不好。<br><strong>第二</strong>，<strong>性能下降</strong><br>由于我们采用了同步调用，调用者需要等待服务提供者执行完返回结果后，才能继续向下执行，也就是说每次远程调用，调用者都是阻塞等待状态。最终整个业务的响应时长就是每次远程调用的执行时长之和：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1686989760653-42e1ae3e-677b-4f27-b55a-eaa259f03ad3.jpeg#averageHue=%23fafafa&id=PTxGD&originHeight=1050&originWidth=1832&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>假如每个微服务的执行时长都是50ms，则最终整个业务的耗时可能高达300ms，性能太差了。<br><strong>第三，级联失败</strong><br>由于我们是基于OpenFeign调用交易服务、通知服务。当交易服务、通知服务出现故障时，整个事务都会回滚，交易失败。<br>这其实就是同步调用的<strong>级联失败</strong>问题。<br>但是大家思考一下，我们假设用户余额充足，扣款已经成功，此时我们应该确保支付流水单更新为已支付，确保交易成功。毕竟收到手里的钱没道理再退回去吧<img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1686986652875-9e2924a9-e0f3-4de2-ae41-8b39ef6345bc.png#averageHue=%23d2c088&clientId=uf9c47826-2719-4&from=paste&height=22&id=u1eecfdc1&originHeight=143&originWidth=150&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=42199&status=done&style=none&taskId=u80811df5-062e-457a-a9a8-0173e00f6b1&title=&width=22.999998092651367#averageHue=%23d2c088&id=HnsL3&originHeight=143&originWidth=150&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none">。<br>因此，这里不能因为短信通知、更新订单状态失败而回滚整个事务。</p><p>综上，同步调用的方式存在下列问题：</p><ul><li>拓展性差</li><li>性能下降</li><li>级联失败</li></ul><p>而要解决这些问题，我们就必须用<strong>异步调用</strong>的方式来代替<strong>同步调用</strong>。</p><h2 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h2><p>异步调用方式其实就是基于消息通知的方式，一般包含三个角色：</p><ul><li>消息发送者：投递消息的人，就是原来的调用方</li><li>消息Broker：管理、暂存、转发消息，你可以把它理解成微信服务器</li><li>消息接收者：接收和处理消息的人，就是原来的服务提供方</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1686990662733-65b0eac8-f65f-4024-a581-6d5761c4c5a4.jpeg#averageHue=%23f8eee6&id=sGtac&originHeight=303&originWidth=1378&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>在异步调用中，发送者不再直接同步调用接收者的业务接口，而是发送一条消息投递给消息Broker。然后接收者根据自己的需求从消息Broker那里订阅消息。每当发送方发送消息后，接受者都能获取消息并处理。<br>这样，发送消息的人和接收消息的人就完全解耦了。<br>还是以余额支付业务为例：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1686990257816-4f0b5ddd-7618-4095-b797-25b92f0bf2a5.jpeg#averageHue=%23faf8f6&id=OOrSZ&originHeight=844&originWidth=1832&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>除了扣减余额、更新支付流水单状态以外，其它调用逻辑全部取消。而是改为发送一条消息到Broker。而相关的微服务都可以订阅消息通知，一旦消息到达Broker，则会分发给每一个订阅了的微服务，处理各自的业务。<br>假如产品经理提出了新的需求，比如要在支付成功后更新用户积分。支付代码完全不用变更，而仅仅是让积分服务也订阅消息即可：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1686989956210-7c1f451c-0368-4602-b02e-a66f2c0f6deb.jpeg#averageHue=%23faf9f7&id=HHzkG&originHeight=1050&originWidth=1832&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>不管后期增加了多少消息订阅者，作为支付服务来讲，执行问扣减余额、更新支付流水状态后，发送消息即可。业务耗时仅仅是这三部分业务耗时，仅仅100ms，大大提高了业务性能。<br>另外，不管是交易服务、通知服务，还是积分服务，他们的业务与支付关联度低。现在采用了异步调用，解除了耦合，他们即便执行过程中出现了故障，也不会影响到支付服务。<br>综上，异步调用的优势包括：</p><ul><li>耦合度更低</li><li>性能更好</li><li>业务拓展性强</li><li>故障隔离，避免级联失败</li></ul><p>当然，异步通信也并非完美无缺，它存在下列缺点：</p><ul><li>完全依赖于Broker的可靠性、安全性和性能</li><li>架构复杂，后期维护和调试麻烦</li></ul><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>消息Broker，目前常见的实现方案就是消息队列（MessageQueue），简称为MQ.<br>目比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司&#x2F;社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ<br>追求可靠性：RabbitMQ、RocketMQ<br>追求吞吐能力：RocketMQ、Kafka<br>追求消息低延迟：RabbitMQ、Kafka<br>据统计，目前国内消息队列使用最多的还是RabbitMQ，再加上其各方面都比较均衡，稳定性也好，因此我们课堂上选择RabbitMQ来学习。</p><h2 id="使用目的"><a href="#使用目的" class="headerlink" title="使用目的"></a>使用目的</h2><h3 id="高并发的流量削峰"><a href="#高并发的流量削峰" class="headerlink" title="高并发的流量削峰"></a>高并发的流量削峰</h3><p>举个例子，假设某订单系统每秒最多能处理一万次订单，也就是最多承受的10000qps，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1722088076726-97c163b4-2de9-408e-a5c9-705a9b56b126.png#averageHue=%23f4f0e2&clientId=u012f9b5b-e4ae-4&from=paste&id=u787a0337&originHeight=482&originWidth=1914&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=ub4a8e3ed-8a8f-4450-9a42-b7fb1efac18&title="></p><h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1722088097048-6ff4c431-fd07-44c9-8b05-731ca18f5499.png#averageHue=%23f7f7f7&clientId=u012f9b5b-e4ae-4&from=paste&id=u6a21c5f2&originHeight=314&originWidth=1011&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u191cbeb7-af82-4351-9ef1-aef3d2d4179&title="></p><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息队列，可以很方便解决这个问题，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1722088105341-ae5fd0ba-14fc-4d75-9840-033b320637ab.png#averageHue=%23fbfbfb&clientId=u012f9b5b-e4ae-4&from=paste&id=u883e7a6b&originHeight=836&originWidth=1892&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u1381677e-8395-4457-aad1-4b5c7bef3b4&title="></p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>以订单服务为例，传统的方式为单体应用，支付、修改订单状态、创建物流订单三个步骤集成在一个服务中，因此这三个步骤可以放在一个jdbc事务中，要么全成功，要么全失败。而在微服务的环境下，会将三个步骤拆分成三个服务，例如：支付服务，订单服务，物流服务。三者各司其职，相互之间进行服务间调用，但这会带来分布式事务的问题，因为三个步骤操作的不是同一个数据库，导致无法使用jdbc事务管理以达到一致性。而 MQ 能够很好的帮我们解决分布式事务的问题，有一个比较容易理解的方案，就是二次提交。基于MQ的特点，MQ作为二次提交的中间节点，负责存储请求数据，在失败的情况可以进行多次尝试，或者基于MQ中的队列数据进行回滚操作，是一个既能保证性能，又能保证业务一致性的方案，如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1722088119467-d7f4178b-1b43-49f9-907d-9bea27d9536b.png#averageHue=%23fbfbfb&clientId=u012f9b5b-e4ae-4&from=paste&id=uc61c5a13&originHeight=1010&originWidth=2022&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u0acca753-6ba1-4cc6-bedb-7870505ba4e&title="></p><h3 id="数据分发"><a href="#数据分发" class="headerlink" title="数据分发"></a>数据分发</h3><p>MQ 具有发布订阅机制，不仅仅是简单的上游和下游一对一的关系，还有支持一对多或者广播的模式，并且都可以根据规则选择分发的对象。这样一份上游数据，众多下游系统中，可以根据规则选择是否接收这些数据，能达到很高的拓展性。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1722088129140-67638657-c06a-41d2-8128-aa2de6e834c5.png#averageHue=%23f5f5f4&clientId=u012f9b5b-e4ae-4&from=paste&id=u2b047517&originHeight=734&originWidth=1498&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=ue629a02d-b383-40ec-99ff-d4ca4ce1d62&title="></p><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p>RabbitMQ是基于Erlang语言开发的开源消息通信中间件，官网地址：<br><a href="https://www.rabbitmq.com/">Messaging that just works — RabbitMQ</a><br>接下来，我们就学习它的基本概念和基础用法。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>我们同样基于Docker来安装RabbitMQ，使用下面的命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=itheima \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line"> -v mq-plugins:/plugins \</span><br><span class="line"> --name mq \</span><br><span class="line"> --hostname mq \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> --network hmall \</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><p>如果拉取镜像困难的话，可以使用课前资料给大家准备的镜像，利用docker load命令加载：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689939432832-7ee45271-f96c-43fa-b0f5-8c01bcdf289f.png#averageHue=%23f8f2f2&clientId=uf6195e90-5366-4&from=paste&height=169&id=u6c039f48&originHeight=188&originWidth=747&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=15874&status=done&style=none&taskId=ub0c7a06c-2f63-4bc5-98d6-da0bfc75c32&title=&width=669.5798176232812#averageHue=%23f8f2f2&id=MCtBY&originHeight=188&originWidth=747&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>可以看到在安装命令中有两个映射的端口：</p><ul><li>15672：RabbitMQ提供的管理控制台的端口</li><li>5672：RabbitMQ的消息发送处理接口</li></ul><p>安装完成后，我们访问 <a href="http://192.168.150.101:15672即可看到管理控制台。首次访问需要登录，默认的用户名和密码在配置文件中已经指定了。">http://192.168.150.101:15672即可看到管理控制台。首次访问需要登录，默认的用户名和密码在配置文件中已经指定了。</a><br>登录后即可看到管理控制台总览页面：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687137883587-56417f79-a649-43a5-be88-2ff777d3cd25.png#averageHue=%23f7f6f6&clientId=u6a529863-cf4b-4&from=paste&height=707&id=u7d848ee1&originHeight=876&originWidth=1572&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=83168&status=done&style=none&taskId=ub505f8cf-075f-462b-bce3-e0df935715d&title=&width=1268.168026574142#averageHue=%23f7f6f6&id=u2C3c&originHeight=876&originWidth=1572&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"></p><p>RabbitMQ对应的架构如图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687136827222-52374724-79c9-4738-b53f-653cc0805d22.png#averageHue=%23e8d7b3&clientId=u6a529863-cf4b-4&from=paste&height=495&id=ub8dd8df6&originHeight=614&originWidth=1458&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=104273&status=done&style=none&taskId=uc0c132a5-73a3-4024-819f-61241da2511&title=&width=1176.2016429676203#averageHue=%23e8d7b3&id=HAg2G&originHeight=614&originWidth=1458&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>其中包含几个概念：</p><ul><li><code>publisher</code>：生产者，也就是发送消息的一方</li><li><code>consumer</code>：消费者，也就是消费消息的一方</li><li><code>queue</code>：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li><code>exchange</code>：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。</li><li><code>virtual host</code>：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue</li></ul><p>上述这些东西都可以在RabbitMQ的管理控制台来管理，下一节我们就一起来学习控制台的使用。</p><h2 id="收发消息"><a href="#收发消息" class="headerlink" title="收发消息"></a>收发消息</h2><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>我们打开Exchanges选项卡，可以看到已经存在很多交换机：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687137953880-08aa9694-6a1e-4337-8bde-5757ec3c33f8.png#averageHue=%23f7f6f6&clientId=u6a529863-cf4b-4&from=paste&height=605&id=u413741e2&originHeight=750&originWidth=1264&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=60217&status=done&style=none&taskId=u8611b86c-aa50-46d9-855f-8307a318079&title=&width=1019.6974463038903#averageHue=%23f7f6f6&id=GokSx&originHeight=750&originWidth=1264&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>我们点击任意交换机，即可进入交换机详情页面。仍然会利用控制台中的publish message 发送一条消息：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687138031622-ccce4612-954f-42c0-9291-73cf19915e39.png#averageHue=%23f9f8f7&clientId=u6a529863-cf4b-4&from=paste&height=487&id=u9d211d96&originHeight=604&originWidth=947&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=38263&status=done&style=none&taskId=ue134ec0e-ad83-465f-a1b2-97cb7667d75&title=&width=763.9663620647026#averageHue=%23f9f8f7&id=dQPGF&originHeight=604&originWidth=947&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687138163403-839087fe-66f7-4710-a866-210aa0282be8.png#averageHue=%23f9f6f6&clientId=u6a529863-cf4b-4&from=paste&height=616&id=ubca84480&originHeight=763&originWidth=1092&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=46085&status=done&style=none&taskId=u5f176fff-eda8-457c-94cd-bb7d6bbd997&title=&width=880.9411482308925#averageHue=%23f9f6f6&id=AYMDi&originHeight=763&originWidth=1092&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>这里是由控制台模拟了生产者发送的消息。由于没有消费者存在，最终消息丢失了，这样说明交换机没有存储消息的能力。</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>我们打开<code>Queues</code>选项卡，新建一个队列：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687138308409-be6e1649-af03-4ee7-bee3-8518fd0dca03.png#averageHue=%23f9f8f7&clientId=u6a529863-cf4b-4&from=paste&height=417&id=u398bfe43&originHeight=517&originWidth=1157&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=35084&status=done&style=none&taskId=u3b2b568c-e113-4abf-971c-2aea7bfaa4b&title=&width=933.3781213398743#averageHue=%23f9f8f7&id=XbqTA&originHeight=517&originWidth=1157&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>命名为<code>hello.queue1</code>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687255044231-4b0e0339-c1ab-468a-8a72-9ae1b184594c.png#averageHue=%23f9f6f6&clientId=u1711eaf3-9387-4&from=paste&height=548&id=uf3cb4af4&originHeight=679&originWidth=1163&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=51428&status=done&style=none&taskId=u71f9590b-0cc5-4727-bd4c-65b353c4df7&title=&width=938.2184573191648#averageHue=%23f9f6f6&id=HM5Ms&originHeight=679&originWidth=1163&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>再以相同的方式，创建一个队列，密码为<code>hello.queue2</code>，最终队列列表如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687255204405-523f8053-e414-45f3-99c3-b66de152f79e.png#averageHue=%23f6f5f4&clientId=u1711eaf3-9387-4&from=paste&height=359&id=u956d1947&originHeight=445&originWidth=1074&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=39049&status=done&style=none&taskId=u1eb8bf9f-f74b-4238-a33e-796c4280e78&title=&width=866.4201402930207#averageHue=%23f6f5f4&id=fSOxB&originHeight=445&originWidth=1074&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>此时，我们再次向<code>amq.fanout</code>交换机发送一条消息。会发现消息依然没有到达队列！！<br>怎么回事呢？<br>发送到交换机的消息，只会路由到与其绑定的队列，因此仅仅创建队列是不够的，我们还需要将其与交换机绑定。</p><h3 id="绑定关系"><a href="#绑定关系" class="headerlink" title="绑定关系"></a>绑定关系</h3><p>点击<code>Exchanges</code>选项卡，点击<code>amq.fanout</code>交换机，进入交换机详情页，然后点击<code>Bindings</code>菜单，在表单中填写要绑定的队列名称：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687255547460-d87943cd-4309-4778-8e9e-374167a97e45.png#averageHue=%23f9f7f7&clientId=u1711eaf3-9387-4&from=paste&height=481&id=u04a61731&originHeight=596&originWidth=1022&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=34676&status=done&style=none&taskId=u0ce69958-400b-4c37-89ea-adf0b369080&title=&width=824.4705618058354#averageHue=%23f9f7f7&id=W5jbX&originHeight=596&originWidth=1022&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>相同的方式，将hello.queue2也绑定到改交换机。<br>最终，绑定结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687255624712-7bd850b1-95fd-4d98-8243-57d1779de935.png#averageHue=%23f7f4f4&clientId=u1711eaf3-9387-4&from=paste&height=385&id=u82198db4&originHeight=477&originWidth=978&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=28098&status=done&style=none&taskId=u1394f18f-c109-4688-9eb1-effec6a43fb&title=&width=788.9747646243708#averageHue=%23f7f4f4&id=jNHjQ&originHeight=477&originWidth=978&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"></p><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>再次回到exchange页面，找到刚刚绑定的<code>amq.fanout</code>，点击进入详情页，再次发送一条消息：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687138163403-839087fe-66f7-4710-a866-210aa0282be8.png#averageHue=%23f9f6f6&clientId=u6a529863-cf4b-4&from=paste&height=616&id=GyhjT&originHeight=763&originWidth=1092&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=46085&status=done&style=none&taskId=u5f176fff-eda8-457c-94cd-bb7d6bbd997&title=&width=880.9411482308925#averageHue=%23f9f6f6&id=VvAzn&originHeight=763&originWidth=1092&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>回到<code>Queues</code>页面，可以发现<code>hello.queue</code>中已经有一条消息了：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687255725782-fd5e2550-3572-48c0-9ec0-60786e33a3b1.png#averageHue=%23f5f4f3&clientId=u1711eaf3-9387-4&from=paste&height=319&id=u97a4707c&originHeight=395&originWidth=1051&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=38484&status=done&style=none&taskId=u4d68c013-3032-4d2b-83a0-571c3335780&title=&width=847.8655190390733#averageHue=%23f5f4f3&id=G2QB8&originHeight=395&originWidth=1051&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>点击队列名称，进入详情页，查看队列详情，这次我们点击get message：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687255765034-69e67460-1535-48b3-8537-da383c498141.png#averageHue=%23f8f7f7&clientId=u1711eaf3-9387-4&from=paste&height=473&id=ua850c29b&originHeight=586&originWidth=974&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=35281&status=done&style=none&taskId=u668d2c9f-54a9-4427-adc4-e121a960025&title=&width=785.7478739715103#averageHue=%23f8f7f7&id=DLdHp&originHeight=586&originWidth=974&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>可以看到消息到达队列了：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687255798153-dda9b729-a3a0-415c-9167-48c525c75800.png#averageHue=%23f9f7f7&clientId=u1711eaf3-9387-4&from=paste&height=466&id=u66fa5450&originHeight=578&originWidth=762&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=33500&status=done&style=none&taskId=u665361c6-23b2-4fc4-b1a9-fdf6c880545&title=&width=614.7226693699085#averageHue=%23f9f7f7&id=HpuzZ&originHeight=578&originWidth=762&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>这个时候如果有消费者监听了MQ的<code>hello.queue1</code>或<code>hello.queue2</code>队列，自然就能接收到消息了。</p><h2 id="数据隔离"><a href="#数据隔离" class="headerlink" title="数据隔离"></a>数据隔离</h2><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>点击<code>Admin</code>选项卡，首先会看到RabbitMQ控制台的用户管理界面：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687151143347-f7e2aaff-0a14-4022-8d50-582ee75e2998.png#averageHue=%23f7f5f5&clientId=uc5430584-57f9-4&from=paste&height=450&id=u2a51a990&originHeight=558&originWidth=1580&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=55212&status=done&style=none&taskId=u18a12c4e-be8d-4ccb-a14a-415a21db44a&title=&width=1274.621807879863#averageHue=%23f7f5f5&id=aZ2Qx&originHeight=558&originWidth=1580&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>这里的用户都是RabbitMQ的管理或运维人员。目前只有安装RabbitMQ时添加的<code>itheima</code>这个用户。仔细观察用户表格中的字段，如下：</p><ul><li><code>Name</code>：<code>itheima</code>，也就是用户名</li><li><code>Tags</code>：<code>administrator</code>，说明<code>itheima</code>用户是超级管理员，拥有所有权限</li><li><code>Can access virtual host</code>： <code>/</code>，可以访问的<code>virtual host</code>，这里的<code>/</code>是默认的<code>virtual host</code></li></ul><p>对于小型企业而言，出于成本考虑，我们通常只会搭建一套MQ集群，公司内的多个不同项目同时使用。这个时候为了避免互相干扰， 我们会利用<code>virtual host</code>的隔离特性，将不同项目隔离。一般会做两件事情：</p><ul><li>给每个项目创建独立的运维账号，将管理权限分离。</li><li>给每个项目创建不同的<code>virtual host</code>，将每个项目的数据隔离。</li></ul><p>比如，我们给黑马商城创建一个新的用户，命名为<code>hmall</code>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687151725993-05fe9bd1-8f8b-468d-8456-eac36278bea2.png#averageHue=%23f7f5f5&clientId=uc5430584-57f9-4&from=paste&height=609&id=ua32ca0ae&originHeight=755&originWidth=1569&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=70298&status=done&style=none&taskId=u4f4ed00c-b8dd-4ffd-8a83-75d03c11fb5&title=&width=1265.7478585844967#averageHue=%23f7f5f5&id=BycvY&originHeight=755&originWidth=1569&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>你会发现此时hmall用户没有任何<code>virtual host</code>的访问权限：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687151853554-e671a696-e9c0-4ff5-9caf-31b39e1a17f5.png#averageHue=%23f7f5f4&clientId=uc5430584-57f9-4&from=paste&height=353&id=ueeaf90c6&originHeight=437&originWidth=927&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=31497&status=done&style=none&taskId=u74d79385-5602-447d-8beb-ed20ec36022&title=&width=747.8319088004005#averageHue=%23f7f5f4&id=F3RVf&originHeight=437&originWidth=927&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>别急，接下来我们就来授权。</p><h3 id="virtual-host"><a href="#virtual-host" class="headerlink" title="virtual host"></a>virtual host</h3><p>我们先退出登录：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687152245922-8438490f-d094-4db1-88fa-a2d916d46a97.png#averageHue=%23f6f5f5&clientId=uc5430584-57f9-4&from=paste&height=374&id=u12c0492e&originHeight=463&originWidth=1571&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=50699&status=done&style=none&taskId=u830f1745-a0ed-4202-9849-7653ebae4c2&title=&width=1267.3613039109268#averageHue=%23f6f5f5&id=BatCe&originHeight=463&originWidth=1571&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>切换到刚刚创建的hmall用户登录，然后点击<code>Virtual Hosts</code>菜单，进入<code>virtual host</code>管理页：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687152310566-2531b1c8-b362-47c7-ba81-1b7c1880c18b.png#averageHue=%23f5f4f3&clientId=uc5430584-57f9-4&from=paste&height=409&id=uf51820c2&originHeight=507&originWidth=1565&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=60462&status=done&style=none&taskId=ud7655191-c9d5-4801-9669-55b47348861&title=&width=1262.5209679316363#averageHue=%23f5f4f3&id=cEwtF&originHeight=507&originWidth=1565&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>可以看到目前只有一个默认的<code>virtual host</code>，名字为 <code>/</code>。<br> 我们可以给黑马商城项目创建一个单独的<code>virtual host</code>，而不是使用默认的<code>/</code>。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687152363999-edb47263-f303-4ee8-a80d-be55d6b0ed37.png#averageHue=%23f6f5f4&clientId=uc5430584-57f9-4&from=paste&height=553&id=ufc5bd4a7&originHeight=685&originWidth=1555&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=67199&status=done&style=none&taskId=u38a5fe38-fcb5-4163-bee4-ddffaba416b&title=&width=1254.4537412994853#averageHue=%23f6f5f4&id=BFwqL&originHeight=685&originWidth=1555&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>创建完成后如图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687152448758-d0a05827-10ac-459b-a92f-495304dddf89.png#averageHue=%23f5f5f4&clientId=uc5430584-57f9-4&from=paste&height=232&id=ue38b9ba4&originHeight=287&originWidth=990&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=24622&status=done&style=none&taskId=ue5f326dc-340c-46e0-83d5-84a19fef1d9&title=&width=798.655436582952#averageHue=%23f5f5f4&id=ynXsR&originHeight=287&originWidth=990&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>由于我们是登录<code>hmall</code>账户后创建的<code>virtual host</code>，因此回到<code>users</code>菜单，你会发现当前用户已经具备了对<code>/hmall</code>这个<code>virtual host</code>的访问权限了：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687152695194-6c2dda94-43c4-4ee9-b95c-ca9d8504cd0c.png#averageHue=%23f7f4f4&clientId=ud5bd9b1f-141b-4&from=paste&height=349&id=u0cf22cf3&originHeight=432&originWidth=890&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=30925&status=done&style=none&taskId=u1b04bdb9-ab59-41d9-b2bb-e5f5a0cca59&title=&width=717.9831702614417#averageHue=%23f7f4f4&id=vUs07&originHeight=432&originWidth=890&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>此时，点击页面右上角的<code>virtual host</code>下拉菜单，切换<code>virtual host</code>为 <code>/hmall</code>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687153236457-ca138f25-b351-4095-8855-aa0df42fae65.png#averageHue=%23f7f5f4&clientId=ud5bd9b1f-141b-4&from=paste&height=223&id=u0989d284&originHeight=277&originWidth=1448&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=35060&status=done&style=none&taskId=u6ab4f38a-ad0d-48bd-ace7-7f0281755d1&title=&width=1168.1344163354693#averageHue=%23f7f5f4&id=LEYlI&originHeight=277&originWidth=1448&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>然后再次查看queues选项卡，会发现之前的队列已经看不到了：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687153307085-0157ac47-2d89-4f32-ab9a-d513b0e19f25.png#averageHue=%23f9f6f6&clientId=ud5bd9b1f-141b-4&from=paste&height=431&id=u151b88b9&originHeight=534&originWidth=1443&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=48526&status=done&style=none&taskId=u7ef6af14-7e3c-4988-8721-80965a310f6&title=&width=1164.1008030193937#averageHue=%23f9f6f6&id=QxwQX&originHeight=534&originWidth=1443&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>这就是基于<code>virtual host </code>的隔离效果。</p><h1 id="SpringAMQP"><a href="#SpringAMQP" class="headerlink" title="SpringAMQP"></a>SpringAMQP</h1><p>将来我们开发业务功能的时候，肯定不会在控制台收发消息，而是应该基于编程的方式。由于<code>RabbitMQ</code>采用了AMQP协议，因此它具备跨语言的特性。任何语言只要遵循AMQP协议收发消息，都可以与<code>RabbitMQ</code>交互。并且<code>RabbitMQ</code>官方也提供了各种不同语言的客户端。<br>但是，RabbitMQ官方提供的Java客户端编码相对复杂，一般生产环境下我们更多会结合Spring来使用。而Spring的官方刚好基于RabbitMQ提供了这样一套消息收发的模板工具：SpringAMQP。并且还基于SpringBoot对其实现了自动装配，使用起来非常方便。<br>SpringAmqp的官方地址：<br><a href="https://spring.io/projects/spring-amqp">Spring AMQP</a><br>SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息</li></ul><p>这一章我们就一起学习一下，如何利用SpringAMQP实现对RabbitMQ的消息收发。</p><h2 id="导入Demo工程"><a href="#导入Demo工程" class="headerlink" title="导入Demo工程"></a>导入Demo工程</h2><p>在课前资料给大家提供了一个Demo工程，方便我们学习SpringAMQP的使用：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689939402093-e0e0a3d4-84ed-40b5-bedc-0884fcb4ae64.png#averageHue=%23f9f9f8&clientId=uf6195e90-5366-4&from=paste&height=169&id=u1dad7a09&originHeight=188&originWidth=752&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=15464&status=done&style=none&taskId=u1668b30b-b977-4fc3-89ba-6c2e029e374&title=&width=674.0616102445883#averageHue=%23f9f9f8&id=yYL66&originHeight=188&originWidth=752&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>将其复制到你的工作空间，然后用Idea打开，项目结构如图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687156248415-3fe7ae5b-302b-4a35-a520-b2419e616862.png#averageHue=%23f9fbf8&clientId=ud5bd9b1f-141b-4&from=paste&height=253&id=u53ed8a5e&originHeight=314&originWidth=664&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=30988&status=done&style=none&taskId=u5ab16e5b-840d-4511-b27b-07f42a60f4c&title=&width=535.6638483748284#averageHue=%23f9fbf8&id=bOB2T&originHeight=314&originWidth=664&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>包括三部分：</p><ul><li>mq-demo：父工程，管理项目依赖</li><li>publisher：消息的发送者</li><li>consumer：消息的消费者</li></ul><p>在mq-demo这个父工程中，已经配置好了SpringAMQP相关的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mq-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>publisher<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因此，子工程中就可以直接使用SpringAMQP了。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>在之前的案例中，我们都是经过交换机发送消息到队列，不过有时候为了测试方便，我们也可以直接向队列发送消息，跳过交换机。<br>在入门案例中，我们就演示这样的简单模型，如图：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1687261777988-23fff732-dcfa-499a-a8a1-a66328fe05e7.jpeg#averageHue=%236db936&id=raUEC&originHeight=136&originWidth=1164&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>也就是：</p><ul><li>publisher直接发送消息到队列</li><li>消费者监听并处理队列中的消息<br>:::warning<br><strong>注意</strong>：这种模式一般测试使用，很少在生产中使用。<br>:::</li></ul><p>为了方便测试，我们现在控制台新建一个队列：simple.queue<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687171932026-33eace5d-c0f2-4070-8742-fe8b34c6c749.png#averageHue=%23f9f8f8&clientId=u0fe93ba5-a0ba-4&from=paste&height=602&id=uec08e673&originHeight=746&originWidth=1219&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=53932&status=done&style=none&taskId=ubdce29f2-6d3c-45cc-8b7f-64627bcf68c&title=&width=983.3949264592106#averageHue=%23f9f8f8&id=wTJ1u&originHeight=746&originWidth=1219&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>添加成功：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687172012283-e19d8da6-8944-4f51-a40b-a15f0814b015.png#averageHue=%23f7f6f6&clientId=u0fe93ba5-a0ba-4&from=paste&height=405&id=u61761e6f&originHeight=502&originWidth=1187&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=40787&status=done&style=none&taskId=uaf3c44d8-727d-4f46-8ae6-46245932d99&title=&width=957.5798012363273#averageHue=%23f7f6f6&id=xkGkH&originHeight=502&originWidth=1187&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>接下来，我们就可以利用Java代码收发消息了。</p><h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><p>首先配置MQ地址，在<code>publisher</code>服务的<code>application.yml</code>中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 你的虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/hmall</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">hmall</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>然后在<code>publisher</code>服务中编写测试类<code>SpringAmqpTest</code>，并利用<code>RabbitTemplate</code>实现消息发送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.publisher.amqp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开控制台，可以看到消息已经发送到队列中：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687173164620-51a78ccb-b2a1-474b-8147-076f4b8cee12.png#averageHue=%23f8f7f6&clientId=u0fe93ba5-a0ba-4&from=paste&height=431&id=u34a6c895&originHeight=534&originWidth=1267&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=43690&status=done&style=none&taskId=u6fd3cf33-b6c0-42a6-91f3-e263e176174&title=&width=1022.1176142935356#averageHue=%23f8f7f6&id=nTnPU&originHeight=534&originWidth=1267&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>接下来，我们再来实现消息接收。</p><h3 id="消息接收"><a href="#消息接收" class="headerlink" title="消息接收"></a>消息接收</h3><p>首先配置MQ地址，在<code>consumer</code>服务的<code>application.yml</code>中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 你的虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/hmall</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">hmall</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>然后在<code>consumer</code>服务的<code>com.itheima.consumer.listener</code>包中新建一个类<code>SpringRabbitListener</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line">    <span class="comment">// 利用RabbitListener来声明要监听的队列信息</span></span><br><span class="line">    <span class="comment">// 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。</span></span><br><span class="line">    <span class="comment">// 可以看到方法体中接收的就是消息体的内容</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息。最终consumer收到消息：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687173574481-792b9a3c-bcab-4f96-9d09-206cccdd1456.png#averageHue=%23f7f9f5&clientId=u0fe93ba5-a0ba-4&from=paste&height=405&id=ua133b5cf&originHeight=502&originWidth=1805&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=226083&status=done&style=none&taskId=u72073b8f-ef3f-4ec4-af3e-4187138ca2a&title=&width=1456.134407103261#averageHue=%23f7f9f5&id=fdVmB&originHeight=502&originWidth=1805&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"></p><h2 id="WorkQueues模型"><a href="#WorkQueues模型" class="headerlink" title="WorkQueues模型"></a>WorkQueues模型</h2><p>Work queues，任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1687261956699-4b3c9999-ee86-4dda-a795-1ea5f4f9eef3.jpeg#averageHue=%23fcf6f1&id=blh5T&originHeight=420&originWidth=1410&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。<br>此时就可以使用work 模型，<strong>多个消费者共同处理消息处理，消息处理的速度就能大大提高</strong>了。<br>接下来，我们就来模拟这样的场景。<br>首先，我们在控制台创建一个新的队列，命名为<code>work.queue</code>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687179664222-3e226588-63e3-4275-a9e2-cce5c8e93d4c.png#averageHue=%23f5f2f1&clientId=u0fe93ba5-a0ba-4&from=paste&height=321&id=u96998af1&originHeight=398&originWidth=1180&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=41883&status=done&style=none&taskId=ubcca08d6-3211-435a-ae7c-10fcf4daafe&title=&width=951.9327425938216#averageHue=%23f5f2f1&id=rckPk&originHeight=398&originWidth=1180&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"></p><h3 id="消息发送-1"><a href="#消息发送-1" class="headerlink" title="消息发送"></a>消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。<br>在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * workQueue</span></span><br><span class="line"><span class="comment">     * 向队列中不停发送消息，模拟消息堆积。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, message_&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 发送消息，每20毫秒发送一次，相当于每秒发送50条消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message + i);</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息接收-1"><a href="#消息接收-1" class="headerlink" title="消息接收"></a>消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这两消费者，都设置了<code>Thead.sleep</code>，模拟任务耗时：</p><ul><li>消费者1 sleep了20毫秒，相当于每秒钟处理50个消息</li><li>消费者2 sleep了200毫秒，相当于每秒处理5个消息</li></ul><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。<br>最终结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_0】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.869555300</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_1】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.884518</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_2】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.907454400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_4】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.953332100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_6】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.997867300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_8】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.042178700</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_3】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.086478800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_10】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.087476600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_12】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.132578300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_14】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.175851200</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_16】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.218533400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_18】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.261322900</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_5】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.287003700</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_20】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.304412400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_22】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.349950100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_24】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.394533900</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_26】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.439876500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_28】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.482937800</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_7】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.488977100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_30】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.526409300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_32】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.572148</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_34】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.618264800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_36】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.660780600</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_9】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.689189300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_38】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.705261</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_40】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.746927300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_42】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.789835</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_44】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.834393100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_46】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.875312100</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_11】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.889969500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_48】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.920702500</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_13】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.090725900</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_15】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.293060600</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_17】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.493748</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_19】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.696635100</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_21】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.896809700</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_23】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.099533400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_25】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.301446400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_27】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.504999100</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_29】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.705702500</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_31】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.906601200</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_33】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.108118500</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_35】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.308945400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_37】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.511547700</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_39】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.714038400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_41】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.916192700</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_43】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.116286400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_45】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.318055100</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_47】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.520656400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_49】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.723106700</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到消费者1和消费者2竟然每人消费了25条消息：</p><ul><li>消费者1很快完成了自己的25条消息</li><li>消费者2却在缓慢的处理自己的25条消息。</li></ul><p>也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。导致1个消费者空闲，另一个消费者忙的不可开交。没有充分利用每一个消费者的能力，最终消息处理的耗时远远超过了1秒。这样显然是有问题的。</p><h3 id="能者多劳"><a href="#能者多劳" class="headerlink" title="能者多劳"></a>能者多劳</h3><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><p>再次测试，发现结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_0】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.659664200</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_1】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.680610</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_2】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.703625</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_3】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.724330100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_4】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.746651100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_5】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.768401400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_6】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.790511400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_7】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.812559800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_8】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.834500600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_9】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.857438800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_10】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.880379600</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_11】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.899327100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_12】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.922828400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_13】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.945617400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_14】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.968942500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_15】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.992215400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_16】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.013325600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_17】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.035687100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_18】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.058188</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_19】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.081208400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_20】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.103406200</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_21】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.123827300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_22】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.146165100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_23】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.168828300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_24】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.191769500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_25】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.214839100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_26】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.238998700</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_27】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.259772600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_28】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.284131800</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_29】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.306190600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_30】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.325315800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_31】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.347012500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_32】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.368508600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_33】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.391785100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_34】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.416383800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_35】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.439019</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_36】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.461733900</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_37】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.485990</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_38】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.509219900</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_39】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.523683400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_40】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.547412100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_41】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.571191800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_42】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.593024600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_43】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.616731800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_44】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.640317</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_45】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.663111100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_46】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.686727</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_47】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.709266500</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_48】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.725884900</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_49】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.746299900</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以发现，由于消费者1处理速度较快，所以处理了更多的消息；消费者2处理速度较慢，只处理了6条消息。而最终总的执行耗时也在1秒左右，大大提升。<br>正所谓能者多劳，这样充分利用了每一个消费者的处理能力，可以有效避免消息积压问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Work模型的使用：</p><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量</li></ul><h2 id="交换机类型"><a href="#交换机类型" class="headerlink" title="交换机类型"></a>交换机类型</h2><p>在之前的两个测试案例中，都没有交换机，生产者直接发送消息到队列。而一旦引入交换机，消息发送的模式会有很大变化：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1687264784359-de7cbc4a-ec60-461d-a6a4-3474ba52e0d0.jpeg#averageHue=%23fcf3eb&id=XmI3f&originHeight=607&originWidth=1390&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p><ul><li><strong>Publisher</strong>：生产者，不再发送消息到队列中，而是发给交换机</li><li><strong>Exchange</strong>：交换机，一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</li><li><strong>Queue</strong>：消息队列也与以前一样，接收消息、缓存消息。不过队列一定要与交换机绑定。</li><li><strong>Consumer</strong>：消费者，与以前一样，订阅队列，没有变化</li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！<br>交换机的类型有四种：</p><ul><li><strong>Fanout</strong>：广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机</li><li><strong>Direct</strong>：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列</li><li><strong>Topic</strong>：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</li><li><strong>Headers</strong>：头匹配，基于MQ的消息头匹配，用的较少。</li></ul><p>课堂中，我们讲解前面的三种交换机模式。</p><h2 id="Fanout交换机"><a href="#Fanout交换机" class="headerlink" title="Fanout交换机"></a>Fanout交换机</h2><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。<br>在广播模式下，消息发送流程是这样的：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687181415478-ea4bb17b-48bf-4303-9242-27703efb39d8.png#averageHue=%23fbf6f6&clientId=u0fe93ba5-a0ba-4&from=paste&height=389&id=u41b3ec34&originHeight=482&originWidth=1598&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=84491&status=done&style=none&taskId=u0db849d5-c734-41f3-87c2-d1fe9ec7575&title=&width=1289.1428158177346#averageHue=%23fbf6f6&id=S9Ptn&originHeight=482&originWidth=1598&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"></p><ul><li>1）  可以有多个队列</li><li>2）  每个队列都要绑定到Exchange（交换机）</li><li>3）  生产者发送的消息，只能发送到交换机</li><li>4）  交换机把消息发送给绑定过的所有队列</li><li>5）  订阅队列的消费者都能拿到消息</li></ul><p>我们的计划是这样的：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687182474076-2b479229-56a6-4163-93c4-a6a7187f3dbe.png#averageHue=%23f9f4f4&clientId=u0fe93ba5-a0ba-4&from=paste&height=248&id=ue59e0d8c&originHeight=308&originWidth=1314&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=48827&status=done&style=none&taskId=u7d52896e-f59b-494d-bb25-b376c96414e&title=&width=1060.0335794646453#averageHue=%23f9f4f4&id=NC2Ht&originHeight=308&originWidth=1314&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"></p><ul><li>创建一个名为<code> hmall.fanout</code>的交换机，类型是<code>Fanout</code></li><li>创建两个队列<code>fanout.queue1</code>和<code>fanout.queue2</code>，绑定到交换机<code>hmall.fanout</code></li></ul><h3 id="声明队列和交换机"><a href="#声明队列和交换机" class="headerlink" title="声明队列和交换机"></a>声明队列和交换机</h3><p>在控制台创建队列<code>fanout.queue1</code>:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689946886137-0bcb8641-faf1-4bea-b553-4b3bb96d224c.png#averageHue=%23f8f7f7&clientId=uf6195e90-5366-4&from=paste&height=380&id=ub435a220&originHeight=424&originWidth=1117&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=31069&status=done&style=none&taskId=uf02d05dd-b916-4d37-b2f4-dba06eff8a9&title=&width=1001.2324716000069#averageHue=%23f8f7f7&id=bEc3i&originHeight=424&originWidth=1117&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>在创建一个队列<code>fanout.queue2</code>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689946949922-c4e442c3-568b-4164-a327-74e30aa9b9d0.png#averageHue=%23f8f6f5&clientId=uf6195e90-5366-4&from=paste&height=380&id=u452ddf31&originHeight=424&originWidth=916&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=29357&status=done&style=none&taskId=u657c70e9-017c-4339-98e0-2d408950262&title=&width=821.0644082234613#averageHue=%23f8f6f5&id=IWVpK&originHeight=424&originWidth=916&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>然后再创建一个交换机：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689948003779-ea99bac6-6b84-48f3-9760-a719ba5f0c2e.png#averageHue=%23f8f6f6&clientId=uf6195e90-5366-4&from=paste&height=359&id=ud456637e&originHeight=401&originWidth=886&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=22862&status=done&style=none&taskId=uba3f2a17-5520-43f0-abd4-2eec22a7c3a&title=&width=794.1736524956187#averageHue=%23f8f6f6&id=BsjVB&originHeight=401&originWidth=886&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>然后绑定两个队列到交换机：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689947064113-23e123ec-a601-4af4-a44f-70f7b4ef4063.png#averageHue=%23f8f7f7&clientId=uf6195e90-5366-4&from=paste&height=527&id=u2d63999d&originHeight=588&originWidth=978&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=34267&status=done&style=none&taskId=uc512438d-9693-44f1-9c35-33917ddbced&title=&width=876.6386367276695#averageHue=%23f8f7f7&id=ATGsY&originHeight=588&originWidth=978&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689947695506-5346b816-61c7-4bfe-a28d-db261b3598c5.png#averageHue=%23f8f7f7&clientId=uf6195e90-5366-4&from=paste&height=537&id=u17bcbe41&originHeight=599&originWidth=985&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=34532&status=done&style=none&taskId=u17b49cc4-004f-4e31-bd46-bdef7fe19a1&title=&width=882.9131463974993#averageHue=%23f8f7f7&id=kdKfx&originHeight=599&originWidth=985&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"></p><h3 id="消息发送-2"><a href="#消息发送-2" class="headerlink" title="消息发送"></a>消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.fanout&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, everyone!&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息接收-2"><a href="#消息接收-2" class="headerlink" title="消息接收"></a>消息接收</h3><p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>交换机的作用是什么？</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><h2 id="Direct交换机"><a href="#Direct交换机" class="headerlink" title="Direct交换机"></a>Direct交换机</h2><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687182404437-027a5191-b037-4033-baab-6bafd998161d.png#averageHue=%23fbf5f5&clientId=u0fe93ba5-a0ba-4&from=paste&height=430&id=uf5b6a678&originHeight=533&originWidth=1686&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=93278&status=done&style=none&taskId=ud6ffb209-4207-40a6-a7ab-4977cab3b5d&title=&width=1360.1344101806637#averageHue=%23fbf5f5&id=fxSST&originHeight=533&originWidth=1686&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p><strong>案例需求如图</strong>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687182519270-885589ec-7f4a-492a-ab78-cddf109121cc.png#averageHue=%23fbf6f6&clientId=u0fe93ba5-a0ba-4&from=paste&height=430&id=u4dde4f59&originHeight=533&originWidth=1362&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=64401&status=done&style=none&taskId=u62c673b4-a71b-40bf-af49-a8c1a4df0de&title=&width=1098.7562672989704#averageHue=%23fbf6f6&id=lFYkC&originHeight=533&originWidth=1362&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"></p><ol><li>声明一个名为<code>hmall.direct</code>的交换机</li><li>声明队列<code>direct.queue1</code>，绑定<code>hmall.direct</code>，<code>bindingKey</code>为<code>blud</code>和<code>red</code></li><li>声明队列<code>direct.queue2</code>，绑定<code>hmall.direct</code>，<code>bindingKey</code>为<code>yellow</code>和<code>red</code></li><li>在<code>consumer</code>服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2 </li><li>在publisher中编写测试方法，向<code>hmall.direct</code>发送消息</li></ol><h3 id="声明队列和交换机-1"><a href="#声明队列和交换机-1" class="headerlink" title="声明队列和交换机"></a>声明队列和交换机</h3><p>首先在控制台声明两个队列<code>direct.queue1</code>和<code>direct.queue2</code>，这里不再展示过程：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689947864231-5ace5d74-fdac-4a2a-9f92-180df06fe4ad.png#averageHue=%23f2f0ef&clientId=uf6195e90-5366-4&from=paste&height=403&id=u292b8851&originHeight=450&originWidth=1157&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=56948&status=done&style=none&taskId=uf110e543-1005-4b1a-b23e-d8529df3c0c&title=&width=1037.0868125704637#averageHue=%23f2f0ef&id=A8OYF&originHeight=450&originWidth=1157&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>然后声明一个direct类型的交换机，命名为<code>hmall.direct</code>:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689948033525-e6ea1134-c2ef-4b80-86b2-b364c1301335.png#averageHue=%23f8f6f6&clientId=uf6195e90-5366-4&from=paste&height=367&id=u0964090b&originHeight=409&originWidth=871&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=22938&status=done&style=none&taskId=u127085fa-3898-488f-afef-52a7cbf9e2d&title=&width=780.7282746316974#averageHue=%23f8f6f6&id=cJl1x&originHeight=409&originWidth=871&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>然后使用<code>red</code>和<code>blue</code>作为key，绑定<code>direct.queue1</code>到<code>hmall.direct</code>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689948151280-bed1019d-7d60-455b-95b8-754e266edf50.png#averageHue=%23f8f6f6&clientId=uf6195e90-5366-4&from=paste&height=523&id=uf5aa7079&originHeight=583&originWidth=942&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=35339&status=done&style=none&taskId=u31d3c033-0a9a-446f-9ebc-a90405ba47d&title=&width=844.3697298542583#averageHue=%23f8f6f6&id=BFdK3&originHeight=583&originWidth=942&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689948181033-6b1e6556-0110-4ed8-a2cb-8bc2dd388903.png#averageHue=%23f8f6f6&clientId=uf6195e90-5366-4&from=paste&height=522&id=u4e6a2147&originHeight=582&originWidth=874&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=34608&status=done&style=none&taskId=u274e41ea-73f2-4da5-bc23-fed091d234d&title=&width=783.4173502044816#averageHue=%23f8f6f6&id=M7Zsw&originHeight=582&originWidth=874&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>同理，使用<code>red</code>和<code>yellow</code>作为key，绑定<code>direct.queue2</code>到<code>hmall.direct</code>，步骤略，最终结果：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689948243879-c97a0e6f-807a-4bc3-ad53-032c378008f3.png#averageHue=%23f4f4f3&clientId=uf6195e90-5366-4&from=paste&height=515&id=ufb0f0d5d&originHeight=575&originWidth=834&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=37957&status=done&style=none&taskId=uaae894e6-bc07-4e01-bf1f-53561ffd05a&title=&width=747.5630092340249#averageHue=%23f4f4f3&id=iHI8s&originHeight=575&originWidth=834&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"></p><h3 id="消息接收-3"><a href="#消息接收-3" class="headerlink" title="消息接收"></a>消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息发送-3"><a href="#消息发送-3" class="headerlink" title="消息发送"></a>消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于使用的red这个key，所以两个消费者都收到了消息：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687182883516-906024ce-6ade-4dcd-8b4e-2b0cfc1bd03a.png#averageHue=%23f7f9f3&clientId=u0fe93ba5-a0ba-4&from=paste&height=136&id=uc0e2efee&originHeight=168&originWidth=1410&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=85796&status=done&style=none&taskId=u4ab862c3-bb61-4a97-87d8-ac463218ab2&title=&width=1137.4789551332954#averageHue=%23f7f9f3&id=FngD8&originHeight=168&originWidth=1410&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>我们再切换为blue这个key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;最新报道，哥斯拉是居民自治巨型气球，虚惊一场！&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;blue&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现，只有消费者1收到了消息：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687182898732-afba28a8-c57e-4ccb-a330-9e3315879b31.png#averageHue=%23f7f9f4&clientId=u0fe93ba5-a0ba-4&from=paste&height=175&id=udcac360f&originHeight=217&originWidth=1237&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=99781&status=done&style=none&taskId=ua85a2eca-9806-4a15-997d-ee3c73528b6&title=&width=997.9159343970824#averageHue=%23f7f9f4&id=SjNkO&originHeight=217&originWidth=1237&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"></p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>描述下Direct交换机与Fanout交换机的差异？</p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><h2 id="Topic交换机"><a href="#Topic交换机" class="headerlink" title="Topic交换机"></a>Topic交换机</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。<br>只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>BindingKey</code> 的时候使用通配符！<br><code>BindingKey</code> 一般都是有一个或多个单词组成，多个单词之间以<code>.</code>分割，例如： <code>item.insert</code><br>通配符规则：</p><ul><li><code>#</code>：匹配一个或多个词</li><li><code>*</code>：匹配不多不少恰好1个词</li></ul><p>举例：</p><ul><li><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></li><li><code>item.*</code>：只能匹配<code>item.spu</code></li></ul><p>图示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687183148068-ad50ba76-0024-460b-9b24-3cf7a0fe172e.png#averageHue=%23f9f4f3&clientId=u0fe93ba5-a0ba-4&from=paste&height=305&id=u74a65bd0&originHeight=378&originWidth=1337&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=57084&status=done&style=none&taskId=u90f6bfb4-4f10-4ebe-8edb-70856565f27&title=&width=1078.5882007185928#averageHue=%23f9f4f3&id=SEgaM&originHeight=378&originWidth=1337&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>假如此时publisher发送的消息使用的<code>RoutingKey</code>共有四种：</p><ul><li><code>china.news </code>代表有中国的新闻消息；</li><li><code>china.weather</code> 代表中国的天气消息；</li><li><code>japan.news</code> 则代表日本新闻</li><li><code>japan.weather</code> 代表日本的天气消息；</li></ul><p>解释：</p><ul><li><code>topic.queue1</code>：绑定的是<code>china.#</code> ，凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到，包括：<ul><li><code>china.news</code></li><li><code>china.weather</code></li></ul></li><li><code>topic.queue2</code>：绑定的是<code>#.news</code> ，凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括:<ul><li><code>china.news</code></li><li><code>japan.news</code></li></ul></li></ul><p>接下来，我们就按照上图所示，来演示一下Topic交换机的用法。<br>首先，在控制台按照图示例子创建队列、交换机，并利用通配符绑定队列和交换机。此处步骤略。最终结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689948475987-05bab459-43b6-47ad-bbfc-faf9f50d776e.png#averageHue=%23f5f5f4&clientId=uf6195e90-5366-4&from=paste&height=419&id=u3d545ee6&originHeight=468&originWidth=879&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=32637&status=done&style=none&taskId=u1bf5deb0-6b33-48e6-9d9d-d273a1be805&title=&width=787.8991428257888#averageHue=%23f5f5f4&id=nwVqG&originHeight=468&originWidth=879&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"></p><h3 id="消息发送-4"><a href="#消息发送-4" class="headerlink" title="消息发送"></a>消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * topicExchange</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendTopicExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.topic&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;喜报！孙悟空大战哥斯拉，胜!&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息接收-4"><a href="#消息接收-4" class="headerlink" title="消息接收"></a>消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;topic.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;topic.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>描述下Direct交换机与Topic交换机的差异？</p><ul><li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>**.**</code> 分割</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li><li><code>#</code>：代表0个或多个词</li><li><code>*</code>：代表1个词</li></ul><h2 id="声明队列和交换机-2"><a href="#声明队列和交换机-2" class="headerlink" title="声明队列和交换机"></a>声明队列和交换机</h2><p>在之前我们都是基于RabbitMQ控制台来创建队列、交换机。但是在实际开发时，队列和交换机是程序员定义的，将来项目上线，又要交给运维去创建。那么程序员就需要把程序中运行的所有队列和交换机都写下来，交给运维。在这个过程中是很容易出现错误的。<br>因此推荐的做法是由程序启动时检查队列和交换机是否存在，如果不存在自动创建。</p><h3 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h3><p>SpringAMQP提供了一个Queue类，用来创建队列：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689945200636-5f4a823f-6f36-4088-9b67-7b9b3ae48079.png#averageHue=%23f9fcf7&clientId=uf6195e90-5366-4&from=paste&height=241&id=u2a7bba30&originHeight=269&originWidth=930&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=42392&status=done&style=none&taskId=uf1b5d62e-4e09-4ba8-a011-f8345dac005&title=&width=833.6134275631213#averageHue=%23f9fcf7&id=qkaCS&originHeight=269&originWidth=930&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"></p><p>SpringAMQP还提供了一个Exchange接口，来表示所有不同类型的交换机：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687181804385-c500bc13-9f81-4071-ad8a-598fa5f57d97.png#averageHue=%23f8f8f7&clientId=u0fe93ba5-a0ba-4&from=paste&height=379&id=Qewqz&originHeight=470&originWidth=1469&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=23466&status=done&style=none&taskId=u357861af-c5aa-43c4-aafd-97dadaf8714&title=&width=1185.0755922629864#averageHue=%23f8f8f7&id=Y8WWI&originHeight=470&originWidth=1469&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br><img src="/assets/image-20210717165552676.png#id=c2Knj&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=JUa3y&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none">我们可以自己创建队列和交换机，不过SpringAMQP还提供了ExchangeBuilder来简化这个过程：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689945421476-fe44bf9a-d6eb-4f51-af02-374359c8e70b.png#averageHue=%23f8f7f5&clientId=uf6195e90-5366-4&from=paste&height=278&id=uae4334fe&originHeight=310&originWidth=781&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=34426&status=done&style=none&taskId=uc1b7bc5b-68b9-4ce9-afe5-9eb733e8f4b&title=&width=700.0560074481696#averageHue=%23f8f7f5&id=Ef5E3&originHeight=310&originWidth=781&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>而在绑定队列和交换机时，则需要使用BindingBuilder来创建Binding对象：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689945503733-13d2179c-f586-4de5-b18c-d3b5749f1f96.png#averageHue=%23dcab6a&clientId=uf6195e90-5366-4&from=paste&height=145&id=u91096ccd&originHeight=162&originWidth=659&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=16128&status=done&style=none&taskId=u1da153f0-6e86-45b2-900b-8f83e489358&title=&width=590.7002674882763#averageHue=%23dcab6a&id=xLw7s&originHeight=162&originWidth=659&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"></p><h3 id="fanout示例"><a href="#fanout示例" class="headerlink" title="fanout示例"></a>fanout示例</h3><p>在consumer中创建一个类，声明队列和交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;hmall.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="direct示例"><a href="#direct示例" class="headerlink" title="direct示例"></a>direct示例</h3><p>direct模式由于要绑定多个KEY，会非常麻烦，每一个Key都要编写一个binding：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Direct类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(<span class="string">&quot;hmall.direct&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;direct.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1WithRed</span><span class="params">(Queue directQueue1, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue1).to(directExchange).with(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1WithBlue</span><span class="params">(Queue directQueue1, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue1).to(directExchange).with(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;direct.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2WithRed</span><span class="params">(Queue directQueue2, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue2).to(directExchange).with(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2WithYellow</span><span class="params">(Queue directQueue2, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue2).to(directExchange).with(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="基于注解声明"><a href="#基于注解声明" class="headerlink" title="基于注解声明"></a>基于注解声明</h3><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。<br>例如，我们同样声明Direct模式的交换机和队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是简单多了。<br>再试试Topic模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h2><p>Spring的消息发送代码接收的消息体是一个Object：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687183652317-82b0319b-03aa-46ed-afbc-373e7a6fa0f1.png#averageHue=%23f6f9f5&clientId=u0fe93ba5-a0ba-4&from=paste&height=394&id=u2c63fbb1&originHeight=488&originWidth=1448&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=122291&status=done&style=none&taskId=u0da81780-720e-4c27-9c2f-c24d7dc0123&title=&width=1168.1344163354693#averageHue=%23f6f9f5&id=rqbgf&originHeight=488&originWidth=1448&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>而在数据传输时，它会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。<br>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>我们来测试一下。</p><h3 id="测试默认转换器"><a href="#测试默认转换器" class="headerlink" title="测试默认转换器"></a>测试默认转换器</h3><p>1）创建测试队列<br>首先，我们在consumer服务中声明一个新的配置类：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687183868403-242aa812-a07f-4748-8863-dc5d1e161dc1.png#averageHue=%23f9fbf8&clientId=u0fe93ba5-a0ba-4&from=paste&height=351&id=u77b665f4&originHeight=435&originWidth=1053&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=48481&status=done&style=none&taskId=uf6d36991-ec76-497c-93d3-3e96d9d6590&title=&width=849.4789643655035#averageHue=%23f9fbf8&id=TDtMT&originHeight=435&originWidth=1053&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>利用@Bean的方式创建一个队列，<img src="/assets/image-20211104102144275.png#id=PyGPl&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=KLaD5&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none">具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">objectQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;object.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里我们先不要给这个队列添加消费者，我们要查看消息体的格式。<br>重启consumer服务以后，该队列就会被自动创建出来了：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687184033157-c4c8e59e-a2b3-4b2b-9c20-ca3c597e556c.png#averageHue=%23f3f0ef&clientId=u0fe93ba5-a0ba-4&from=paste&height=456&id=u7c3fdb16&originHeight=565&originWidth=1196&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=72445&status=done&style=none&taskId=u03cddb0f-41a3-483d-83c7-d53a5ecb269&title=&width=964.8403052052632#averageHue=%23f3f0ef&id=y1tQZ&originHeight=565&originWidth=1196&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br><img src="/assets/image-20211104102409347.png#id=tPRoz&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=F0q1a&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>2）发送消息<br>我们在publisher模块的SpringAmqpTest中新增一个消息发送的代码，发送一个Map对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 准备消息</span></span><br><span class="line">    Map&lt;String,Object&gt; msg = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    msg.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">    msg.put(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;object.queue&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送消息后查看控制台：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687184206574-69117533-5b4e-4172-b254-23130023f711.png#averageHue=%23f9f7f7&clientId=u0fe93ba5-a0ba-4&from=paste&height=528&id=u038b25c3&originHeight=654&originWidth=1244&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=46749&status=done&style=none&taskId=u8bea522c-fa98-48f1-bd84-1acfb50fff8&title=&width=1003.5629930395882#averageHue=%23f9f7f7&id=KHHkP&originHeight=654&originWidth=1244&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br>可以看到消息格式非常不友好。</p><h3 id="配置JSON转换器"><a href="#配置JSON转换器" class="headerlink" title="配置JSON转换器"></a>配置JSON转换器</h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。<br>在<code>publisher</code>和<code>consumer</code>两个服务中都引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意，如果项目中引入了<code>spring-boot-starter-web</code>依赖，则无需再次引入<code>Jackson</code>依赖。</p><p>配置消息转换器，在<code>publisher</code>和<code>consumer</code>两个服务的启动类中添加一个Bean即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jackson2JsonMessageConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jackson2JsonMessageConverter.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jackson2JsonMessageConverter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息转换器中添加的messageId可以便于我们将来做幂等性判断。</p><p>此时，我们到MQ控制台<strong>删除</strong><code>object.queue</code>中的旧的消息。然后再次执行刚才的消息发送的代码，到MQ的控制台查看消息结构：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687245684217-8b401cc5-29e6-4d08-9a9b-4fbe0dffd486.png#averageHue=%23f9f7f7&clientId=ucdd993b6-34bc-4&from=paste&height=432&id=ue5acc96b&originHeight=535&originWidth=990&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=41352&status=done&style=none&taskId=u158a691b-c3b3-4103-993a-3064dc7139b&title=&width=798.655436582952#averageHue=%23f9f7f7&id=ApSKq&originHeight=535&originWidth=990&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"><br><img src="/assets/image-20211104102831385.png#id=mx45K&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=CNN58&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"></p><h3 id="消费者接收Object"><a href="#消费者接收Object" class="headerlink" title="消费者接收Object"></a>消费者接收Object</h3><p>我们在consumer服务中定义一个新的消费者，publisher是用Map发送，那么消费者也一定要用Map接收，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;object.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(Map&lt;String, Object&gt; msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到object.queue消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20211104103017170.png#id=E5J5O&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=P9u4f&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none"></p>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在线课堂个人总结</title>
      <link href="/2024/07/27/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E5%A0%82/"/>
      <url>/2024/07/27/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E5%A0%82/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="nacos-gateway"><a href="#nacos-gateway" class="headerlink" title="nacos &amp; gateway"></a>nacos &amp; gateway</h3><p>配置文件和服务注册由 Nacos 统一管理，使用 Feign 实现远程调用，网关进行路由管理<br>在项目中使用了Nacos进行统一管理配置文件以及微服务的注册和相互之间的发现，然后微服务之间通过OpenFeign进行相互调用，接口声明是放在调用端，实际代码放在被调用端，通过一些注解进行调用即可<br>网关的话则是对于请求的路由分配起到了作用，这边可以做的事就包括一些请求限制，流量控制一类的。</p><h3 id="认证授权"><a href="#认证授权" class="headerlink" title="认证授权"></a>认证授权</h3><p>采用Spring Security进行认证，根据OAuth 2.0 协议进行JWT令牌的分发<br><a href="https://mx67xggunk5.feishu.cn/wiki/WZ1lwDVi8iWxrRkKYdGcVYOanqb">参考来源</a></p><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><h5 id="认证授权-1"><a href="#认证授权-1" class="headerlink" title="认证授权"></a>认证授权</h5><p>用户先通过访问认证微服务进行认证获取令牌，携带令牌进行访问其他服务。（单点登录：认证一次便可以访问多个系统）<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1721966543298-ec73b8ac-8ab5-4efd-89bd-6d98ca60203c.png#averageHue=%23f8f8f8&clientId=u6d9e292d-44fc-4&from=paste&height=615&id=jsTxn&originHeight=922&originWidth=1541&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=174424&status=done&style=none&taskId=u8b998751-fe76-4274-9fb5-980996522a2&title=&width=1027.3333333333333" alt="image.png"></p><h5 id="Spring-Security工作原理"><a href="#Spring-Security工作原理" class="headerlink" title="Spring Security工作原理"></a>Spring Security工作原理</h5><p>实际上这个框架的工作原理是由一系列的过滤器组成，各有各的作用。重点在于关注<code>**UsernamePasswordAuthenticationFilter**</code>这个过滤器，实际执行流程如下：</p><ol><li>用户提交用户名、密码被SecurityFilterChain中的<code>UsernamePasswordAuthenticationFilter</code>过滤器获取到，封装为请求Authentication，通常情况下是UsernamePasswordAuthenticationToken这个实现类。</li><li>然后过滤器将Authentication提交至认证管理器（AuthenticationManager）进行认证</li><li>认证成功后，<code>AuthenticationManager</code>身份管理器返回一个被填充满了信息的（包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除）<code>Authentication</code>实例。</li><li><code>SecurityContextHolder</code>安全上下文容器将第3步填充了信息的<code>Authentication</code>，通过SecurityContextHolder.getContext().setAuthentication(…)方法，设置到其中。</li><li>可以看出AuthenticationManager接口（认证管理器）是认证相关的核心接口，也是发起认证的出发点，它的实现类为ProviderManager。而Spring Security支持多种认证方式，因此ProviderManager维护着一个<code>List&lt;AuthenticationProvider&gt;</code>列表，存放多种认证方式，最终实际的认证工作是由AuthenticationProvider完成的。咱们知道web表单的对应的AuthenticationProvider实现类为DaoAuthenticationProvider，它的内部又维护着一个UserDetailsService负责UserDetails的获取。最终AuthenticationProvider将UserDetails填充至Authentication。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1721978996844-8aa0ac51-2ec7-4851-90ce-57322b0b91e5.png#averageHue=%23f9f5f1&clientId=u1b4206ee-1628-4&from=paste&height=496&id=ua6f4aacc&originHeight=744&originWidth=1543&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=384398&status=done&style=none&taskId=u890d25ae-be57-4cbb-83ae-c00c5c80e90&title=&width=1028.6666666666667" alt="image.png"></p><h5 id="OAuth-2协议"><a href="#OAuth-2协议" class="headerlink" title="OAuth 2协议"></a>OAuth 2协议</h5><p>OAuth2提供授权码模式、密码模式、简化模式、客户端模式等四种授权模式，前边举的微信扫码登录的例子就是基于授权码模式，这四种模式中授权码模式和密码模式应用较多；该项目使用密码模式进行认证，当然微信登录是授权码模式（相对比较复杂一些）</p><h5 id="JWT令牌"><a href="#JWT令牌" class="headerlink" title="JWT令牌"></a>JWT令牌</h5><p>JSON Web Token（JWT）是一种使用JSON格式传递数据的网络令牌技术。<br>JWT令牌的优点：</p><ol><li>jwt基于json，非常方便解析。</li><li>可以在令牌中自定义丰富的内容，易扩展。</li><li>通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高。</li><li>资源服务使用JWT可不依赖认证服务即可完成授权。</li></ol><p>缺点：<br>JWT令牌较长，占存储空间比较大。</p><p>JWT令牌由三部分组成，每部分中间使用点（.）分隔，比如：xxxxx.yyyyy.zzzzz</p><ol><li>Header</li></ol><p> 头部包括令牌的类型（即JWT）及使用的哈希算法（如HMAC SHA256或RSA）<br> 一个例子如下：<br> 下边是Header部分的内容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p> 将上边的内容使用Base64Url编码，得到一个字符串就是JWT令牌的第一部分。</p><ol start="2"><li>Payload</li></ol><p> 第二部分是负载，内容也是一个json对象，它是存放有效信息的地方，它可以存放jwt提供的信息字段，比如：iss（签发者）,exp（过期时间戳）, sub（面向的用户）等，也可自定义字段。<br> 此部分不建议存放敏感信息，因为此部分可以解码还原原始内容。<br> 最后将第二部分负载使用Base64Url编码，得到一个字符串就是JWT令牌的第二部分。<br> 一个例子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;456&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>Signature</li></ol><p> 第三部分是签名，此部分用于防止jwt内容被篡改。<br> 这个部分使用base64url将前两部分进行编码，编码后使用点（.）连接组成字符串，最后使用header中声明的签名算法进行签名。<br> 一个例子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">base64UrlEncode(payload)<span class="punctuation">,</span></span><br><span class="line">secret)</span><br></pre></td></tr></table></figure><p>base64UrlEncode(header)：jwt令牌的第一部分。<br>base64UrlEncode(payload)：jwt令牌的第二部分。<br>secret：签名所使用的密钥。<br>为什么JWT可以防止篡改？<br>第三部分使用签名算法对第一部分和第二部分的内容进行签名，常用的签名算法是 HS256，常见的还有md5,sha 等，签名算法需要使用密钥进行签名，密钥不对外公开，并且签名是不可逆的，如果第三方更改了内容那么服务器验证签名就会失败，要想保证验证签名正确必须保证内容、密钥与签名前一致。</p><h4 id="应用过程"><a href="#应用过程" class="headerlink" title="应用过程"></a>应用过程</h4><h5 id="Spring-Security的认证工作原理"><a href="#Spring-Security的认证工作原理" class="headerlink" title="Spring Security的认证工作原理"></a>Spring Security的认证工作原理</h5><p>在认证阶段，前端发送来用户名和密码，我们重写<code>WebSecurityConfigurerAdapter</code>进行配置拦截，由<code>DaoAuthenticationProvider</code>调用<code>UserDetailsService</code>的<code>loadUserByUsername()</code>方法获取<code>UserDetails</code>用户信息（从数据库或者内存中获取 ），之后进行用户信息验证阶段，<code>DaoAuthenticationProvider</code>会调用<code>additionalAuthenticationChecks()</code>方法进行密码校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    <span class="keyword">if</span> (authentication.getCredentials() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Failed to authenticate since no credentials provided&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(<span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;</span>, <span class="string">&quot;Bad credentials&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">presentedPassword</span> <span class="operator">=</span> authentication.getCredentials().toString();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Failed to authenticate since password does not match stored value&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(<span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;</span>, <span class="string">&quot;Bad credentials&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>项目使用<code>BCrypt</code>进行加密，一种加盐的单向Hash，不可逆的加密算法，同一种明文（plaintext），每次加密后的密文都不一样，而且不可反向破解生成明文，破解难度很大。生成的密文是60位的，虽然更安全但是加密也更慢。</li><li>与之对比的加密方式是<code>MD5</code>加密，是不加盐的单向Hash，不可逆的加密算法，同一个密码经过hash的时候生成的是同一个hash值，在大多数的情况下，有些经过md5加密的方法将会被破解。</li></ul><h5 id="进行用户信息的扩展"><a href="#进行用户信息的扩展" class="headerlink" title="进行用户信息的扩展"></a>进行用户信息的扩展</h5><p>在我们进行发放用户令牌的时候，需要使用来自<code>UserDetails</code>的用户信息，使用原生的话通常只包含用户名和密码，这是不够的，所以需要我们进行扩充。<br>第一是可以扩展UserDetails，使之包括更多的自定义属性，第二也可以扩展username的内容，，比如存入json数据内容作为username的内容。相比较而言，方案二比较简单还不用破坏UserDetails的结构，我们采用方案二。<br>前边说过<code>Security</code>是通过<code>loadUserByUsername()</code>方法来加载账号信息，我们就可以重写这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据用户名查询用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 用户信息，JSON格式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">    <span class="type">AuthParamsDto</span> <span class="variable">authParamsDto</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        authParamsDto = JSON.parseObject(s, AuthParamsDto.class);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;认证请求不符合项目要求:&#123;&#125;&quot;</span>,s);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;请求认证参数不合法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据认证类型获取对应的认证服务(Bean名称), 策略模式</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">authType</span> <span class="operator">=</span> authParamsDto.getAuthType();</span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> authType + <span class="string">&quot;_authService&quot;</span>;</span><br><span class="line">    <span class="type">AuthService</span> <span class="variable">authService</span> <span class="operator">=</span> applicationContext.getBean(beanName, AuthService.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行认证</span></span><br><span class="line">    <span class="type">XcUserExt</span> <span class="variable">xcUserExt</span> <span class="operator">=</span> authService.execute(authParamsDto);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回userDetails对象</span></span><br><span class="line">    <span class="keyword">return</span> getUserPrincipal(xcUserExt);  <span class="comment">// TODO 在这里使用了下面这个方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 查询用户权限，构建UserDetails对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> UserDetails <span class="title function_">getUserPrincipal</span><span class="params">(XcUserExt user)</span>&#123;</span><br><span class="line"><span class="comment">//用户权限,如果不加报Cannot pass a null GrantedAuthority collection</span></span><br><span class="line">List&lt;XcMenu&gt; xcMenus = xcMenuMapper.selectPermissionByUserId(user.getId());</span><br><span class="line">List&lt;String&gt; permissions = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (!xcMenus.isEmpty())&#123;</span><br><span class="line">    permissions = xcMenus.stream().map(XcMenu::getCode).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line">String[] authorities = &#123;<span class="string">&quot;p1&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> user.getPassword();</span><br><span class="line"><span class="comment">//为了安全在令牌中不放密码</span></span><br><span class="line">user.setPassword(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//将user对象转json</span></span><br><span class="line"><span class="type">String</span> <span class="variable">userString</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line"><span class="comment">//创建UserDetails对象</span></span><br><span class="line"><span class="keyword">return</span> User.withUsername(userString)</span><br><span class="line">.password(password)</span><br><span class="line">.authorities(Objects.requireNonNull(permissions).toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]))</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里还包含了采用策略模式进行认证，认证完成后会返回用户信息，在<code>getUserPrincipal()</code>方法会查询用户的权限信息之后构建UserDetails对象。</p></blockquote><h5 id="认证方式扩充"><a href="#认证方式扩充" class="headerlink" title="认证方式扩充"></a>认证方式扩充</h5><p>由前文所说在获得<code>UserDetails</code>对象信息后，<code>DaoAuthenticationProvider</code>会调用<code>additionalAuthenticationChecks()</code>方法进行密码校验。因此为了扩充成功，我们先将该方法重写为空方法，达到屏蔽原生密码认证的功能。并且在<code>WebSecurityConfig</code>中设置认证器（<code>authenticationProvider</code>个人翻译）来源。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoAuthenticationProviderCustom</span> <span class="keyword">extends</span> <span class="title class_">DaoAuthenticationProvider</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDetailsService</span><span class="params">(UserDetailsService userDetailsService)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setUserDetailsService(userDetailsService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//屏蔽密码对比</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置认证器来源</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DaoAuthenticationProviderCustom daoAuthenticationProviderCustom;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    auth.authenticationProvider(daoAuthenticationProviderCustom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再根据上文可知，我将认证过程放在了<code>loadUserByUsername()</code>方法内，采用了一个策略模式。</p><h5 id="配置JWT令牌发放服务"><a href="#配置JWT令牌发放服务" class="headerlink" title="配置JWT令牌发放服务"></a>配置<code>JWT</code>令牌发放服务</h5><p>在配置好令牌的一些配置后，将其添加到令牌管理服务中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//令牌端点的访问配置</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> &#123;</span><br><span class="line">endpoints</span><br><span class="line">.authenticationManager(authenticationManager)<span class="comment">//认证管理器</span></span><br><span class="line">.tokenServices(authorizationServerTokenServices)<span class="comment">//令牌管理服务</span></span><br><span class="line">.allowedTokenEndpointRequestMethods(HttpMethod.POST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="授权过程"><a href="#授权过程" class="headerlink" title="授权过程"></a>授权过程</h5><p>在客户端得到令牌后，会携带这个令牌进行访问服务器，此时需要判断用户是否有访问权限<br>过程也比较简单，在接口上添加注解<code>@PreAuthorize</code>，表示需要进行授权过程，其中权限在Step 2的<code>getUserPrincipal()</code>方法中对数据库进行了查询，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;xc_teachmanager_course_list&#x27;)&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/course/list&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;课程基础信息查询接口&quot;)</span></span><br><span class="line"><span class="keyword">public</span> PageResult&lt;CourseBase&gt; <span class="title function_">list</span><span class="params">(PageParams pageParams,</span></span><br><span class="line"><span class="params">                                   <span class="meta">@RequestBody</span> QueryCourseParamsDto queryCourseParamsDto)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> courseBaseService.queryCourseBaseList(pageParams,queryCourseParamsDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意这个权限分配是根据<code>RBAC</code>中的基于资源的访问控制，给资源指定访问其所需要的权限，给用户进行授权，两者权限进行对比，得到比较结果。</p></blockquote><h3 id="支付功能"><a href="#支付功能" class="headerlink" title="支付功能"></a>支付功能</h3><p>生成二维码 -&gt; 扫描后发送支付请求 -&gt; 支付结果回调通知 -&gt; 主动查询支付结果</p><h4 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a>生成二维码</h4><p>前端访问接口，携带商品信息，服务层会先生成真正的订单记录，再添加一条支付记录，然后将支付记录的支付id和访问地址进行拼接，生成二维码图片返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建订单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> PayRecordDto <span class="title function_">createOrder</span><span class="params">(String userId, AddOrderDto addOrderDto)</span> &#123;</span><br><span class="line">    <span class="comment">//添加商品订单 订单表 订单明细表</span></span><br><span class="line">    <span class="type">XcOrders</span> <span class="variable">xcOrders</span> <span class="operator">=</span> saveXcOrders(userId, addOrderDto);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加支付记录</span></span><br><span class="line">    <span class="type">XcPayRecord</span> <span class="variable">xcPayRecord</span> <span class="operator">=</span> savePayRecord(xcOrders);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成二维码</span></span><br><span class="line">    <span class="comment">//调用接口生成二维码</span></span><br><span class="line">    <span class="type">QRCodeUtil</span> <span class="variable">qrCodeUtil</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QRCodeUtil</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">qrCode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> String.format(qrcodeurl, xcPayRecord.getPayNo());</span><br><span class="line">        qrCode = qrCodeUtil.createQRCode(url, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        XueChengPlusException.cast(<span class="string">&quot;生成二维码失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">PayRecordDto</span> <span class="variable">payRecordDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PayRecordDto</span>();</span><br><span class="line">    BeanUtils.copyProperties(xcPayRecord, payRecordDto);</span><br><span class="line">    payRecordDto.setQrcode(qrCode);</span><br><span class="line">    <span class="keyword">return</span> payRecordDto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扫描开始支付"><a href="#扫描开始支付" class="headerlink" title="扫描开始支付"></a>扫描开始支付</h4><p>上一步生成的二维码中包含了访问接口的地址，携带了订单记录的id号，这个接口主要是支付宝提供的一些代码示例，注意其中有一个支付结果回调通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;扫码下单接口&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/requestpay&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestPay</span><span class="params">(String payNo, HttpServletResponse httpResponse)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 判断订单记录是否存在</span></span><br><span class="line">    <span class="type">XcPayRecord</span> <span class="variable">payRecordByPayNo</span> <span class="operator">=</span> orderService.getPayRecordByPayNo(payNo);</span><br><span class="line">    <span class="keyword">if</span> (payRecordByPayNo == <span class="literal">null</span>)</span><br><span class="line">        XueChengPlusException.cast(<span class="string">&quot;订单记录不存在&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支付状态判断</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">status</span> <span class="operator">=</span> payRecordByPayNo.getStatus();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;601002&quot;</span>.equals(status))</span><br><span class="line">        XueChengPlusException.cast(<span class="string">&quot;订单已支付&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用支付宝接口</span></span><br><span class="line">    <span class="type">AlipayClient</span> <span class="variable">alipayClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultAlipayClient</span>(AlipayConfig.URL, APP_ID, APP_PRIVATE_KEY, AlipayConfig.FORMAT, AlipayConfig.CHARSET, ALIPAY_PUBLIC_KEY, AlipayConfig.SIGNTYPE); <span class="comment">//获得初始化的AlipayClient</span></span><br><span class="line">    <span class="type">AlipayTradeWapPayRequest</span> <span class="variable">alipayRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlipayTradeWapPayRequest</span>();<span class="comment">//创建API对应的request</span></span><br><span class="line">    <span class="comment">// alipayRequest.setReturnUrl(&quot;http://domain.com/CallBack/return_url.jsp&quot;);</span></span><br><span class="line">    alipayRequest.setNotifyUrl(<span class="string">&quot;http://125.124.119.32:63002/orders/receivenotify&quot;</span>);<span class="comment">//在公共参数中设置回跳和通知地址</span></span><br><span class="line">    alipayRequest.setBizContent(<span class="string">&quot;&#123;&quot;</span> +</span><br><span class="line">                                <span class="string">&quot; \&quot;out_trade_no\&quot;:\&quot;&quot;</span> + payRecordByPayNo.getPayNo() + <span class="string">&quot;\&quot;,&quot;</span> +</span><br><span class="line">                                <span class="string">&quot; \&quot;total_amount\&quot;:\&quot;&quot;</span> + payRecordByPayNo.getTotalPrice() + <span class="string">&quot;\&quot;,&quot;</span> +</span><br><span class="line">                                <span class="string">&quot; \&quot;subject\&quot;:\&quot;&quot;</span> + payRecordByPayNo.getOrderName() + <span class="string">&quot;\&quot;,&quot;</span> +</span><br><span class="line">                                <span class="string">&quot; \&quot;product_code\&quot;:\&quot;QUICK_WAP_PAY\&quot;&quot;</span> +</span><br><span class="line">                                <span class="string">&quot; &#125;&quot;</span>);<span class="comment">//填充业务参数</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">form</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        form = alipayClient.pageExecute(alipayRequest).getBody(); <span class="comment">//调用SDK生成表单</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (AlipayApiException e) &#123;</span><br><span class="line">        XueChengPlusException.cast(<span class="string">&quot;支付宝接口调用失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    httpResponse.setContentType(<span class="string">&quot;text/html;charset=&quot;</span> + AlipayConfig.CHARSET);</span><br><span class="line">    httpResponse.getWriter().write(form);<span class="comment">//直接将完整的表单html输出到页面</span></span><br><span class="line">    httpResponse.getWriter().flush();</span><br><span class="line">    httpResponse.getWriter().close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="支付结果回调"><a href="#支付结果回调" class="headerlink" title="支付结果回调"></a>支付结果回调</h4><p>此结果来自于支付宝的主动通知，里面包含了业务逻辑代码。</p><h4 id="主动查询支付结果"><a href="#主动查询支付结果" class="headerlink" title="主动查询支付结果"></a>主动查询支付结果</h4><p>主动调用支付宝的结果，再执行业务逻辑代码，和上一步相同。</p><h4 id="支付通知（待学习）"><a href="#支付通知（待学习）" class="headerlink" title="支付通知（待学习）"></a>支付通知（待学习）</h4><p>使用RabbitMQ（待学习）作为消息队列，将结果进行通知，订单服务将支付结果发送给学习中心服务（目的是告诉学习服务支付成功，可以进行修改购买的一些商品的支付状态成已支付，以及其他的一些逻辑代码），采用交换机方式。<br>订单服务收到第三方平台的支付结果时，在saveAliPayStatus方法中添加代码，向数据库消息表添加消息并进行发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.orders.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.messagesdk.model.po.MqMessage;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.messagesdk.service.MqMessageService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/2/23 16:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayNotifyConfig</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PAYNOTIFY_EXCHANGE_FANOUT</span> <span class="operator">=</span> <span class="string">&quot;paynotify_exchange_fanout&quot;</span>;</span><br><span class="line">    <span class="comment">//支付结果通知消息类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MESSAGE_TYPE</span> <span class="operator">=</span> <span class="string">&quot;payresult_notify&quot;</span>;</span><br><span class="line">    <span class="comment">//支付通知队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PAYNOTIFY_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;paynotify_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明交换机，且持久化</span></span><br><span class="line">    <span class="meta">@Bean(PAYNOTIFY_EXCHANGE_FANOUT)</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">paynotify_exchange_fanout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(PAYNOTIFY_EXCHANGE_FANOUT, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//支付通知队列,且持久化</span></span><br><span class="line">    <span class="meta">@Bean(PAYNOTIFY_QUEUE)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">course_publish_queue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(PAYNOTIFY_QUEUE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换机和支付通知队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding_course_publish_queue</span><span class="params">(<span class="meta">@Qualifier(PAYNOTIFY_QUEUE)</span> Queue queue, <span class="meta">@Qualifier(PAYNOTIFY_EXCHANGE_FANOUT)</span> FanoutExchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 获取RabbitTemplate</span></span><br><span class="line">        <span class="type">RabbitTemplate</span> <span class="variable">rabbitTemplate</span> <span class="operator">=</span> applicationContext.getBean(RabbitTemplate.class);</span><br><span class="line">        <span class="comment">//消息处理service</span></span><br><span class="line">        <span class="type">MqMessageService</span> <span class="variable">mqMessageService</span> <span class="operator">=</span> applicationContext.getBean(MqMessageService.class);</span><br><span class="line">        <span class="comment">// 设置ReturnCallback</span></span><br><span class="line">        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 投递失败，记录日志</span></span><br><span class="line">            log.info(<span class="string">&quot;消息发送失败，应答码&#123;&#125;，原因&#123;&#125;，交换机&#123;&#125;，路由键&#123;&#125;,消息&#123;&#125;&quot;</span>,</span><br><span class="line">                     replyCode, replyText, exchange, routingKey, message.toString());</span><br><span class="line">            <span class="type">MqMessage</span> <span class="variable">mqMessage</span> <span class="operator">=</span> JSON.parseObject(message.toString(), MqMessage.class);</span><br><span class="line">            <span class="comment">//将消息再添加到消息表</span></span><br><span class="line">            mqMessageService.addMessage(mqMessage.getMessageType(),mqMessage.getBusinessKey1(),mqMessage.getBusinessKey2(),mqMessage.getBusinessKey3());</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ES搜索服务（待学习）"><a href="#ES搜索服务（待学习）" class="headerlink" title="ES搜索服务（待学习）"></a>ES搜索服务（待学习）</h3><p>在项目中使用到的主要是将发布后的课程信息存储在ES中，确保能够进行快速的搜索功能。</p><h3 id="XXL-JOB分布式调度"><a href="#XXL-JOB分布式调度" class="headerlink" title="XXL-JOB分布式调度"></a>XXL-JOB分布式调度</h3><h4 id="分布式任务调度是什么"><a href="#分布式任务调度是什么" class="headerlink" title="分布式任务调度是什么"></a>分布式任务调度是什么</h4><p>分布式调度：分布式任务调度是指通过合理的调度算法，在分布式环境下协调执行任务的一种机制。其目的是最大程度地提高任务执行效率、保障任务的可靠性和实时性。</p><ul><li><strong>定时任务调度</strong>： 在分布式系统中，可能有大量的定时任务需要执行，如日志清理、数据备份等。</li><li><strong>实时数据处理</strong>： 处理实时产生的大量数据，如日志分析、实时报警等。</li><li><strong>批处理任务</strong>： 需要大规模并行处理的任务，如数据批量处理、大规模计算等。</li></ul><p>注意事项：</p><ul><li><strong>任务幂等性</strong>： 确保任务的幂等性，即同一个任务可以被安全地执行多次而不产生副作用。</li><li><strong>任务监控</strong>： 实时监控任务的执行情况，及时发现和解决任务执行异常。</li><li><strong>任务失败重试</strong>： 对于执行失败的任务，设计合理的重试策略，确保任务成功执行。</li><li><strong>任务日志</strong>： 记录任务的执行日志，方便排查和分析任务执行过程中的问题。</li></ul><p>Jdk也为我们提供了相关支持，如Timer、ScheduledExecutor</p><ol><li><p><strong>Timer方式实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;  </span><br><span class="line">    <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();  </span><br><span class="line">    timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">            <span class="comment">//TODO：something</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;, <span class="number">1000</span>, <span class="number">2000</span>);  <span class="comment">//1秒后开始调度，每2秒执行一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Timer 的优点在于简单易用，每个Timer对应一个线程，因此可以同时启动多个Timer并行执行多个任务，同一个Timer中的任务是串行执行</p></li><li><p><strong>ScheduledExecutor方式实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] agrs)</span>&#123;</span><br><span class="line">    <span class="type">ScheduledExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">    service.scheduleAtFixedRate(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//TODO：something</span></span><br><span class="line">                System.out.println(<span class="string">&quot;todo something&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>,</span><br><span class="line">        <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 5 推出了基于线程池设计的 ScheduledExecutor，其设计思想是，每一个被调度的任务都会由线程池中一个线程去执行，因此任务是并发执行的，相互之间不会受到干扰。<br> Timer 和 ScheduledExecutor 都仅能提供基于开始时间与重复间隔的任务调度，不能胜任更加复杂的调度需求。比如，设置每月第一天凌晨1点执行任务、复杂调度任务的管理、任务间传递数据等等。</p></li><li><p><strong>Quartz方式</strong></p></li></ol><p>Quartz 是一个功能强大的任务调度框架，它可以满足更多更复杂的调度需求，Quartz 设计的核心类包括 Scheduler, Job 以及 Trigger。其中，Job 负责定义需要执行的任务，Trigger 负责设置调度策略，Scheduler 将二者组装在一起，并触发任务开始执行。Quartz支持简单的按时间间隔调度、还支持按日历调度方式，通过设置CronTrigger表达式（包括：秒、分、时、日、月、周、年）进行任务调度。<br>XXL-JOB主要有调度中心、执行器、任务：<br><strong>调度中心：</strong><br> 负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码；<br> 主要职责为执行器管理、任务管理、监控运维、日志管理等<br><strong>任务执行器：</strong><br> 负责接收调度请求并执行任务逻辑；<br> 只要职责是注册服务、任务执行服务（接收到任务后会放入线程池中的任务队列）、执行结果上报、日志服务等<br><strong>任务：</strong>负责执行具体的业务处理。<br>调度中心与执行器之间的工作流程如下：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1722044048607-0245d54a-9cee-4358-ba48-397b310f4371.png#averageHue=%23545865&clientId=u9e1b070f-a274-4&from=paste&height=656&id=u79f85ba4&originHeight=984&originWidth=1536&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=350363&status=done&style=none&taskId=uedc0a5b1-f9ec-4287-871b-7ce651c9a56&title=&width=1024" alt="image.png"><br><strong>执行流程：</strong></p><ol><li>任务执行器根据配置的调度中心的地址，自动注册到调度中心</li><li>达到任务触发条件，调度中心下发任务</li><li>执行器基于线程池执行任务，并把执行结果放入内存队列中、把执行日志写入日志文件中</li><li>执行器消费内存队列中的执行结果，主动上报给调度中心</li><li>当用户在调度中心查看任务日志，调度中心请求任务执行器，任务执行器读取任务日志文件并返回日志详情<blockquote><p>在做好应有的配置后，我们还要知道具体流程，首先启动<code>xxl-job</code>项目，进入web页面；同时在对应的微服务中添加需要执行的代码，使用注解标识；创建执行器，进行注册（相当于一个服务）；开始调度即可</p></blockquote></li></ol><h4 id="分布式调度其它解决方案"><a href="#分布式调度其它解决方案" class="headerlink" title="分布式调度其它解决方案"></a>分布式调度其它解决方案</h4><p><strong>基于消息队列的实现</strong><br>通过消息队列实现分布式任务调度，任务发布者将任务消息发送到消息队列，任务执行者监听消息队列，获取任务消息并执行。</p><blockquote><p>基于消息队列<br>基于分布式调度框架</p></blockquote><h4 id="项目中使用的地方"><a href="#项目中使用的地方" class="headerlink" title="项目中使用的地方"></a>项目中使用的地方</h4><p>对视频业务进行合并处理（可以不讲，这个不打算放出来）<br>课程发布时，需要进行一些操作：课程页面静态化；课程索引保存在es中；课程信息保存在Redis中</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ的常见问题解决</title>
      <link href="/2024/07/20/RabbitMQ/"/>
      <url>/2024/07/20/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>RabbitMQ常见问题解决方案</strong><br>消息中间件在业务开发当中具有举足轻重的地位，很多场景&#x2F;问题下都可以依托于消息中间件来实现，所以消息中间件的很多问题也是在面试的高频点。</p></blockquote><h3 id="RabbitMQ的可靠性（消息丢失问题）"><a href="#RabbitMQ的可靠性（消息丢失问题）" class="headerlink" title="RabbitMQ的可靠性（消息丢失问题）"></a>RabbitMQ的可靠性（消息丢失问题）</h3><p><strong>消息可靠性问题举例：</strong><br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1721468060252-a80b2d79-c74c-40da-918b-3aa9b2b40da4.png#averageHue=%23f5f5f5&clientId=u1ec627d8-dbd2-4&from=paste&height=326&id=uf7ec90f0&originHeight=489&originWidth=1050&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=218850&status=done&style=none&taskId=u910eebe9-5904-4e3b-a33a-bf5200bc56a&title=&width=700" alt="image.png"><br>以创建订单为例，可能会出现这样的业务场景</p><ul><li>MQ 挂了，消息没发出去。创建订单后面几个优惠券、积分的下游系统全都没有执行业务结算怎么办？</li><li>MQ 是高可用的，消息发出去了，但是优惠券结算业务报错了怎么办？因为这个是异步的，也不好去回滚</li><li>消息正常发出去，消费者也接收到了，商户系统、优惠券系统都正常执行完了，积分业务报错了导致积分没结算，那这个订单的数据就不一致了<br>要解决上述问题，就是要保证消息一定要可靠的被消费，那么我们可以来分析下消息有哪些步骤会出问题</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1721468081466-639212a6-347a-4ebf-832b-a2d4294403e0.png#averageHue=%23e7cea2&clientId=u1ec627d8-dbd2-4&from=paste&height=136&id=u6f54a548&originHeight=204&originWidth=1018&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=158893&status=done&style=none&taskId=ud987ba50-4092-4a56-ba9a-8961bd107f9&title=&width=678.6666666666666" alt="image.png"><br>RabbitMQ出现消息可靠性问题的常见情况：</p><ul><li>生产者消息没到交换机，相当于生产者弄丢消息</li><li>交换机没有把消息路由到队列，相当于生产者弄丢消息</li><li>RabbitMQ 宕机导致队列、队列中的消息丢失，相当于 RabbitMQ 弄丢消息</li><li>消费者消费出现异常，业务没执行，相当于消费者弄丢消息</li></ul><h4 id="1-1-生产者丢失消息"><a href="#1-1-生产者丢失消息" class="headerlink" title="1.1 生产者丢失消息"></a>1.1 生产者丢失消息</h4><p>异步监听机制：<br>①成功&#x2F;未成功发送到交换机可以触发一个<code>confirm-type</code>监听<br>②交换机发送到队列会有一个<code>publisher-returns</code>监听<br>具体操作：<br>以 SpringBoot 整合 RabbitMQ 为例<br>引入依赖 starter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment">#新版本 publisher-confirms: true 已过时\</span></span><br></pre></td></tr></table></figure><p>然后编写监听回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enableConfirmCallback</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//confirm 监听，当消息成功发到交换机 ack = true，没有发送到交换机 ack = false</span></span><br><span class="line">        <span class="comment">//correlationData 可在发送时指定消息唯一 id</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(!ack)&#123;</span><br><span class="line">                <span class="comment">//记录日志、发送邮件通知、落库定时任务扫描重发</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当消息成功发送到交换机没有路由到队列触发此监听</span></span><br><span class="line">        rabbitTemplate.setReturnsCallback(returned -&gt; &#123;</span><br><span class="line">            <span class="comment">//记录日志、发送邮件通知、落库定时任务扫描重发</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试的时候可以在发送消息时故意写错交换机、路由键的名称，然后就会回调到我们刚刚写的监听方法， cause 会给我们展示具体没有发到交换机的原因；returned 对象中包含了消息相关信息。<br><strong>但是一般不这样用，成本太高丢失概率很低。一般采用日志&#x2F;邮件记录，手动维护。</strong><br>即RabbitMQ 本身丢失的可能性就非常低，其次如果这里需要落库再用定时任务扫描重发还要开发一堆代码，分布式定时任务…再其次定时任务扫描肯定会增加消息延迟，不是很有必要。真实业务场景是记录一下日志就行了，方便问题回溯，顺便发个邮件给相关人员，如果真的极其罕见的是生产者弄丢消息，那么开发往数据库补数据就行了。</p><h4 id="1-2-RabbitMQ弄丢消息"><a href="#1-2-RabbitMQ弄丢消息" class="headerlink" title="1.2 RabbitMQ弄丢消息"></a>1.2 RabbitMQ弄丢消息</h4><p>设置<strong>持久化将消息写出磁盘</strong>（重启后消息仍然存在），否则RabbitMQ重启后所有队列和消息都会丢失。<br>持久化操作：<br>持久化分为三种</p><ul><li>交换机持久化</li><li>队列持久化</li><li>消息持久化</li></ul><h5 id="1-2-1-交换机持久化"><a href="#1-2-1-交换机持久化" class="headerlink" title="1.2.1 交换机持久化"></a>1.2.1 交换机持久化</h5><p>交换机持久化描述的是当这个交换机上没有注册队列时，这个交换机是否删除。如果要打开持久化的话也很简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">testDirectExchange</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//第二个参数就是是否持久化，第三个参数就是是否自动删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;direct.Exchange&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者类上的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(</span></span><br><span class="line"><span class="meta">        bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">                value = @Queue(value = &quot;direct.Queue&quot;,autoDelete = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">                exchange = @Exchange(value = &quot;direct.Exchange&quot;, type = ExchangeTypes.DIRECT,durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">                key = &quot;direct.Rout&quot;</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure><p>@Exchange注解的durable属性设置为true(默认也是true，不设置也可以)。这样，即使这个交换机没有队列，也不会被删除</p><h5 id="1-2-2-队列持久化"><a href="#1-2-2-队列持久化" class="headerlink" title="1.2.2 队列持久化"></a>1.2.2 队列持久化</h5><p>队列持久化描述的是当这个队列没有消费者在监听时，是否进行删除。持久化做法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">txQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//第二个参数就是durable，是否持久化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;txQueue&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者类的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(</span></span><br><span class="line"><span class="meta">        bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">                value = @Queue(value = &quot;direct.Queue&quot;,autoDelete = &quot;false&quot;,durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">                exchange = @Exchange(value = &quot;direct.Exchange&quot;, type = ExchangeTypes.DIRECT,durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">                key = &quot;direct.Rout&quot;</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure><p>可以看到，@Queue注解上，加上了durable&#x3D;”true”的注解。这样队列在重启的时候就不会被删除了<br>1.2.3 消息持久化<br>消息持久化和前面两个稍微有点不同。消息持久化实际上就是基于确认机制去做的。默认情况下，只要消费者接收到这个消息，这个消息就从队列上被删除了。、<br>但考虑这样一种场景，接口层接受到一个请求，然后推送一个消息，异步地去更新数据库。此时对于消费者端来说，一拿到消息，消息就从队列上被删除，然后开始执行数据库更新，但此时数据库更新失败了，方法直接返回。但队列上已经没有这条消息了，这个更新操作不就没有完成了吗？这肯定是有问题的。<br>所以RabbitMQ就有了消费者确认机制，只有消费者手动确认，消息才会被删除，否则该消息将一直存在队列中，开启的方法很简单：<br>application.properties上加上：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.rabbitmq.listener.simple.acknowledge-mode</span>=<span class="string">manual</span></span><br><span class="line"><span class="comment"># 意为改为手动确认。</span></span><br></pre></td></tr></table></figure><p>对于消费者端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String str,Channel channel,Message message)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="literal">false</span>); <span class="comment">//手动调用</span></span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手动调用下确认即可，消息就会被删除。这一步可以放在业务逻辑的执行之后</p><h4 id="1-3-消费者弄丢消息"><a href="#1-3-消费者弄丢消息" class="headerlink" title="1.3 消费者弄丢消息"></a>1.3 消费者弄丢消息</h4><p>消费者丢数据一般是因为采用了自动确认消息模式。MQ收到确认消息后会删除消息，如果这时消费者异常了，那消息就没了。<br>即消费端执行业务代码报错，导致业务未执行，比较常见，属于业务代码异常，一定要解决。如：创建订单成功了，优惠券结算报错了，默认情况下 RabbitMQ 只要把消息推送到消费者就会认为消息已经被消费，就从队列中删除了，但是优惠券还没有结算，这样就相当于消息变相丢失了。<br>可以使用ack机制，默认情况下自动应答，可以使用手动ack，然后再删除消息。<br>具体操作：<br>首先在配置文件中开启手动 ack</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span> <span class="comment">#手动应答</span></span><br></pre></td></tr></table></figure><p>然后在消费端代码中手动应答签收消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">(String object, Message message, Channel channel)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line">    log.info(<span class="string">&quot;消费成功：&#123;&#125;,消息内容:&#123;&#125;&quot;</span>, deliveryTag, object);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 执行业务代码...</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">        channel.basicAck(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;签收失败&quot;</span>, e);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel.basicNack(deliveryTag, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException exception) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;拒签失败&quot;</span>, exception);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际场景的应用<br>但是在实际场景中，设置ack后，让消息重回队列会回到队列顶端，继续推送到服务端，通常的代码报错并不能因为重试而解决，可能会造成死循环。所以这样的场景一般有三个选择：</p><ol><li>当消费失败后将此消息存到 Redis，记录消费次数，如果消费了三次还是失败，就丢弃掉消息，记录日志落库保存</li><li>直接填 false ，不重回队列，记录日志、发送邮件等待开发手动处理</li><li>不启用手动 ack ，使用 SpringBoot 提供的消息重试</li></ol><p><strong>SpringBoot 提供的消息重试：</strong><br>其实很多场景并不是一定要启用消费者应答模式，因为 SpringBoot 给我们提供了一种重试机制，当消费者执行的业务方法报错时会重试执行消费者业务方法。<br>启用 SpringBoot 提供的重试机制</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment">#重试次数</span></span><br></pre></td></tr></table></figure><p>消费者代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">(String object, Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 执行业务代码...</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>; <span class="comment">//故意报错测试</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;签收失败&quot;</span>, e);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 记录日志、发送邮件、保存消息到数据库，落库之前判断如果消息已经落库就不保存</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;消息消费失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意一定要手动 throw 一个异常，因为 SpringBoot 触发重试是根据方法中发生未捕捉的异常来决定的</strong>。值得注意的是这个重试是 SpringBoot 提供的，重新执行消费者方法，而不是让 RabbitMQ 重新推送消息。<br><strong>小结</strong><br>其实认真研究下来你会发现所谓的消息可靠性本身就是无法保证的…所谓的各种可靠性机制只是为了以后消息丢失提供可查询的日志而已，不过通过这些机制耗费一些（巨大）成本的确是能够缩小消息丢失的可能性。</p><h3 id="重复消费问题（消息幂等性）"><a href="#重复消费问题（消息幂等性）" class="headerlink" title="重复消费问题（消息幂等性）"></a>重复消费问题（消息幂等性）</h3><p>为了防止消息在消费者端丢失，会采用手动回复MQ的方式来解决，同时也引出了一个问题，消费者处理消息成功，手动回复MQ时由于网络不稳定，连接断开，导致MQ没有收到消费者回复的消息，那么该条消息还会保存在MQ的消息队列，由于MQ的消息重发机制，会重新把该条消息发给和该队列绑定的消息者处理，这样就会导致消息重复消费。而有些操作是不允许重复消费的，比如下单，减库存，扣款等操作。</p><h4 id="2-1-生产时消息重复"><a href="#2-1-生产时消息重复" class="headerlink" title="2.1 生产时消息重复"></a>2.1 生产时消息重复</h4><p>由于生产者发送消息给MQ，在MQ确认的时候出现了网络波动，生产者没有收到确认，实际上MQ已经接收到了消息。这时候生产者就会重新发送一遍这条消息。<br>生产者中如果消息未被确认，或确认失败，我们可以使用定时任务+（redis&#x2F;db）来进行消息重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4J</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessage</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大投递次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_TRY_COUNT</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每30s拉取投递失败的消息, 重新投递</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/30 * * * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resend</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始执行定时任务(重新投递消息)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;MsgLog&gt; msgLogs = messageService.selectTimeoutMsg();</span><br><span class="line">        msgLogs.forEach(msgLog -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msgId</span> <span class="operator">=</span> msgLog.getMsgId();</span><br><span class="line">            <span class="keyword">if</span> (msgLog.getTryCount() &gt;= MAX_TRY_COUNT) &#123;</span><br><span class="line">                messageService.updateStatus(msgId, Constant.MsgLogStatus.DELIVER_FAIL);</span><br><span class="line">                log.info(<span class="string">&quot;超过最大重试次数, 消息投递失败, msgId: &#123;&#125;&quot;</span>, msgId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                messageService.updateTryCount(msgId, msgLog.getNextTryTime());<span class="comment">// 投递次数+1</span></span><br><span class="line"></span><br><span class="line">                <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(msgId);</span><br><span class="line">                rabbitTemplate.convertAndSend(msgLog.getExchange(), msgLog.getRoutingKey(), MessageHelper.objToMsg(msgLog.getMsg()), correlationData);<span class="comment">// 重新投递</span></span><br><span class="line"></span><br><span class="line">                log.info(<span class="string">&quot;第 &quot;</span> + (msgLog.getTryCount() + <span class="number">1</span>) + <span class="string">&quot; 次重新投递消息&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;定时任务执行结束(重新投递消息)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>也可以生产消息时，具备唯一ID，消费时通过消费端进行处理（参看消费重复的解决方案）。</strong></p><h4 id="2-2-消费时消息重复"><a href="#2-2-消费时消息重复" class="headerlink" title="2.2 消费时消息重复"></a>2.2 消费时消息重复</h4><p><strong>两个思路</strong>：</p><ol><li>不让消费端执行两次</li><li>让它重复消费了，但是不让其对业务数据造成影响</li></ol><h5 id="2-2-1-确保消费端只执行一次"><a href="#2-2-1-确保消费端只执行一次" class="headerlink" title="2.2.1 确保消费端只执行一次"></a>2.2.1 确保消费端只执行一次</h5><p>一般来说消息重复消费都是在短暂的一瞬间消费多次，我们可以使用 redis 将消费过的消息唯一标识存储起来，然后在消费端业务执行之前判断 redis 中是否已经存在这个标识。<br>举个例子，订单使用优惠券后，要通知优惠券系统，增加使用流水。这里可以用订单号 + 优惠券 id 做唯一标识。业务开始先判断 redis 是否已经存在这个标识，如果已经存在代表处理过了。不存在就放进 redis 设置过期时间，执行业务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;orderNo+couponId&quot;</span>);</span><br><span class="line">    <span class="comment">//先检查这条消息是不是已经消费过了</span></span><br><span class="line">    <span class="keyword">if</span> (!Boolean.TRUE.equals(flag)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行业务...</span></span><br><span class="line">    <span class="comment">//消费过的标识存储到 Redis，10 秒过期</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;orderNo+couponId&quot;</span>,<span class="string">&quot;1&quot;</span>, Duration.ofSeconds(<span class="number">10L</span>));</span><br></pre></td></tr></table></figure><p>2.2.2 允许消费端执行多次，保证数据不受影响</p><ul><li><strong>数据库唯一键约束</strong></li></ul><p>如果消费端业务是新增操作，我们可以利用数据库的唯一键约束，比如优惠券流水表的优惠券编号，如果重复消费将会插入两条相同的优惠券编号记录，数据库会给我们报错，可以保证数据库数据不会插入两条。</p><ul><li><strong>数据库乐观锁思想</strong></li></ul><p>如果消费端业务是更新操作，可以给业务表加一个 version 字段，每次更新把 version 作为条件，更新之后 version + 1。由于 MySQL 的 innoDB 是行锁，当其中一个请求成功更新之后，另一个请求才能进来，由于版本号 version 已经变成 2，必定更新的 SQL 语句影响行数为 0，不会影响数据库数据。</p><h3 id="消息消费顺序性问题"><a href="#消息消费顺序性问题" class="headerlink" title="消息消费顺序性问题"></a>消息消费顺序性问题</h3><p><strong>举例：</strong></p><ol><li>比如一个电商的下单操作，下单后先减库存然后生成订单，这个操作就需要顺序执行的 那怎么保证顺序呢？</li><li>有些业务场景会需要让消息顺序消费，比如使用 canal 订阅 MySQL 的 binary 日志来更新 Redis，通常我们会把 canal 订阅到的数据变化发送到消息队列。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1721468118414-e5bc0cfe-1f62-4039-99e7-e6867b32dc89.png#averageHue=%23c2f0b6&clientId=u1ec627d8-dbd2-4&from=paste&height=239&id=ucfafd312&originHeight=358&originWidth=866&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=227961&status=done&style=none&taskId=u54b14545-68cb-4ace-8659-5251e0a6467&title=&width=577.3333333333334" alt="image.png"><br>如果不保证 RabbitMQ 的顺序消费， Redis 中就有可能会出现脏数据。<br><strong>原因</strong>：<br>其实队列本身是有顺序的，但是生产环境服务实例一般都是集群，当消费者是多个实例时，队列中的消息会分发到所有实例进行消费（同一个消息只能发给一个消费者实例），这样就不能保证消息顺序的消费，因为你不能确保哪台机器执行消费端业务代码的速度快。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1721468134268-2fe0e3c3-cbef-4c05-9eda-cc4c552718ce.png#averageHue=%23f7f2ec&clientId=u1ec627d8-dbd2-4&from=paste&height=167&id=uc7b378f4&originHeight=250&originWidth=1104&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=150926&status=done&style=none&taskId=ue0fef00b-67ae-46ab-af07-10e1e9f33b0&title=&width=736" alt="image.png"><br>解决消费顺序问题的思路：</p><ol><li>多个消费实例并发竞争时，不能保证消费顺序，那么每次RabbitMQ只投递一个消息，待收到ack确认时再投递下一个，即可解决问题。在并发和性能要求高的情况下不适用：<ol><li>每次只有一个消费者可消费，其他消费者被阻塞，降低了消费端的性能和并发能力。</li><li>大大提高了消息积压的风险。</li></ol></li><li>根据一定的策略，多个消费者按序消费。</li></ol><h4 id="3-1-保证每次只有单个消费实例消费"><a href="#3-1-保证每次只有单个消费实例消费" class="headerlink" title="3.1 保证每次只有单个消费实例消费"></a>3.1 保证每次只有单个消费实例消费</h4><p>所以对于需要保证顺序消费的业务，我们可以只部署一个消费者实例，然后设置 RabbitMQ 每次只推送一个消息，再开启手动 ack 即可。这样 RabbitMQ 每次只会从队列推送一个消息过来，处理完成之后我们 ack 回应，再消费下一个，就能确保消息顺序性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment">#每次只推送一个消息</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure><p>这样 RabbitMQ 每次只会从队列推送一个消息过来，处理完成之后我们 ack 回应，再消费下一个，就能确保消息顺序性。<br>但是这样的操作也会降低消费者的性能，一个消费者消费消息时，其他消费者会阻塞，所以很多场景下可能并不会采用这样的方案。<br>所以一般会根据场景，制定一定的策略来解决消费顺序问题。</p><h4 id="3-2-简单队列场景"><a href="#3-2-简单队列场景" class="headerlink" title="3.2 简单队列场景"></a>3.2 简单队列场景</h4><p>当RabbitMQ采用简单队列模式的时候,如果消费者采用多线程的方式来加速消息的处理,此时也会出现消息乱序的问题。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1721468146867-8d663922-b1bd-4f99-87fa-20c68083bb66.png#averageHue=%23fbfaf9&clientId=u1ec627d8-dbd2-4&from=paste&height=276&id=uf199a87d&originHeight=414&originWidth=1234&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=60585&status=done&style=none&taskId=u9bb4f042-48c9-4251-acdb-eb9b97cc406&title=&width=822.6666666666666" alt="image.png"><br>多线程并发抢占出现消费乱序问题，将消息ID进行hash计算，将相同值放入同一个内存队列，让指定线程执行，即可解决顺序消费问题。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1721468169492-853c4d90-3a23-4bc7-aa1f-4d8c7b61f3b2.png#averageHue=%23f8f6f5&clientId=u1ec627d8-dbd2-4&from=paste&height=195&id=u7d57aac0&originHeight=293&originWidth=1210&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=63412&status=done&style=none&taskId=u1a40e755-2065-4f07-bf22-457d679200e&title=&width=806.6666666666666" alt="image.png"></p><h4 id="3-3-工作队列场景"><a href="#3-3-工作队列场景" class="headerlink" title="3.3 工作队列场景"></a>3.3 工作队列场景</h4><p>当RabbitMQ采用work Queue模式，此时只会有一个Queue但是会有多个Consumer,同时多个Consumer直接是竞争关系，此时就会出现MQ消息乱序的问题。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1721468186445-084de51b-98e1-4a45-a94b-4c359c0cce3f.png#averageHue=%23fbf6f3&clientId=u1ec627d8-dbd2-4&from=paste&height=281&id=uee5cf1b9&originHeight=421&originWidth=1077&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=62946&status=done&style=none&taskId=u05524237-a9a5-45d9-95fc-2e9e882b97b&title=&width=718" alt="image.png"><br>生产者根据商品id计算hash值，对队列取余，将相同id的操作压入同一个队列。每个队列一个消费者就不会出现乱序情况。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1721468200435-f46efa32-be27-4b8e-8116-200b6a137715.png#averageHue=%23e5be8a&clientId=u1ec627d8-dbd2-4&from=paste&height=376&id=ud56cd349&originHeight=564&originWidth=1097&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=92812&status=done&style=none&taskId=u21299453-b325-4d26-b543-49075768475&title=&width=731.3333333333334" alt="image.png"></p><h4 id="3-4小结"><a href="#3-4小结" class="headerlink" title="3.4小结"></a>3.4小结</h4><p>解决消费顺序问题，最根源的思路还是根据一定的策略，实现一个消费者按序处理一个队列中的消息。</p><h3 id="消息积压问题"><a href="#消息积压问题" class="headerlink" title="消息积压问题"></a>消息积压问题</h3><blockquote><p>所谓消息积压一般是由于消息生产的速度长时间，远远大于消费的速度时，导致大量消息在 RabbitMQ 的队列中无法消费。</p></blockquote><h4 id="4-1-消息积压的影响"><a href="#4-1-消息积压的影响" class="headerlink" title="4.1 消息积压的影响"></a>4.1 消息积压的影响</h4><ul><li>可能导致新消息无法进入队列</li><li>可能导致l旧消息无法丢失</li><li>消息等待消费的时间过长，超出了业务容忍范围。</li></ul><h4 id="4-2-产生堆积的情况"><a href="#4-2-产生堆积的情况" class="headerlink" title="4.2 产生堆积的情况"></a>4.2 产生堆积的情况</h4><ul><li>生产者突然大量发布消息</li><li>消费者消费失败</li><li>消费者出现性能瓶颈</li><li>消费者挂掉</li></ul><h4 id="4-3场景重现"><a href="#4-3场景重现" class="headerlink" title="4.3场景重现"></a>4.3场景重现</h4><ol><li>生产者发送大量消息：利用Jmeter开多线程，循环发送大量消息进入队列。</li><li>消费者消费失败：自动ack情况下，抛出异常进行模拟。</li><li>设置消费者性能瓶颈：在消费方法中设置休眠时间，模拟性能瓶颈。</li><li>关闭消费者:停掉消费者，模拟消费者挂掉。</li></ol><p>消费者端示例核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginIntegralComsumer</span> <span class="keyword">implements</span> <span class="title class_">MessageListener</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            jsonString = <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>); </span><br><span class="line">        &#125;<span class="keyword">catch</span> (UnsupportedEncodingException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">5</span>)==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//模拟发生异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;模拟处理异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//模拟耗时的处理过程</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;处理消息:&quot;</span>+jsonString);      </span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-解决办法"><a href="#4-4-解决办法" class="headerlink" title="4.4 解决办法"></a>4.4 解决办法</h4><ol><li><strong>对生产者发消息接口进行适当限流（不太推荐，影响用户体验）</strong></li><li><strong>多部署几台消费者实例（推荐）</strong></li><li><strong>适当增加 prefetch 的数量，让消费端一次多接受一些消息（推荐，可以和第二种方案一起用）</strong></li><li><strong>增加消费者的多线程处理</strong></li><li><strong>死信队列</strong></li></ol><p><strong>常见处理思路</strong></p><ol><li>拆分MQ,生产者一个MQ，消费者一个MQ，写一个程序监听生产者的MQ模拟消费速度（譬如线程休眠），然后发送到消费者的MQ，如果消息积压则只需要处理生产者的MQ的积压消息，不影响消费者MQ</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1721468218089-6d4b92eb-5993-4ad2-8a4c-2c116abd6852.png#averageHue=%23fefefc&clientId=u1ec627d8-dbd2-4&from=paste&height=239&id=u3a535fc9&originHeight=358&originWidth=1303&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=59958&status=done&style=none&taskId=u0a87d11d-5974-4ff9-a96d-d41b1079044&title=&width=868.6666666666666" alt="image.png"></p><ol start="2"><li>拆分MQ,生产者一个MQ，消费者一个MQ，写一个程序监听生产者的MQ，定义一个全局静态变量记录上一次消费的时间，如果上一次时间和当前时间只差小于消费者的处理时间，则发送到一个延迟队列（可以使用死信队列实现）发送到消费者的MQ，如果消息积压则只需要处理生产者的MQ的积压消息，不影响消费者MQ。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1721468243104-75857b95-3f91-4d7c-b00b-1af4a5c9d469.png#averageHue=%23fefefc&clientId=u1ec627d8-dbd2-4&from=paste&height=229&id=u82fa6e63&originHeight=343&originWidth=1226&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=58857&status=done&style=none&taskId=u3f1dca8a-d8ee-4ac0-8cd7-48f7a992248&title=&width=817.3333333333334" alt="image.png"></p><ol start="3"><li>使用Redis的List或ZSET做接收消息缓存，写一个程序按照消费者处理时间定时从Redis取消息发送到MQ</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1721468269059-8bd1a3a6-ba96-40d6-9f7c-f886a6fea739.png#averageHue=%23fefefd&clientId=u1ec627d8-dbd2-4&from=paste&height=247&id=u08873ada&originHeight=371&originWidth=1255&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=54199&status=done&style=none&taskId=ufcd92f8e-b363-4b0b-9c24-75440f74f40&title=&width=836.6666666666666" alt="image.png"></p><ol start="4"><li>设置消息过期时间，过期后转入死信队列，写一个程序处理死信消息（重新如队列或者即使处理或记录到数据库延后处理）</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1721468290858-1f238d04-6475-481a-98a6-b90ef88e296d.png#averageHue=%23fefdfa&clientId=u1ec627d8-dbd2-4&from=paste&height=278&id=u8fec6b62&originHeight=417&originWidth=1252&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=62466&status=done&style=none&taskId=u70406346-fff9-46d6-8daa-6507745073f&title=&width=834.6666666666666" alt="image.png"><br><strong>参考</strong></p><ul><li><a href="https://blog.csdn.net/qq_42937522/article/details/119567072">RabbitMQ常见问题解决方案——消息丢失、重复消费、消费乱序、消息积压</a>（资料来源）</li><li><a href="https://zhuanlan.zhihu.com/p/384200726">RabbitMQ 可靠性、重复消费、顺序性、消息积压解决方案</a></li><li><a href="https://zhuanlan.zhihu.com/p/169364604">《RabbitMQ》如何保证消息不被重复消费</a> （生产者造成的消息重复问题和代码实现可参考）</li><li><a href="https://zhuanlan.zhihu.com/p/139078426">RabbitMQ(堆积,丢失,有序,重复)消息</a></li><li><a href="https://zhuanlan.zhihu.com/p/110430855">面试官杠上消息队列？高可用、重复消费、丢失、顺序消息你懂吗？</a></li><li><a href="https://blog.csdn.net/scutjay/article/details/106654227">SpringBoot整合RabbitMQ之交换机,确认与通知,持久化</a></li><li><a href="https://www.cnblogs.com/townsend/p/13663544.html">RabbitMQ消息积压的几种解决思路</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xxl-job</title>
      <link href="/2024/06/13/xxl-job/"/>
      <url>/2024/06/13/xxl-job/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>在了解<code>xxl-job</code>之前，我需要先记录下有关<code>ffmpeg</code>的安装过程，可跳过<br>安装系统：CentOS 7.9，天翼云服务器<br>我们将使用 yum 从 RPM Fusion 存储库安装：</p><ol><li><p>RPM Fusion 存储库依赖于EPEL 软件存储库，如果您的系统上未启用 EPEL，请使用以下命令：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br></pre></td></tr></table></figure></li><li><p>接下来，通过安装 rpm 包启用 RPM Fusion 存储库 ：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum localinstall --nogpgcheck https://download1.rpmfusion.org/free/el/rpmfusion-free-release-7.noarch.rpm</span><br></pre></td></tr></table></figure></li><li><p>启用存储库后，安装 FFmpeg：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install ffmpeg ffmpeg-devel</span><br></pre></td></tr></table></figure></li><li><p>通过检查其版本来验证 FFmpeg 安装：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -version</span><br></pre></td></tr></table></figure><p>一切顺利，FFmpeg 已经安装在你的CentOS 7上，会出现以下结果<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1718271496652-b77fac88-c61b-4b5f-a362-b50d2ed49059.png#averageHue=%23312f2e&clientId=u60e47e14-76be-4&from=paste&height=448&id=u91bf8b5c&originHeight=672&originWidth=832&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=89867&status=done&style=none&taskId=u234d95ac-ba4c-4fd1-af0b-5e5d5e3a4f8&title=&width=554.6666666666666" alt="image.png"><br>在各个命令安装过程中，可能会出现网络不可达，这应该是国外仓库镜像的原因，不用管，继续等待即可</p></li></ol><h3 id="分布式任务调度"><a href="#分布式任务调度" class="headerlink" title="分布式任务调度"></a>分布式任务调度</h3><p>在了解<code>xxl-job</code>之前，有必要了解下什么是分布式任务调度<br>对于一批任务的执行，我们通常可以采用以下的一些方法：</p><ol><li>多线程</li></ol><p>我们可以开启一个线程，每sleep一段时间，就去检查是否已到预期执行时间。<br>以下代码简单实现了任务调度的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    </span><br><span class="line">    <span class="comment">//任务执行间隔时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">timeInterval</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">//TODO：something</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(timeInterval);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Timer方式</li></ol><p>上面的代码实现了按一定的间隔时间执行任务调度的功能。<br>Jdk也为我们提供了相关支持，如Timer、ScheduledExecutor。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;  </span><br><span class="line">    <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();  </span><br><span class="line">    timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">           <span class="comment">//TODO：something</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;, <span class="number">1000</span>, <span class="number">2000</span>);  <span class="comment">//1秒后开始调度，每2秒执行一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Timer 的优点在于简单易用，每个Timer对应一个线程，因此可以同时启动多个Timer并行执行多个任务，同一个Timer中的任务是串行执行。</p><ol start="3"><li><p>ScheduledExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] agrs)</span>&#123;</span><br><span class="line">    <span class="type">ScheduledExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">    service.scheduleAtFixedRate(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">//TODO：something</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;todo something&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">1</span>,</span><br><span class="line">            <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 5 推出了基于线程池设计的 ScheduledExecutor，其设计思想是，每一个被调度的任务都会由线程池中一个线程去执行，因此任务是并发执行的，相互之间不会受到干扰。<br>Timer 和 ScheduledExecutor 都仅能提供基于开始时间与重复间隔的任务调度，不能胜任更加复杂的调度需求。比如，设置每月第一天凌晨1点执行任务、复杂调度任务的管理、任务间传递数据等等。</p></li><li><p>Quartz方式</p></li></ol><p>Quartz 是一个功能强大的任务调度框架，它可以满足更多更复杂的调度需求，Quartz 设计的核心类包括 Scheduler, Job 以及 Trigger。其中，Job 负责定义需要执行的任务，Trigger 负责设置调度策略，Scheduler 将二者组装在一起，并触发任务开始执行。Quartz支持简单的按时间间隔调度、还支持按日历调度方式，通过设置CronTrigger表达式（包括：秒、分、时、日、月、周、年）进行任务调度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] agrs)</span> <span class="keyword">throws</span> SchedulerException &#123;</span><br><span class="line">    <span class="comment">//创建一个Scheduler</span></span><br><span class="line">    <span class="type">SchedulerFactory</span> <span class="variable">schedulerFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StdSchedulerFactory</span>();</span><br><span class="line">    <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> schedulerFactory.getScheduler();</span><br><span class="line">    <span class="comment">//创建JobDetail</span></span><br><span class="line">    <span class="type">JobBuilder</span> <span class="variable">jobDetailBuilder</span> <span class="operator">=</span> JobBuilder.newJob(MyJob.class);</span><br><span class="line">    jobDetailBuilder.withIdentity(<span class="string">&quot;jobName&quot;</span>,<span class="string">&quot;jobGroupName&quot;</span>);</span><br><span class="line">    <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> jobDetailBuilder.build();</span><br><span class="line">    <span class="comment">//创建触发的CronTrigger 支持按日历调度</span></span><br><span class="line">        <span class="type">CronTrigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">&quot;triggerName&quot;</span>, <span class="string">&quot;triggerGroupName&quot;</span>)</span><br><span class="line">                .startNow()</span><br><span class="line">                .withSchedule(CronScheduleBuilder.cronSchedule(<span class="string">&quot;0/2 * * * * ?&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    scheduler.scheduleJob(jobDetail,trigger);</span><br><span class="line">    scheduler.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJob</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;todo something&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是对于批次任务可以进行的一些处理，通过在指定时间点执行某些任务，完成任务的调度<br>而分布式调度则是对于同一种任务，我们调用多个实例进行执行，从而提高执行效率<br><strong>分布式调度要实现的目标：</strong><br>不管是任务调度程序集成在应用程序中，还是单独构建的任务调度系统，如果采用分布式调度任务的方式就相当于将任务调度程序分布式构建，这样就可以具有分布式系统的特点，并且提高任务的调度处理能力：<br>1、并行任务调度<br>并行任务调度实现靠多线程，如果有大量任务需要调度，此时光靠多线程就会有瓶颈了，因为一台计算机CPU的处理能力是有限的。<br>如果将任务调度程序分布式部署，每个结点还可以部署为集群，这样就可以让多台计算机共同去完成任务调度，我们可以将任务分割为若干个分片，由不同的实例并行执行，来提高任务调度的处理效率。<br>2、高可用<br>若某一个实例宕机，不影响其他实例来执行任务。<br>3、弹性扩容<br>当集群中增加实例就可以提高并执行任务的处理效率。<br>4、任务管理与监测<br>对系统中存在的所有定时任务进行统一的管理及监测。让开发人员及运维人员能够时刻了解任务执行情况，从而做出快速的应急处理响应。<br>5、避免任务重复执行<br>当任务调度以集群方式部署，同一个任务调度可能会执行多次，比如在上面提到的电商系统中到点发优惠券的例子，就会发放多次优惠券，对公司造成很多损失，所以我们需要控制相同的任务在多个运行实例上只执行一次。</p><h3 id="xxl-job介绍"><a href="#xxl-job介绍" class="headerlink" title="xxl-job介绍"></a>xxl-job介绍</h3><p>XXL-JOB是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。<br>官网：<a href="https://www.xuxueli.com/xxl-job/">分布式任务调度平台XXL-JOB</a><br>XXL-JOB主要有调度中心、执行器、任务：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1718277482647-5d868c02-f07e-4903-8dfb-8ba4a3433dfb.png#averageHue=%23c2d1fd&clientId=u7af45073-f659-4&from=paste&height=308&id=u9f9d4518&originHeight=462&originWidth=856&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=79866&status=done&style=none&taskId=ubd5c6410-4c8b-4c5d-aefc-68e78cf78fe&title=&width=570.6666666666666" alt="image.png"><br><strong>调度中心：</strong><br>负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码；<br>主要职责为执行器管理、任务管理、监控运维、日志管理等<br><strong>任务执行器：</strong><br>负责接收调度请求并执行任务逻辑；<br>只要职责是注册服务、任务执行服务（接收到任务后会放入线程池中的任务队列）、执行结果上报、日志服务等<br><strong>任务：</strong>负责执行具体的业务处理。<br>调度中心与执行器之间的工作流程如下：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1718277527596-80b3ae32-95d8-4886-b965-72f72b4e96b1.png#averageHue=%23545865&clientId=u7af45073-f659-4&from=paste&height=363&id=u0a8fa074&originHeight=544&originWidth=854&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=116218&status=done&style=none&taskId=u7a292f46-08cb-447e-8ab8-2ab2611b2ac&title=&width=569.3333333333334" alt="image.png"><br><strong>执行流程：</strong></p><ol><li>任务执行器根据配置的调度中心的地址，自动注册到调度中心</li><li>达到任务触发条件，调度中心下发任务</li><li>执行器基于线程池执行任务，并把执行结果放入内存队列中、把执行日志写入日志文件中</li><li>执行器消费内存队列中的执行结果，主动上报给调度中心</li><li>当用户在调度中心查看任务日志，调度中心请求任务执行器，任务执行器读取任务日志文件并返回日志详情</li></ol><h3 id="xxl-job的简单使用"><a href="#xxl-job的简单使用" class="headerlink" title="xxl-job的简单使用"></a>xxl-job的简单使用</h3><h4 id="调度中心"><a href="#调度中心" class="headerlink" title="调度中心"></a>调度中心</h4><p>首先下载XXL-JOB<br>GitHub：<a href="https://github.com/xuxueli/xxl-job">GitHub - xuxueli&#x2F;xxl-job: A distributed task scheduling framework.（分布式任务调度平台XXL-JOB）</a><br>码云：<a href="https://gitee.com/xuxueli0323/xxl-job">许雪里&#x2F;xxl-job</a><br>解压后会出现以下目录：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1718277753846-edbefcc0-f367-4a53-89b0-d4aa23d486b1.png#averageHue=%233d4143&clientId=u7af45073-f659-4&from=paste&height=336&id=u6d368667&originHeight=504&originWidth=548&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=34251&status=done&style=none&taskId=uedd2ae33-65d4-4220-83f8-78d2d5fd551&title=&width=365.3333333333333" alt="image.png"></p><ul><li>xxl-job-admin：调度中心</li><li>xxl-job-core：公共依赖</li><li>xxl-job-executor-samples：执行器Sample示例（选择合适的版本执行器，可直接使用）<ul><li>xxl-job-executor-sample-springboot：Springboot版本，通过Springboot管理执行器，推荐这种方式；</li><li>xxl-job-executor-sample-frameless：无框架版本；</li></ul></li><li>doc :文档资料，包含数据库脚本</li></ul><p>在运行项目之前，需要先创建数据库，在<code>doc</code>文件夹下有一个<code>db</code>的SQL模型，里面有需要创建的表格<br>然后在<code>xxl-job/xxl-job-admin/src/main/resources/application.properties</code>路径下的文件，修改为你的数据库连接<br>最后启动<code>xxl-job-admin</code>模块下的<code>springboot</code>项目，登录后（账号：admin，密码：123456）就能看到这个界面：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1718278163499-3a76baa6-d504-4b03-9b0e-ddc4b50609f4.png#averageHue=%23c5d0ab&clientId=u79ed345a-c056-4&from=paste&height=812&id=u929096ab&originHeight=1218&originWidth=2549&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=133644&status=done&style=none&taskId=u32412c2e-ee18-434d-baf8-d9baedda006&title=&width=1699.3333333333333" alt="image.png"></p><h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>下边配置执行器，执行器负责与调度中心通信接收调度中心发起的任务调度请求。</p><ol><li>下边进入调度中心添加执行器</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1718278237855-3e78196a-ab75-4431-9f4b-54e164f4652e.png#averageHue=%2325a467&clientId=u79ed345a-c056-4&from=paste&height=181&id=ucb87f6e6&originHeight=272&originWidth=851&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=927740&status=done&style=none&taskId=ud55160d6-cdf5-40fc-98b2-4eb43a04f51&title=&width=567.3333333333334" alt="image.png"><br>点击新增，填写执行器信息，appname是前边在nacos中配置xxl信息时指定的执行器的应用名。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1718278279149-6c534fb8-fcb7-4b23-bdd6-fc519e5b4d29.png#averageHue=%23f8f7f7&clientId=u79ed345a-c056-4&from=paste&height=400&id=u5b77862a&originHeight=600&originWidth=851&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=2046382&status=done&style=none&taskId=u98f51e4b-7c2b-4328-867c-65390cc9eeb&title=&width=567.3333333333334" alt="image.png"><br>添加成功：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1718278295775-2c32222b-7ee3-4442-8c39-06a3391b77cd.png#averageHue=%23889c8b&clientId=u79ed345a-c056-4&from=paste&height=129&id=u703bd3f7&originHeight=194&originWidth=851&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=661714&status=done&style=none&taskId=u13c66c05-462f-407a-ab8a-631fa26dd68&title=&width=567.3333333333334" alt="image.png"></p><ol start="2"><li>微服务进行执行器注册</li></ol><p>首先添加对应依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>yaml</code>配置中添加以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">xxl:</span></span><br><span class="line">  <span class="attr">job:</span></span><br><span class="line">    <span class="attr">admin:</span> </span><br><span class="line">      <span class="attr">addresses:</span> <span class="string">http://192.168.101.65:8088/xxl-job-admin</span></span><br><span class="line">    <span class="attr">executor:</span></span><br><span class="line">      <span class="attr">appname:</span> <span class="string">media-process-service</span></span><br><span class="line">      <span class="attr">address:</span> </span><br><span class="line">      <span class="attr">ip:</span> </span><br><span class="line">      <span class="attr">port:</span> <span class="number">9999</span></span><br><span class="line">      <span class="attr">logpath:</span> <span class="string">/data/applogs/xxl-job/jobhandler</span></span><br><span class="line">      <span class="attr">logretentiondays:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">accessToken:</span> <span class="string">default_token</span></span><br></pre></td></tr></table></figure><p>注意配置中的appname这是执行器的应用名，这个名字和你刚刚添加的执行器名字相同，port是执行器启动的端口，如果本地启动多个执行器注意端口不能重复</p><ol start="3"><li>配置xxl-job的执行器</li></ol><p>在你的微服务内编写配置类<br>可以从示例工程中直接拷贝，路径是<code>xxl-job/xxl-job-executor-samples/xxl-job-executor-sample-springboot/src/main/java/com/xxl/job/executor/core/config/XxlJobConfig.java</code><br>到此完成媒资管理模块service工程配置xxl-job执行器，在xxl-job调度中心添加执行器，下边准备测试执行器与调度中心是否正常通信，因为接口工程依赖了service工程，所以启动媒资管理模块的接口工程。<br>启动后观察日志，出现下边的日志表示执行器在调度中心注册成功<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1718278702978-6152506d-cff3-4539-b307-4bcdeb49e3fb.png#averageHue=%23f6f3f1&clientId=u79ed345a-c056-4&from=paste&height=21&id=u66237da6&originHeight=32&originWidth=851&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=109220&status=done&style=none&taskId=ua9340f5b-a755-49f9-a05a-fa0f5cb9a24&title=&width=567.3333333333334" alt="image.png"><br>同时观察调度中心中的执行器界面<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1718278721956-c55b1df6-1a58-40be-a60c-e894252d7d92.png#averageHue=%23abb5a9&clientId=u79ed345a-c056-4&from=paste&height=130&id=u5ab5dc75&originHeight=195&originWidth=851&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=665131&status=done&style=none&taskId=ue0813f86-f583-47fe-81d7-7a93ba103ba&title=&width=567.3333333333334" alt="image.png"></p><h4 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h4><p>下边编写任务，参考示例工程中任务类的编写方法，在路径<code>xxl-job/xxl-job-executor-samples/xxl-job-executor-sample-springboot/src/main/java/com/xxl/job/executor/service/jobhandler/SampleXxlJob.java</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.media.jobhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xxl.job.core.handler.annotation.XxlJob;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@ClassName</span>&#125; SampleJob</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Description</span>&#125; 执行器测试</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Author</span>&#125; LiuXing</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Date</span>&#125; 2024/6/13 19:41</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Version</span>&#125; 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SampleJob</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、简单任务示例（Bean模式）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@XxlJob(&quot;testJob&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJob</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始执行.....&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下边在调度中心添加任务，进入任务管理<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1718279551721-5928fc92-e085-4db2-8411-9b3108e4aacb.png#averageHue=%234da77a&clientId=u79ed345a-c056-4&from=paste&height=178&id=uc5faad3f&originHeight=267&originWidth=851&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=910674&status=done&style=none&taskId=u67dc3e99-75a0-4722-94b1-ff1b163867e&title=&width=567.3333333333334" alt="image.png"><br>点击新增，填写任务信息<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1718279565860-fc9f84aa-a061-405a-bfb2-c18630e173c2.png#averageHue=%23fafafa&clientId=u79ed345a-c056-4&from=paste&height=442&id=u4c11d8aa&originHeight=663&originWidth=851&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=2261239&status=done&style=none&taskId=u0df8aa57-a809-4d02-b79e-37e5d52a725&title=&width=567.3333333333334" alt="image.png"><br>注意红色标记处：<br>调度类型：<br>固定速度指按固定的间隔定时调度。<br>Cron，通过Cron表达式实现更丰富的定时调度策略。<br>Cron表达式是一个字符串，通过它可以定义调度策略，格式如下：<br>{秒数} {分钟} {小时} {日期} {月份} {星期} {年份(可为空)}<br>xxl-job提供图形界面去配置：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1718279579070-00631c8c-62a0-40fd-8507-523df546ce83.png#averageHue=%23f6f6f6&clientId=u79ed345a-c056-4&from=paste&height=433&id=ub897678b&originHeight=650&originWidth=851&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=2216909&status=done&style=none&taskId=u122f705a-22bf-4dc1-bd4e-f9056b9f0f6&title=&width=567.3333333333334" alt="image.png"><br>一些例子如下：<br>30 10 1 * * ?  每天1点10分30秒触发<br>0&#x2F;30 * * * * ? 每30秒触发一次</p><ul><li>0&#x2F;10 * * * ? 每10分钟触发一次<br>运行模式有BEAN和GLUE，bean模式较常用就是在项目工程中编写执行器的任务代码，GLUE是将任务代码编写在调度中心。<br>JobHandler即任务方法名，填写任务方法上边@XxlJob注解中的名称。<br>路由策略：当执行器集群部署时，调度中心向哪个执行器下发任务，这里选择第一个表示只向第一个执行器下发任务，路由策略的其它选项稍后在分片广播章节详细解释。<br>高级配置的其它配置项稍后在分片广播章节详细解释。<br>添加成功，启动任务<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1718279605149-46cef056-b6e1-47b3-980c-ab16cfd32bb2.png#averageHue=%234da57b&clientId=u79ed345a-c056-4&from=paste&height=211&id=uf80740eb&originHeight=317&originWidth=851&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=1081201&status=done&style=none&taskId=u002aa838-14f5-4b1b-b766-6113d8e20a5&title=&width=567.3333333333334" alt="image.png"><br>通过调度日志查看任务执行情况<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1718279613237-12c4a4de-df55-49fb-87ee-0af8be12b418.png#averageHue=%23b0b4ac&clientId=u79ed345a-c056-4&from=paste&height=157&id=uad221622&originHeight=236&originWidth=851&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=804960&status=done&style=none&taskId=udd660cd4-ea43-47ba-90df-a28819b0353&title=&width=567.3333333333334" alt="image.png"><br>如果要停止任务需要在调度中心操作<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1718279637951-33bdc04a-17b9-43ce-b4cd-eda46c5f3431.png#averageHue=%2349ad7e&clientId=u79ed345a-c056-4&from=paste&height=224&id=uf37a0fac&originHeight=336&originWidth=851&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=1146002&status=done&style=none&taskId=ud6dba352-ec6b-4a58-a203-7f34cba3ef9&title=&width=567.3333333333334" alt="image.png"><br>这就是一个简单的示例，其他的更高级调用参考文档</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小知识 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot解决跨域的五种方式</title>
      <link href="/2024/06/12/SpringBoot%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2024/06/12/SpringBoot%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="跨域是什么？"><a href="#跨域是什么？" class="headerlink" title="跨域是什么？"></a>跨域是什么？</h3><p>跨域就是说从一个地址到另一个地址去拉取资源，而浏览器根据同源策略，会认为这是不安全的行为导致跨域问题<br>而且相对来说跨域只会发生在前端，如果在后端通过<code>HttpClient</code>去请求的话，是不会存在跨域问题的<br>两个地址的区别从路径开始往前存在不同都可以认为是不同的地址<br>在我们通常的请求中，源地址为我们所请求网页的地址，目标地址为你需要请求其他资源所指向的地址，如果地址不同，浏览器通常会先发一个<code>Option</code>请求，确认后端是否允许跨域</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">www.jd.<span class="keyword">com</span> ---&gt; www.baidu.<span class="keyword">com</span> // 域名不同</span><br><span class="line">http:// ---&gt; https:// 协议不同</span><br><span class="line">www.jd.<span class="keyword">com</span> ---&gt; www.baidu.<span class="keyword">com</span>:<span class="number">8080</span> // 端口不同</span><br><span class="line">www.jd.<span class="keyword">com</span> ---&gt; admin.tutu.<span class="keyword">com</span> // 二级域名不同</span><br><span class="line">www.jd.<span class="keyword">com</span> ---&gt; <span class="number">39.103</span>.<span class="number">211.181</span> // IP不同</span><br></pre></td></tr></table></figure><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP是一种比较古老的解决跨域问题的方式，因此兼容性比较好<br>但是它只支持<code>GET</code>请求，并且需要前后端都写代码进行处理，耦合度比较高<br>原理解析：</p><ol><li>前端进行ajax请求时会生成一个<code>callback</code>数据，并在访问参数中进行携带传回后端</li><li>后端在参数中进行接收，并在返回时返回一个<code>JSONObject</code>对象，里面的键为前端传过来的<code>callback</code></li><li>相当于是前后端进行了一个握手<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;http://localhost:8080/media/checkFile?fileMd5=123456&quot;</span>, </span><br><span class="line">  <span class="attr">dataType</span>: <span class="string">&quot;jsonp&quot;</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(res.<span class="property">data</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;json/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JSONObject <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Integer id,String callback)</span>&#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>().fluentPut(<span class="string">&quot;callback&quot;</span>, callback).fluentPut(<span class="string">&quot;data&quot;</span>, o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>这种方式是由后端进行编写代码来实现跨域<br>主要有三种级别的设置：单个接口，指定接口，所有接口</p><h4 id="单个接口"><a href="#单个接口" class="headerlink" title="单个接口"></a>单个接口</h4><p>在某一个接口上指定<code>@CrossOrigin</code>注解，表明这个接口是允许进行跨域请求的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;json/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@CrossOrigin(&quot;http://localhost:8081&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JSONObject <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Integer id,String callback)</span>&#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>().fluentPut(<span class="string">&quot;callback&quot;</span>, callback).fluentPut(<span class="string">&quot;data&quot;</span>, o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指定接口"><a href="#指定接口" class="headerlink" title="指定接口"></a>指定接口</h4><p>通过重写<code>WebMvcConfigurer</code>的<code>addCorsMappings</code>方法，添加一些跨域请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsWebMvcConfigurer</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>) <span class="comment">// 允许跨域请求的路径</span></span><br><span class="line">        .allowedOrigins(<span class="string">&quot;*&quot;</span>) <span class="comment">// 允许跨域请求的域名</span></span><br><span class="line">        .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>) <span class="comment">// 允许跨域请求的请求方法</span></span><br><span class="line">        .allowCredentials(<span class="literal">true</span>) <span class="comment">// 允许跨域请求带有cookie</span></span><br><span class="line">        .maxAge(<span class="number">3600</span>); <span class="comment">// 预检请求的有效期</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="所有接口"><a href="#所有接口" class="headerlink" title="所有接口"></a>所有接口</h4><p>这个的话就是对所有方法进行跨域设置了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalCorsConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsFilter <span class="title function_">getCorsFilter</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        <span class="comment">//添加哪些http方法可以跨域，比如：GET,Post，（多个方法中间以逗号分隔），*号表示所有</span></span><br><span class="line">        configuration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">//添加允许哪个请求进行跨域，*表示所有,可以具体指定http://localhost:8601 表示只允许http://localhost:8601/跨域</span></span><br><span class="line">        configuration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">//所有头信息全部放行</span></span><br><span class="line">        configuration.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">//允许跨域发送cookie</span></span><br><span class="line">        configuration.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">urlBasedCorsConfigurationSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        urlBasedCorsConfigurationSource.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, configuration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsFilter</span>(urlBasedCorsConfigurationSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>事实上这个分类不是那么准确，从可配置接口路径来看，第二种方式也是可以进行全路径跨域设置的，只不过这两种实现的方式不一样，这里就不改了</p></blockquote><h3 id="nginx进行跨域"><a href="#nginx进行跨域" class="headerlink" title="nginx进行跨域"></a>nginx进行跨域</h3><p>这个应该是相对最好的跨域解决方法，前端通过修改请求路径前缀，访问相同地址的<code>nginx</code>，由<code>nginx</code>进行转发，而这个转发是不会存在问题的，以下是具体示例：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen       9002<span class="comment">;</span></span><br><span class="line">server_name  server<span class="comment">;</span></span><br><span class="line"><span class="comment"># 指定前端项目所在的位置</span></span><br><span class="line">location / &#123;</span><br><span class="line">root   完整路径<span class="comment">;</span></span><br><span class="line">index  index.html index.htm<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error_page   500 502 503 504  /50x.html<span class="comment">;</span></span><br><span class="line"><span class="attr">location</span> = /<span class="number">50</span>x.html &#123;</span><br><span class="line">root   <span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">location /api &#123;</span><br><span class="line">default_type  application/json<span class="comment">;</span></span><br><span class="line"><span class="comment">#internal;</span></span><br><span class="line">keepalive_timeout   30s<span class="comment">;</span></span><br><span class="line">keepalive_requests  1000<span class="comment">;</span></span><br><span class="line">client_max_body_size 100M<span class="comment">;</span></span><br><span class="line"><span class="comment">#支持keep-alive</span></span><br><span class="line">proxy_http_version 1.1<span class="comment">;</span></span><br><span class="line"><span class="comment">#rewrite /api(/.*) $1 break;    #路径重写</span></span><br><span class="line">proxy_pass_request_headers on<span class="comment">;</span></span><br><span class="line"><span class="comment">#more_clear_input_headers Accept-Encoding;</span></span><br><span class="line">proxy_next_upstream error timeout<span class="comment">;</span></span><br><span class="line">proxy_pass http://localhost:9000<span class="comment">;</span></span><br><span class="line"><span class="comment">#proxy_pass http://backend;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upstream backend &#123;</span><br><span class="line">server localhost:9000 <span class="attr">max_fails</span>=<span class="number">5</span> fail_timeout=<span class="number">10</span>s weight=<span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="comment">#server 127.0.0.1:8082 max_fails=5 fail_timeout=10s weight=1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nginx</code>监听9002端口，检测到路径前缀为<code>/api</code>的，即进行转发<br>不谈其他设置，转发的位置是<code>proxy_pass http://localhost:9000;</code><br>这样就能解决跨域问题</p>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo修改鼠标指针样式</title>
      <link href="/2024/06/09/%E4%BF%AE%E6%94%B9%E9%BC%A0%E6%A0%87%E6%8C%87%E9%92%88%E6%A0%B7%E5%BC%8F/"/>
      <url>/2024/06/09/%E4%BF%AE%E6%94%B9%E9%BC%A0%E6%A0%87%E6%8C%87%E9%92%88%E6%A0%B7%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>想要为博客设置自定义的可爱鼠标指针，先从网上找到鼠标指针的资源。<br>动态指针一般为ani或gif文件，静态指针为cur或ico文件。据说目前的浏览器已经不支持动态鼠标指针了，所以将找到的ani文件转为cur格式，<a href="https://jingyan.baidu.com/article/90895e0f928e7e64ec6b0be9.html">转换教程</a>。<br>在theme&#x2F;source&#x2F;css文件夹中创建自己的css文件，并在主目录下的_config.butterfly.yml文件中Inject下添加css文件路径。<br>在css文件中添加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/* 全局默认鼠标指针 */</span><br><span class="line">body,</span><br><span class="line">html &#123;</span><br><span class="line">cursor: url(<span class="string">&#x27;./mouse/xxx.cur&#x27;</span>),auto !important;</span><br><span class="line">&#125;</span><br><span class="line">/* 悬停图片时的鼠标指针 */</span><br><span class="line">img &#123; </span><br><span class="line">cursor: url(<span class="string">&#x27;./mouse/xxx.cur&#x27;</span>), auto !important;</span><br><span class="line">&#125;</span><br><span class="line">/* 悬停图片弹出窗口时的鼠标指针 */</span><br><span class="line">.fancybox__slide&#123;</span><br><span class="line">cursor: url(<span class="string">&#x27;./mouse/xxx.cur&#x27;</span>), auto !important;</span><br><span class="line">&#125;</span><br><span class="line">.carousel__slide&#123;</span><br><span class="line">cursor: url(<span class="string">&#x27;./mouse/xxx.cur&#x27;</span>), auto !important;</span><br><span class="line">&#125;</span><br><span class="line">/* 选择链接标签时的鼠标指针 */</span><br><span class="line">a:hover,#site-name:hover &#123;</span><br><span class="line">    cursor: url(<span class="string">&#x27;./mouse/xxx.cur&#x27;</span>), auto !important;</span><br><span class="line">&#125;</span><br><span class="line">/* 选择代码框展开和复制按钮时的鼠标指针 */</span><br><span class="line">.copy-button:hover,.<span class="built_in">expand</span>:hover &#123;</span><br><span class="line">    cursor: url(<span class="string">&#x27;./mouse/xxx.cur&#x27;</span>), auto !important;</span><br><span class="line">&#125;</span><br><span class="line">/* 选中输入框时的鼠标指针 */</span><br><span class="line">input:hover, textarea:hover &#123;</span><br><span class="line">    cursor: url(<span class="string">&#x27;./mouse/xxx.cur&#x27;</span>), auto;</span><br><span class="line">&#125;</span><br><span class="line">/* 悬停按钮时的鼠标指针 */</span><br><span class="line">button:hover,.scroll-down-effects:hover &#123;</span><br><span class="line">    cursor: url(<span class="string">&#x27;./mouse/xxx.cur&#x27;</span>), auto;</span><br><span class="line">&#125;</span><br><span class="line">/* 悬停页脚链接标签（例如页脚徽标）时的鼠标指针 */</span><br><span class="line"><span class="comment">#footer-wrap a:hover &#123;</span></span><br><span class="line">    cursor: url(<span class="string">&#x27;./mouse/xxx.cur&#x27;</span>), auto;</span><br><span class="line">&#125;</span><br><span class="line">/* 悬停页码时的鼠标指针 */</span><br><span class="line"><span class="comment">#pagination .page-number:hover &#123;</span></span><br><span class="line">    cursor: url(<span class="string">&#x27;./mouse/xxx.cur&#x27;</span>), auto;</span><br><span class="line">&#125;</span><br><span class="line">/* 悬停菜单栏时的鼠标指针 */</span><br><span class="line"><span class="comment">#nav .site-page:hover &#123;</span></span><br><span class="line">    cursor: url(<span class="string">&#x27;./mouse/xxx.cur&#x27;</span>), auto !important;</span><br><span class="line">&#125;</span><br><span class="line">/* 悬停滚动条的鼠标指针（只对Chrome有效） */</span><br><span class="line">::-webkit-scrollbar:hover&#123;</span><br><span class="line">cursor: url(<span class="string">&#x27;./mouse/xxx.cur&#x27;</span>), auto!important;</span><br><span class="line">&#125;</span><br><span class="line">/* 悬停评论按钮的鼠标指针（我使用的是Gitalk/Valine） */</span><br><span class="line">.switch-btn,.switch-btn:before,.gt-user-inner,.gt-ico,.gt-user-name,.gt-btn,.vbtn,svg,.at_button&#123;</span><br><span class="line">cursor: url(<span class="string">&#x27;./mouse/xxx.cur&#x27;</span>), auto !important;</span><br><span class="line">&#125;</span><br><span class="line">/* 悬停非链接文本时的鼠标指针 */</span><br><span class="line">h1,h2,h3,h4,h5,h6,#subtitle,.content,.line,.post-content p,.post-content li&#123;</span><br><span class="line">cursor: url(<span class="string">&#x27;./mouse/xxx.cur&#x27;</span>), auto;</span><br><span class="line">&#125;</span><br><span class="line">/* 悬停文章日期 */</span><br><span class="line">.post-meta-date:hover,.post-meta-date-created:hover&#123;</span><br><span class="line">cursor: url(<span class="string">&#x27;./mouse/xxx.cur&#x27;</span>), auto!important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>暂时不会修改的元素：iframe，FireFox滚动条，鼠标右击、加载时等样式。</li><li>然后命令三连，就能看到效果了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo文章加密</title>
      <link href="/2024/06/07/Hexo%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86/"/>
      <url>/2024/06/07/Hexo%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>以下文章来源于<a href="https://luochunhai.github.io/2021/09/23/frontend/hexo/hexo-encrypt/#:~:text=%E5%8F%AA%E9%9C%80%E8%A6%81%E5%9C%A8%E9%9C%80%E8%A6%81%E5%8A%A0%E5%AF%86%E7%9A%84%E6%96%87%E7%AB%A0%E4%B8%AD%EF%BC%8C%E6%B7%BB%E5%8A%A0%E8%AE%BE%E7%BD%AE%E7%9A%84%20tag%E5%80%BC%20%E5%8D%B3%E5%8F%AF%E3%80%82%20%E5%9C%A8Hexo%E4%B8%BB%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%20_config.yml%20%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%A6%82%E4%B8%8B%E9%85%8D%E7%BD%AE%EF%BC%9A,12345678910%20%23%20Securityencrypt%3A%20%23%20hexo-blog-encryptsilent%3A%20trueabstract%3A%20%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0%EF%BC%8C%E9%9C%80%E8%A6%81%E5%AF%86%E7%A0%81%E6%89%8D%E8%83%BD%E7%BB%A7%E7%BB%AD%E9%98%85%E8%AF%BB%E3%80%82">hexo 加密</a>，为防止丢失和方便查看，进行了内容的搬运</p><h6 id="插件安装-快速使用"><a href="#插件安装-快速使用" class="headerlink" title="插件安装 &amp; 快速使用"></a>插件安装 &amp; 快速使用</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-blog-encrypt <span class="comment"># 安装插件</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line"><span class="built_in">date</span>: 2021-04-13 21:18:02</span><br><span class="line">password: hello</span><br><span class="line">---</span><br><span class="line"><span class="comment"># 添加password字段</span></span><br></pre></td></tr></table></figure><h6 id="全局加密配置"><a href="#全局加密配置" class="headerlink" title="全局加密配置"></a>全局加密配置</h6><p>分别为每篇文章设置密码，虽然很灵活，但是配置或者修改起来非常麻烦。为此，可以通过设置统一配置来实现全局加密。<br>通过添加指定 tag 的方式，可以为所有需要加密的文章添加统一加密操作。只需要在需要加密的文章中，添加设置的 tag值 即可。<br>在Hexo主配置文件 _config.yml 中添加如下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Security</span></span><br><span class="line">encrypt: <span class="comment"># hexo-blog-encrypt</span></span><br><span class="line">silent: <span class="literal">true</span></span><br><span class="line">abstract: 这是一篇加密文章，需要密码才能继续阅读。</span><br><span class="line">message: 当前文章暂不对外可见，请输入密码后查看！</span><br><span class="line">tags:</span><br><span class="line">- &#123;name: private, password: hello&#125;</span><br><span class="line">wrong_pass_message: 抱歉，您输入的密码错误，请检查后重新输入。</span><br><span class="line">wrong_hash_message: 抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>其中的 tag 部分：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tags:</span><br><span class="line">- &#123;name: private, password: hello&#125;</span><br></pre></td></tr></table></figure><p>表示当在文章中指定了 private 这个 tag 后，该文章就会自动加密并使用对应的值 hello 作为密码，输入密码后才可查看。<br>相应的文章头部设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Password Test</span><br><span class="line"><span class="built_in">date</span>: 2019-12-21 11:54:07</span><br><span class="line">tags:</span><br><span class="line">- private</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>在全局加密配置下禁用某些文章的加密<br>可能有这样的情况，属于 private 标签下的某篇文章在一段时间内想要开放访问。如果在描述中加上密码提示： 当前文章密码为xxx，请输入密码后查看 ，来让用户每次查看时都要先输入密码后再查看，这样的操作又会给访客带来不便。<br>这时可以单独设置允许某篇文章不设置密码。<br>只需要在使用 加密tag 的前提下，结合 password 来实现即可。在博客文章的头部添加 password 并设置为 “” 就能取消当前文章的 Tag 加密。<br>相应的设置示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: No Password Test</span><br><span class="line"><span class="built_in">date</span>: 2019-12-21 11:54:07</span><br><span class="line">tags:</span><br><span class="line">- private</span><br><span class="line">password: <span class="string">&quot;&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><h6 id="在全局加密配置下设置非全局密码"><a href="#在全局加密配置下设置非全局密码" class="headerlink" title="在全局加密配置下设置非全局密码"></a>在全局加密配置下设置非全局密码</h6><p>在全局加密配置下，我们可以通过设置多个 加密tag 来为多篇不同类型的文章设置相同的查看密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tags:</span><br><span class="line">- &#123;name: private, password: hello&#125;</span><br><span class="line">- &#123;name: jiami, password: world&#125;</span><br><span class="line">- &#123;name: 加密, password: jiesuo&#125;</span><br></pre></td></tr></table></figure><p>那么可能有这样的场景：<br>属于 private 标签下的某篇文章想要设置成不一样的密码，防止用户恶意通过一个密码来查看同标签下的所有文章。此时，仍可以通过 password 参数来实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Password Test</span><br><span class="line"><span class="built_in">date</span>: 2019-12-21 11:54:07</span><br><span class="line">tags:</span><br><span class="line">- private</span><br><span class="line">password: <span class="string">&quot;buyiyang&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>说明：<br>该文章通过tag值 private 做了加密，按说密码应该为 hello ，但是又在信息头中设置了 password ，因为配置的优先级是 文章信息头 &gt; 按标签加密，所以最后的密码为 buyiyang 。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo创建&amp;迁移</title>
      <link href="/2024/06/07/Hexo%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%81%E7%A7%BB/"/>
      <url>/2024/06/07/Hexo%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>最近找到了实习，过几天去上班，所以也就闲下来了一些。想着我搞个博客吧，于是就开始了<br>本来是没想记录这个过程的，不过手贱把环境删除了，又得重来，正好就记录下（还好历史记录都在）<br>顺便可以为将来换服务器进行Hexo博客迁移做记录</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>我是拿云服务器进行部署的，网上通常是<code>Hexo + GitHubPage</code>，利用GitHub进行代码托管。时间仓促，就简单进行部署，博客内容使用<code>.md</code>文件编辑后添加到服务器。</p><ul><li>Nodejs：v14.17.6</li><li>Git：自己看着下</li><li>npm：一般Nodejs自带</li></ul><p>安装完成后，使用命令进行测试：<code>node -v</code>，<code>npm -v</code>，<code>git --version</code><br>GitHub：暂时用不到，跳过</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>创建好你要放博客的目录，命令行中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>但是这个会出现一些权限问题，具体自己看，可以换以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli --unsafe-perm</span><br></pre></td></tr></table></figure><p>安装成功后，以下命令进行测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -version</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1717751384100-b2efb149-6964-4fcc-bc4b-d153b727a563.png#averageHue=%232d2c2c&clientId=u5fb26f2d-df60-4&from=paste&height=427&id=uc2837c05&originHeight=641&originWidth=691&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=44943&status=done&style=none&taskId=u7f90d561-5c2d-4feb-84ef-6650d9c90a7&title=&width=460.6666666666667" alt="image.png"></p><h3 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h3><p>进入博客目录，进行初始化，网络问题，可能会有点久，耐心等待</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init <span class="comment"># 初始化hexo，如果不行在命令后面添加 --unsafe-perm</span></span><br><span class="line">npm install <span class="comment"># 安装组件</span></span><br></pre></td></tr></table></figure><p>这个相当于是从代码仓库克隆后，进行了依赖安装<br>命令介绍：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清理public文件夹</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译文件，生成public文件夹</span></span><br><span class="line">hexo g</span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行项目</span></span><br><span class="line">hexo server</span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署项目 我没用过</span></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>默认使用4000端口，也可以使用命令<code>hexo server -p port</code>进行修改</li><li>一般来说，上传文件后需要运行前三个命令进行重新编译，否则修改不生效</li></ul><p>基本上经过以上步骤就可以跑起来啦</p><h3 id="ButterFly主题"><a href="#ButterFly主题" class="headerlink" title="ButterFly主题"></a>ButterFly主题</h3><p>初始状态真的很丑，我们来改造一下<br>其中有很多帮助来源于一下两篇文章，由于在初创期间焦头烂额，大多数文章记录没有保存，走了很多弯路，现在来描述也不会很清晰，具体还是看这两篇文章吧<br><a href="https://butterfly.js.org/">Butterfly</a><br><a href="https://blog.csdn.net/mjh1667002013/article/details/129290903">【Hexo】Hexo搭建Butterfly主题并快速美化_hexo主题butterfly配置-CSDN博客</a></p><ol><li><p>我们先在hexo项目进行下载主题吧</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure></li><li><p>安装pug 和 stylus 渲染器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure></li><li><p>修改项目根目录下的_config.yml文件（称为站点配置文件），开启主题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure><p>注意点：</p></li></ol><ul><li>下载主题后将整个主题文件放在<code>themes</code>文件夹下</li><li>后面就是一些配置，推荐把主题<code>butterfly</code>文件夹下的内容_config.yml进行复制，在博客根目录下创建_config.butterfly.yml，把内容粘贴进去，这个文件的内容，重复的会覆盖其它配置文件（原文件都不要删除）</li><li>注意里面有一些<code>tag</code>，<code>categories</code>，<code>archives</code>等文件，注意这几个文件是特有的</li><li>推荐后续在这些中进行修改，效果可以看前面两个文章<blockquote><p>敲黑板：只要改配置就要进行<code>hexo generate</code>命令后进行run，否则不生效<br>主题配置需要的话可以看名片加我细嗦</p></blockquote></li></ul><h3 id="Hexo原理"><a href="#Hexo原理" class="headerlink" title="Hexo原理"></a>Hexo原理</h3><p>对于page，你需要利用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>会出现source&#x2F;categories&#x2F;index.md文件，在这个里面有一些配置<br>对于post，类似命令进行创建或者自动创建<code>.md</code>文件上传，但是需要以下参数（部分必须）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 必须 post的标题来源这里</span><br><span class="line"><span class="built_in">date</span>:</span><br><span class="line">updated:</span><br><span class="line"><span class="built_in">type</span>: </span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top_img:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aside:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">random:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>参考这个博客吧<br><a href="https://butterfly.js.org/posts/dc584b87/#Front-matter">Butterfly 安裝文檔(二) 主題頁面</a></p><h3 id="Hexo迁移"><a href="#Hexo迁移" class="headerlink" title="Hexo迁移"></a>Hexo迁移</h3><ol><li>压缩原项目后上传</li><li>准备环境</li><li>安装必要的插件</li><li>正常跑起来就可以了</li></ol>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人教程</title>
      <link href="/2024/05/20/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
      <url>/2024/05/20/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="阿里云ECS安装nacos"><a href="#阿里云ECS安装nacos" class="headerlink" title="阿里云ECS安装nacos"></a>阿里云ECS安装nacos</h2><ol><li>拉取nacos镜像</li></ol><p>docker pull nacos&#x2F;nacos-server</p><ol start="2"><li><p>创建挂载目录（可以不需要进入容器去修改配置或者查看日志）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /mydata/nacos/logs/                      <span class="comment">#新建logs目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /mydata/nacos/init.d/          </span><br><span class="line">vim /mydata/nacos/init.d/custom.properties        <span class="comment">#修改配置文件</span></span><br></pre></td></tr></table></figure></li><li><p>创建容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker  run \</span><br><span class="line">--name nacos -d \</span><br><span class="line">-p 8848:8848 \</span><br><span class="line">--privileged=<span class="literal">true</span> \</span><br><span class="line">--restart=always \</span><br><span class="line">-e JVM_XMS=256m \</span><br><span class="line">-e JVM_XMX=256m \</span><br><span class="line">-e MODE=standalone \</span><br><span class="line">-e PREFER_HOST_MODE=hostname \</span><br><span class="line">-v /mydata/nacos/logs:/home/nacos/logs \</span><br><span class="line">-v /mydata/nacos/init.d/custom.properties:/home/nacos/init.d/custom.properties \</span><br><span class="line">-v /mydata/nacos/conf:/home/nacos/conf \</span><br><span class="line">nacos/nacos-server</span><br></pre></td></tr></table></figure></li><li><p>进入：docker exec -it nacos &#x2F;bin&#x2F;bash</p></li><li><p>开启鉴权</p></li></ol><p>进入conf&#x2F;application.properties里面进行编辑，如果不成功，可以进入容器查看是否真的修改成功</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##新增两行</span></span><br><span class="line"><span class="attr">nacos.core.auth.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">nacos.core.auth.enable.userAgentAuthWhite</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##修改三行</span></span><br><span class="line"><span class="attr">nacos.core.auth.plugin.nacos.token.secret.key</span>=<span class="string">$&#123;NACOS_AUTH_TOKEN:Token&#125;</span></span><br><span class="line"><span class="attr">nacos.core.auth.server.identity.key</span>=<span class="string">$&#123;NACOS_AUTH_IDENTITY_KEY:example&#125;</span></span><br><span class="line"><span class="attr">nacos.core.auth.server.identity.value</span>=<span class="string">$&#123;NACOS_AUTH_IDENTITY_VALUE:example&#125;</span></span><br></pre></td></tr></table></figure><ol start="6"><li>鉴权之后报错</li></ol><p>具体不记得，解决步骤如下</p><ul><li>如果添加了spring-cloud-starter-alibaba-nacos-config，就需要创建bootstrap.yaml文件</li><li>检查nacos-client版本（查看config或者discovery依赖中），此次使用的nacos是2.3.2，注意匹配</li><li>给application.properties增加两句，username和password，默认nacos，然后在yaml文件加上</li><li>nacos2.x+版本需要多开放两个端口</li></ul><p><a href="https://blog.csdn.net/u013051638/article/details/135859497">docker容器启动后修改或添加端口 nacos容器 版本2.x需要额外开放9848、9849_nacos 9849端口-CSDN博客</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">http://127.0.0.1:8848</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">http://127.0.0.1:8848</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br></pre></td></tr></table></figure><h2 id="Docker关闭容器命令-docker-stop"><a href="#Docker关闭容器命令-docker-stop" class="headerlink" title="Docker关闭容器命令(docker stop)"></a>Docker关闭容器命令(docker stop)</h2><p>#关闭容器<br>docker stop 容器名称</p><h2 id="MyBatis-Plusde的逆向工程使用"><a href="#MyBatis-Plusde的逆向工程使用" class="headerlink" title="MyBatis-Plusde的逆向工程使用"></a>MyBatis-Plusde的逆向工程使用</h2><p>连接数据库，点击表格右键（安装好mabatisX插件）<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712218635886-37825ffa-c5ee-4137-bc7e-d2c163020220.png#averageHue=%23f7f6f5&clientId=uc59b83e4-0825-4&from=paste&height=382&id=u014c6184&originHeight=573&originWidth=821&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=135561&status=done&style=none&taskId=u4a6dd266-0c46-4a57-971f-0e57c8c7096&title=&width=547.3333333333334" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712218685352-f8286494-fd73-477f-b8c6-5dece00c8a3b.png#averageHue=%23f5f3f2&clientId=uc59b83e4-0825-4&from=paste&height=473&id=uae25bbfb&originHeight=710&originWidth=791&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=222858&status=done&style=none&taskId=uf267cc7e-6100-48db-b812-446d48f57bc&title=&width=527.3333333333334" alt="image.png"></p><h2 id="Redis的启动"><a href="#Redis的启动" class="headerlink" title="Redis的启动"></a>Redis的启动</h2><p>1.redis关闭<br>redis-cli -h 127.0.0.1 -p 6379 shutdown<br>redis-cli -h 127.0.0.1 -p 6379 -a password shutdown<br>如果上述方式都没有成功停止redis，则可以使用 kill -9 杀死redis进程<br>2.redis启动<br>第一种方式 默认无密码启动方式 .&#x2F;redis-server 或者 .&#x2F;redis-server –port 6380<br>如果设置密码，这种方式启动redis,调用时就会出现异常 Caused by: redis.clients.jedis.exceptions.JedisDataException: ERR Client sent AUTH, but no password is set<br>第二种 已设置访问密码启动方式 .&#x2F;redis-server ..&#x2F;redis.conf<br><a href="https://blog.csdn.net/qq_36427903/article/details/114078377">Linux下如何正确停止&#x2F;重启&#x2F;启动redis服务_linux下如何重启redis-CSDN博客</a><br>这也是机房的redis启动方式</p><h2 id="Redis添加从节点"><a href="#Redis添加从节点" class="headerlink" title="Redis添加从节点"></a>Redis添加从节点</h2><ol><li>复制一份redis.conf文件</li></ol><p>可以和原来的conf文件放一起</p><ol start="2"><li><p>修改配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span></span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line"></span><br><span class="line">dbfilename dump-6380.rdb</span><br><span class="line"></span><br><span class="line">pidfile /var/run/redis_6380.pid</span><br><span class="line"></span><br><span class="line">port 6380</span><br><span class="line"></span><br><span class="line">// 如果主节点有密码</span><br><span class="line"><span class="comment"># masterauth &lt;master-password&gt;</span></span><br><span class="line">masterauth 123456</span><br></pre></td></tr></table></figure></li><li><p>使用命令启动</p></li></ol><p>.&#x2F;redis-server ..&#x2F;redis-6380.conf<br>info replication 查看信息</p><h2 id="Redis添加哨兵"><a href="#Redis添加哨兵" class="headerlink" title="Redis添加哨兵"></a>Redis添加哨兵</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1表示一个哨兵同意即可进行故障转移</span></span><br><span class="line">sentinel monitor master 127.0.0.1 6379 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span></span><br><span class="line">sentinel auth-pass master 123456</span><br></pre></td></tr></table></figure><p>添加上述配置<br>启动：.&#x2F;redis-sentinel ..&#x2F;sentinel.conf<br>可以模仿主节点宕机，关闭主节点，等一会故障转移</p><h2 id="阿里云安装MySQL"><a href="#阿里云安装MySQL" class="headerlink" title="阿里云安装MySQL"></a>阿里云安装MySQL</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:<span class="number">5.7</span></span><br><span class="line"></span><br><span class="line">docker run -p <span class="number">3306</span>:<span class="number">3306</span> --name mysql \</span><br><span class="line">-v /mydata/mysql/log:/<span class="keyword">var</span>/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/<span class="keyword">var</span>/lib/mysql \</span><br><span class="line">-v /mydata/mysql/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">-d mysql:<span class="number">5.7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口</li><li>v &#x2F;mydata&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql：将配置文件夹挂载到主机</li><li>v &#x2F;mydata&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql：将日志文件夹挂载到主机</li><li>v &#x2F;mydata&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;：将配置文件夹挂载到主机</li><li>e MYSQL_ROOT_PASSWORD&#x3D;root：初始化 root 用户的密码</li></ul><p><strong>MYSQL配置</strong><br> vi &#x2F;mydata&#x2F;mysql&#x2F;conf&#x2F;my.cnf<br> [client]<br>default-character-set&#x3D;utf8<br>[mysql]<br>default-character-set&#x3D;utf8<br>[mysqld]<br>init_connect&#x3D;’SET collation_connection &#x3D; utf8_unicode_ci’ init_connect&#x3D;’SET NAMES utf8’<br>character-set-server&#x3D;utf8<br>collation-server&#x3D;utf8_unicode_ci<br>skip-character-set-client-handshake<br>skip-name-resolve<br><em><strong>注意：解决 MySQL 连接慢的问题</strong></em><br>在配置文件中加入如下，并重启 mysql<br>[mysqld]<br>skip-name-resolve<br>解释：<br>skip-name-resolve：跳过域名解析<br><strong>通过容器的 mysql 命令行工具连接</strong><br>docker exec -it mysql mysql -uroot -proot<br><strong>设置 root 远程访问</strong><br>grant all privileges on <em>.</em> to ‘root‘@’%’ identified by ‘root’ with grant option;<br>flush privileges;<br><strong>进入容器文件系统</strong><br>docker exec -it mysql &#x2F;bin&#x2F;bash</p><h2 id="docker安装redis"><a href="#docker安装redis" class="headerlink" title="docker安装redis"></a>docker安装redis</h2><p> docker pull redis<br>mkdir -p &#x2F;mydata&#x2F;redis&#x2F;conf</p><p>docker run -p 6379:6379 –name redis -v &#x2F;mydata&#x2F;redis&#x2F;data:&#x2F;data <br>-v &#x2F;mydata&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf <br>-d redis redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf</p><p>touch &#x2F;mydata&#x2F;redis&#x2F;conf&#x2F;redis.conf<br> docker exec -it redis redis-cli  </p><h2 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h2><p><a href="https://blog.csdn.net/Elon15/article/details/124516929">保姆级教程——将springboot项目部署到阿里云服务器（小白包会）_怎么把框架项目放到阿里云公网上-CSDN博客</a></p><h4 id="Nginx部署前端项目"><a href="#Nginx部署前端项目" class="headerlink" title="Nginx部署前端项目"></a>Nginx部署前端项目</h4><p><a href="https://blog.csdn.net/qq_44082755/article/details/138300413">docker安装nginx部署前端项目-CSDN博客</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br><span class="line"></span><br><span class="line">docker run \</span><br><span class="line">-p <span class="number">9002</span>:<span class="number">9002</span> \</span><br><span class="line">--name nginx \</span><br><span class="line">-v /mydata/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v /mydata/nginx/conf/conf.d:/etc/nginx/conf.d \</span><br><span class="line">-v /mydata/nginx/log:/<span class="keyword">var</span>/log/nginx \</span><br><span class="line">-v /mydata/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-d nginx:latest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体看链接里面，挂载目录</span></span><br></pre></td></tr></table></figure><p>把打包好的前端项目放在html目录下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">user  nginx;</span><br><span class="line">worker_processes  auto;</span><br><span class="line"></span><br><span class="line">error_log  /<span class="keyword">var</span>/log/nginx/error.log notice;</span><br><span class="line">pid        /<span class="keyword">var</span>/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    access_log  /<span class="keyword">var</span>/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d<span class="comment">/*.conf;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    server &#123;</span></span><br><span class="line"><span class="comment">        listen       9002;</span></span><br><span class="line"><span class="comment">        server_name  http://47.120.55.253/;</span></span><br><span class="line"><span class="comment">        # 指定前端项目所在的位置</span></span><br><span class="line"><span class="comment">        location / &#123;</span></span><br><span class="line"><span class="comment">            # 注意是docker容器的nginx内部路径</span></span><br><span class="line"><span class="comment">            root   /usr/share/nginx/html/hmdp;</span></span><br><span class="line"><span class="comment">            index  index.html index.htm;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        error_page   500 502 503 504  /50x.html;</span></span><br><span class="line"><span class="comment">        location = /50x.html &#123;</span></span><br><span class="line"><span class="comment">            root   html;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        location /api &#123;</span></span><br><span class="line"><span class="comment">            default_type  application/json;</span></span><br><span class="line"><span class="comment">            #internal;</span></span><br><span class="line"><span class="comment">            keepalive_timeout   30s;</span></span><br><span class="line"><span class="comment">            keepalive_requests  1000;</span></span><br><span class="line"><span class="comment">            #支持keep-alive</span></span><br><span class="line"><span class="comment">            proxy_http_version 1.1;</span></span><br><span class="line"><span class="comment">            rewrite /api(/.*) $1 break;</span></span><br><span class="line"><span class="comment">            proxy_pass_request_headers on;</span></span><br><span class="line"><span class="comment">            #more_clear_input_headers Accept-Encoding;</span></span><br><span class="line"><span class="comment">            proxy_next_upstream error timeout;</span></span><br><span class="line"><span class="comment">            proxy_pass http://127.0.0.1:8080;</span></span><br><span class="line"><span class="comment">            #proxy_pass http://backend;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    upstream backend &#123;</span></span><br><span class="line"><span class="comment">        server 127.0.0.1:8080 max_fails=5 fail_timeout=10s weight=1;</span></span><br><span class="line"><span class="comment">        #server 127.0.0.1:8082 max_fails=5 fail_timeout=10s weight=1;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="Git中将本地项目关联到远程仓库"><a href="#Git中将本地项目关联到远程仓库" class="headerlink" title="Git中将本地项目关联到远程仓库"></a>Git中将本地项目关联到远程仓库</h4><p><a href="https://blog.csdn.net/qq_45798556/article/details/114632849">如何把项目上传到Gitee（全网最细）_如何把項目上傳到自己的gitee-CSDN博客</a><br>注意会出现什么不是安全的问题，按照提示输入命令后记得重启IEDA，否则一直没用</p><h4 id="安装maven"><a href="#安装maven" class="headerlink" title="安装maven"></a>安装maven</h4><p><a href="https://blog.csdn.net/m0_52985087/article/details/136155283">Linux环境安装Maven（详细图文）_linux安装maven环境-CSDN博客</a></p><h4 id="安装portainer"><a href="#安装portainer" class="headerlink" title="安装portainer"></a>安装portainer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker pull portainer/portainer</span><br><span class="line"></span><br><span class="line">docker run -d --restart=always \</span><br><span class="line">--name portainer -p <span class="number">9000</span>:<span class="number">9000</span> \</span><br><span class="line">-v /<span class="keyword">var</span>/run/docker.sock:/<span class="keyword">var</span>/run/docker.sock portainer/portainer</span><br></pre></td></tr></table></figure><p>注意挂载目录不要乱改，可能出问题<br>连接地址：<a href="http://47.120.55.253:9000/#!/2/docker/containers">http://47.120.55.253:9000/</a></p><h4 id="后端项目部署"><a href="#后端项目部署" class="headerlink" title="后端项目部署"></a>后端项目部署</h4><p>先制作镜像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 基础镜像</span><br><span class="line">FROM openjdk:<span class="number">8</span>-jre-slim</span><br><span class="line"></span><br><span class="line"># 作者</span><br><span class="line">MAINTAINER liu</span><br><span class="line"></span><br><span class="line"># 配置</span><br><span class="line">ENV PARAMS=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"># 时区</span><br><span class="line">ENV TZ=PRC</span><br><span class="line">RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone</span><br><span class="line"></span><br><span class="line"># 添加应用</span><br><span class="line">ADD hm-backend/target/hm-dianping-<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT.jar /hm-dianping-<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT.jar</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [<span class="string">&quot;sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;java -jar $JAVA_OPTS hm-dianping-0.0.1-SNAPSHOT.jar $PARAMS&quot;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 普通镜像构建，随系统版本构建 amd/arm</span><br><span class="line">docker build -t hm-dianping:<span class="number">1.0</span> -f ./Dockerfile .</span><br></pre></td></tr></table></figure><p>启动服务，这里只有一个，也可以启动多个</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.9&#x27;</span></span><br><span class="line"><span class="comment"># 命令执行 docker-compose -f docker-compose-app.yml up -d</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">hm-dianping:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hm-dianping:1.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hm-dianping</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=PRC</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SERVER_PORT=8080</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">APP_CONFIG_API_VERSION=v1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">APP_CONFIG_CROSS_ORIGIN=*</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_USERNAME=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_PASSWORD=123456</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_URL=jdbc:mysql://47.120.55.253:3306/heima?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_DRIVER_CLASS_NAME=com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_HIKARI_POOL_NAME=Retail_HikariCP</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REDIS_SDK_CONFIG_HOST=redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REDIS_SDK_CONFIG_PORT=6379</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./log:/data/log</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line">    <span class="attr">logging:</span></span><br><span class="line">      <span class="attr">driver:</span> <span class="string">&quot;json-file&quot;</span></span><br><span class="line">      <span class="attr">options:</span></span><br><span class="line">        <span class="attr">max-size:</span> <span class="string">&quot;10m&quot;</span></span><br><span class="line">        <span class="attr">max-file:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意先下载这个东西</span></span><br><span class="line"><span class="built_in">sudo</span> curl -L https://gitee.com/fustack/docker-compose/releases/download/v2.24.1/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">docker-compose -f hm-app.yaml up -d</span><br></pre></td></tr></table></figure><p>连接数据库时出现一个bug，由于数据库使用了SSL证书，导致连接不上，记得加上?useSSL&#x3D;false&amp;</p><h2 id="构建多级缓存"><a href="#构建多级缓存" class="headerlink" title="构建多级缓存"></a>构建多级缓存</h2><ol><li>ConcurrentHashMap</li></ol><p>最简单的一种本地缓存，负责存进去，并且移除也是调用移除的，没有什么过期时间什么的</p><ol start="2"><li>Caffeine</li></ol><p>Java高性能的本地缓存库，是一种带有存储和移除策略的Map</p><ul><li><p>Cache：普通的缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">.maximumSize(<span class="number">100</span>) <span class="comment">// 最大缓存条目数</span></span><br><span class="line">.expireAfterAccess(<span class="number">30</span>, TimeUnit.MINUTES)</span><br><span class="line">.recordStats() <span class="comment">// 开启统计功能</span></span><br><span class="line">.build();</span><br></pre></td></tr></table></figure></li><li><p>LoadingCache：在Cache的基础上增加了一个load方法，key不存在时加载新值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">.maximumSize(<span class="number">100</span>) <span class="comment">// 最大缓存条目数</span></span><br><span class="line">.expireAfterAccess(<span class="number">30</span>, TimeUnit.MINUTES)</span><br><span class="line">.recordStats() <span class="comment">// 开启统计功能</span></span><br><span class="line">.build(<span class="keyword">new</span> <span class="title class_">CacheLoader</span>&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> String <span class="title function_">load</span><span class="params">(<span class="meta">@NonNull</span> String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;value&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@NonNull</span> Map&lt;<span class="meta">@NonNull</span> String, <span class="meta">@NonNull</span> String&gt; loadAll(<span class="meta">@NonNull</span> Iterable&lt;? extends <span class="meta">@NonNull</span> String&gt; keys) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> CacheLoader.<span class="built_in">super</span>.loadAll(keys);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 和Cache不同的是，调用get()方法，key不存在时，就会调用load()方法进行加载最新值</span></span><br></pre></td></tr></table></figure></li><li><p>AsyncCache：Cache的变体，可以选择使用新线程来执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AsyncCache&lt;String, String&gt; asyncCache = Caffeine.newBuilder()</span><br><span class="line">                .maximumSize(<span class="number">100</span>) <span class="comment">// 最大缓存条目数</span></span><br><span class="line">                .expireAfterAccess(<span class="number">30</span>, TimeUnit.MINUTES)</span><br><span class="line">                .recordStats() <span class="comment">// 开启统计功能</span></span><br><span class="line">                .buildAsync();</span><br></pre></td></tr></table></figure></li><li><p>AsyncLoadingCache：LoadingCache的变体，增加了一个load方法，key不存在时加载新值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AsyncCache&lt;String, String&gt; asyncCache = Caffeine.newBuilder()</span><br><span class="line">.maximumSize(<span class="number">100</span>) <span class="comment">// 最大缓存条目数</span></span><br><span class="line">.expireAfterAccess(<span class="number">30</span>, TimeUnit.MINUTES)</span><br><span class="line">.recordStats() <span class="comment">// 开启统计功能</span></span><br><span class="line">.buildAsync(<span class="keyword">new</span> <span class="title class_">CacheLoader</span>&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> String <span class="title function_">load</span><span class="params">(<span class="meta">@NonNull</span> String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;value&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@NonNull</span> Map&lt;<span class="meta">@NonNull</span> String, <span class="meta">@NonNull</span> String&gt; loadAll(<span class="meta">@NonNull</span> Iterable&lt;? extends <span class="meta">@NonNull</span> String&gt; keys) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> CacheLoader.<span class="built_in">super</span>.loadAll(keys);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>Guava</li></ol><p>Guava是Google开源的一款Java工具库，我们可以使用它的Guave Cache<br>使用 GuavaCacheManager：结合springboot注解，将这个Manager加入注解中<br>使用CacheBuilder：不理解。。。</p><ol start="4"><li>Redis</li></ol><h2 id="初始环境配置"><a href="#初始环境配置" class="headerlink" title="初始环境配置"></a>初始环境配置</h2><ol><li>创建项目</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712123255625-b5c8f5a2-0df3-4701-955b-d4901d91b438.png#averageHue=%233f4958&clientId=u25161b75-2661-4&from=paste&height=91&id=ufbc21674&originHeight=171&originWidth=1031&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=22339&status=done&style=none&taskId=uc1858fec-64a5-4c57-9b91-ba87ac33724&title=&width=549.8666666666667" alt="image.png"><br>选择新建项目，从版本控制哪里进行创建（先在远程仓库进行创建好一个仓库）</p><ol start="2"><li>创建模块</li></ol><p>new module -&gt; 选择spring脚手架 -&gt; 记得选择web和openfeign服务（微服务）</p><ol start="3"><li>仓库报错</li></ol><p>fatal: detected dubious ownership in repository at</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --add safe.directory E:/project/UC-BMS</span><br></pre></td></tr></table></figure><ol start="4"><li><p>添加文件忽略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">**/mvnw</span><br><span class="line">**/mvnw.cmd</span><br><span class="line"></span><br><span class="line">**/.mvn</span><br><span class="line">**/target/</span><br><span class="line"></span><br><span class="line">.idea</span><br><span class="line">**/.gitignore</span><br></pre></td></tr></table></figure><p>实际上可以打开git，查看那些文件是不需要进行上传的，这是部分建议</p></li><li><p>创建common项目</p></li></ol><p>应该可以创建一个正常的springboot项目，然后删除一些文件<br>引入一些包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.liu.aichat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aichat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aichat-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpcore<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.classgraph<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>classgraph<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 服务注册/发现--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  配置中心      --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2021.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里可以放一些公共类，比如返回结果类等</p><ol start="6"><li>创建gateway网关</li></ol><p>正常创建项目，导入网关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.liu.aichat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aichat-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>aichat-gateway<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>aichat-gateway<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>17<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>2020.0.0<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.liu.aichat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aichat-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2021.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="7"><li><p>基本配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3307/aichat</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">http://47.120.55.253:8848</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">aichat-chat</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br><span class="line">    <span class="attr">time-zone:</span> <span class="string">GMT+8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath*:/mapper/**/*.xml</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span>  <span class="comment"># 自增主键</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.atguigu.gulimall.product:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure></li><li><p>实现路由转发</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 81</span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 127.0.0.1:8848</span><br><span class="line">        username: nacos</span><br><span class="line">        password: nacos</span><br><span class="line">      config:</span><br><span class="line">        enabled: true</span><br><span class="line">        server-addr: http://47.120.55.253:8848</span><br><span class="line">        username: nacos</span><br><span class="line">        password: nacos</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: chat_route</span><br><span class="line">          // 需要路由到的微服务</span><br><span class="line">          uri: lb://aichat-chat</span><br><span class="line">          // 判断什么请求需要路由</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/api/chat/**</span><br><span class="line">          // 重写路径</span><br><span class="line">          filters:</span><br><span class="line">            - RewritePath=/api/(?<span class="tag">&lt;<span class="name">segment</span>&gt;</span>.*), /$\&#123;segment&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="用户微服务"><a href="#用户微服务" class="headerlink" title="用户微服务"></a>用户微服务</h2><h4 id="注册功能"><a href="#注册功能" class="headerlink" title="注册功能"></a>注册功能</h4><ol><li><p>创建了一个user用户表，保存注册信息，进行逆向工程生成</p></li><li><p>进行了一个简单的注册判断，注意加密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt;</span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MD5Util MD5Util;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerByPwd</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 1 根据用户名查询用户是否已经存在</span></span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(User::getUserName,user.getUserName());</span><br><span class="line">        <span class="type">User</span> <span class="variable">queryUser</span> <span class="operator">=</span> <span class="built_in">this</span>.baseMapper.selectOne(queryWrapper);</span><br><span class="line">        <span class="keyword">if</span> (queryUser != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//  抛出用户已存在错误，进行全局处理</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserException</span>(StatusEnum.registerStatusEnum.USER_EXISTED_ERROR);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2 不存在，进行插入操作</span></span><br><span class="line">            user.setLoginType(<span class="number">1</span>);</span><br><span class="line">            user.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            user.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            user.setPassword(MD5Util.encPwd(user.getPassword())); <span class="comment">// 密码进行密文存储</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.baseMapper.insert(user);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="comment">//  抛出注册失败异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserException</span>(StatusEnum.registerStatusEnum.INSERT_USER_ERROR);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用advice进行异常处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserExceptionHandlerAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(value = UserException.class)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">UserException</span><span class="params">(UserException userException)</span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;服务出现异常:&#123;&#125;,异常信息:&#123;&#125;&quot;</span>,userException.getClass(),userException.getMsg());</span><br><span class="line">        <span class="keyword">return</span> R.error(userException.getCode(), userException.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserException</span><span class="params">(<span class="type">int</span> code,String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserException</span><span class="params">(StatusEnum.registerStatusEnum registerStatusEnum)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.code = registerStatusEnum.getCode();</span><br><span class="line">        <span class="built_in">this</span>.msg = registerStatusEnum.getMsg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StatusEnum</span> &#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">registerStatusEnum</span>&#123;</span><br><span class="line">        USER_EXISTED_ERROR(<span class="number">410</span>,<span class="string">&quot;用户名已经存在，尝试登录试试！&quot;</span>),</span><br><span class="line">        INSERT_USER_ERROR(<span class="number">411</span>,<span class="string">&quot;建立用户信息失败，请再次注册&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> String msg;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">        registerStatusEnum(<span class="type">int</span> code, String msg)&#123;</span><br><span class="line">            <span class="built_in">this</span>.msg = msg;</span><br><span class="line">            <span class="built_in">this</span>.code = code;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>先定义好状态码，自定义异常是使用状态码的信息来定义异常类型，而不为每个异常类型定义异常类，最后使用advice进行handle自定义异常。相对来说，这样会比较通用，而且代码没有那么繁琐，但是耦合度过高 。<br>后面可以添加一个spring security 进行加密</p></blockquote></li></ol><h4 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h4><ol><li><p>查询是否符合登录条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> UserVo userVo,</span></span><br><span class="line"><span class="params">               HttpServletResponse response)</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">session</span> <span class="operator">=</span> userService.loginByUserPwd(userVo);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isNotBlank(session))&#123;</span><br><span class="line">    <span class="comment">//增加cookie，记录session</span></span><br><span class="line">    response.addCookie(SessionUtils.newCookie(UserService.SESSION_KEY,session,<span class="string">&quot;/index.html&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> R.ok(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserException</span>(StatusEnum.loginStatusEnum.WRONG_ERROR);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将session放入cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">loginByUserPwd</span><span class="params">(UserVo userVo)</span> &#123;</span><br><span class="line"><span class="comment">// 1 根据用户名查询用户是否已经存在</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">queryWrapper.eq(User::getUserName,userVo.getUsername());</span><br><span class="line"><span class="type">User</span> <span class="variable">queryUser</span> <span class="operator">=</span> <span class="built_in">this</span>.baseMapper.selectOne(queryWrapper);</span><br><span class="line"><span class="comment">// 验证用户是否存在</span></span><br><span class="line"><span class="keyword">if</span> (queryUser == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserException</span>(StatusEnum.loginStatusEnum.USER_NOT_EXISTED_ERROR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 验证密码是否相等</span></span><br><span class="line"><span class="keyword">if</span> (MD5Util.match(userVo.getPassword(), queryUser.getPassword())) &#123;</span><br><span class="line">    <span class="comment">// 登录成功 创建session</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">session</span> <span class="operator">=</span> userSessionHelper.genSession(queryUser.getId());</span><br><span class="line">    log.info(<span class="string">&quot;session:&#123;&#125;&quot;</span>,session);</span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用户密码错误</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserException</span>(StatusEnum.loginStatusEnum.PASSWORD_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>bug：在user模块进行Redis的功能调用，注册时出现template为null，主要是因为注册是在common包中，user包的启动类无法扫描到common模块，所以他的配置类也就无法生效。可以修改启动类的扫描包的范围，或者把配置类放入user模块中。</p></blockquote></li></ol><h4 id="3-退出登录"><a href="#3-退出登录" class="headerlink" title="3.退出登录"></a>3.退出登录</h4><ol><li>释放会话</li><li>移除cookie、session</li><li>重定向<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;logout&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">logout</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 获取session</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">session</span> <span class="operator">=</span> Objects.requireNonNull(SessionUtils.findCookieByName(request, UserService.SESSION_KEY)).getValue();</span><br><span class="line">    <span class="comment">// 释放会话</span></span><br><span class="line">    request.getSession().invalidate();</span><br><span class="line">    <span class="comment">// 移除cookie</span></span><br><span class="line">    response.addCookie(SessionUtils.delCookie(UserService.SESSION_KEY));</span><br><span class="line">    <span class="comment">// 删除登录信息</span></span><br><span class="line">    userService.logout(session);</span><br><span class="line">    <span class="comment">// 重定向</span></span><br><span class="line">    response.sendRedirect(<span class="string">&quot;/index.html&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> R.ok(<span class="string">&quot;退出登录成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="4-手机验证码登录"><a href="#4-手机验证码登录" class="headerlink" title="4.手机验证码登录"></a>4.手机验证码登录</h4><p><strong>Jedis操作redis</strong></p><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;spring.redis&quot;)</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConfig</span> &#123;</span><br><span class="line">    <span class="comment">// Redis连接相关参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> database;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Redis连接池配置</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.jedis.pool.max-active&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxActive;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.jedis.pool.max-idle&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxIdle;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.jedis.pool.min-idle&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> minIdle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JedisPool <span class="title function_">jedisPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        poolConfig.setMaxTotal(maxActive);</span><br><span class="line">        poolConfig.setMaxIdle(maxIdle);</span><br><span class="line">        poolConfig.setMinIdle(minIdle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig,host,port,<span class="number">2000</span>,password,database);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>参数设置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">10.166</span><span class="number">.33</span><span class="number">.175</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">jedis:</span>  <span class="comment"># jedis连接池配置</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment"># 最大连接数</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span> <span class="comment"># 最大空闲数</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment"># 最小空闲数</span></span><br><span class="line">  <span class="attr">jmx:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span><span class="comment"># 貌似会报错，不清楚是否有影响</span></span><br></pre></td></tr></table></figure><p><strong>发送验证码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取随机验证码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">random</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) (Math.random()*<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送验证码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;code&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getValidateCode</span><span class="params">(<span class="meta">@RequestBody()</span> Map&lt;String,String&gt; params,</span></span><br><span class="line"><span class="params">                              HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="comment">// 获取手机号，得到key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phoneCode</span> <span class="operator">=</span> params.get(<span class="string">&quot;phoneCode&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;code:&quot;</span> + phoneCode;</span><br><span class="line">    <span class="comment">// 得到IP地址的key，用来判断发送验证码的次数，五分钟内有效</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">ipKey</span> <span class="operator">=</span> <span class="string">&quot;protectCode:&quot;</span> + request.getRemoteAddr();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource())&#123;</span><br><span class="line">        <span class="comment">// 用来加锁访问次数超过限制的IP地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockIpKey</span> <span class="operator">=</span> <span class="string">&quot;lockIp:&quot;</span> + request.getRemoteAddr();</span><br><span class="line">        <span class="comment">// 先判断IP是不是被锁了</span></span><br><span class="line">        <span class="keyword">if</span> (jedis.exists(lockIpKey))</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;验证码发送次数过多，请1小时后再试&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (jedis.exists(ipKey))&#123;</span><br><span class="line">            <span class="comment">// IP存在，说明已经发过验证码，做加1操作</span></span><br><span class="line">            jedis.incr(ipKey);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 第一次发验证码, 将ip加入缓存</span></span><br><span class="line">            jedis.setex(ipKey,<span class="number">300L</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Integer.parseInt(jedis.get(ipKey)) &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="comment">// 超过三次，锁IP</span></span><br><span class="line">            jedis.setex(lockIpKey,<span class="number">60</span>*<span class="number">60L</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否发送过验证码或者验证码是否过期</span></span><br><span class="line">        <span class="keyword">if</span> (jedis.exists(key))</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;验证码已发送,有效时间剩余&quot;</span> + jedis.ttl(key) + <span class="string">&quot;秒&quot;</span>;</span><br><span class="line">        <span class="comment">// 随机生成四位验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">validateCode</span> <span class="operator">=</span> String.valueOf(random());</span><br><span class="line">        <span class="comment">// 利用阿里云短信服务发送短信</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">smsResponse</span> <span class="operator">=</span> sendMsgHelper.sendSms(phoneCode, validateCode);</span><br><span class="line">        log.info(smsResponse);<span class="comment">// 打印返回码</span></span><br><span class="line">        <span class="comment">// 保存验证码 过期时间60秒</span></span><br><span class="line">        jedis.setex(key,<span class="number">60L</span>, validate);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;验证码:&quot;</span> + validateCode;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;发送失败，再试试吧&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>短信服务</strong><br>注意，需要给子账户添加短信权限</p></li><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    短信服务的依赖    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dysmsapi20170525<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tea-openapi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tea-console<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>darabonba-env<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tea-util<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>darabonba-time<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>darabonba-string<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tea<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>[1.0.3, 2.0.0)<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">alicloud:</span></span><br><span class="line">  <span class="attr">accessKeyId:</span> <span class="string">LTAI5tD8J4xX2RUGNLzSqy4L</span><span class="comment"># 子账户ID</span></span><br><span class="line">  <span class="attr">accessKeySecret:</span> <span class="string">36ApHRwIYJCKqBUSsYixp43q5Hmlbz</span><span class="comment"># 子账户密码</span></span><br><span class="line">  <span class="attr">signName:</span> <span class="string">阿里云短信测试</span><span class="comment"># 短信签名</span></span><br><span class="line">  <span class="attr">templateCode:</span> <span class="string">SMS_154950909</span><span class="comment"># 短信模板</span></span><br></pre></td></tr></table></figure></li><li><p>使用代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMsgHelper</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;alicloud.accessKeyId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;alicloud.accessKeySecret&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;alicloud.signName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String signName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;alicloud.templateCode&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String templateCode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Client <span class="title function_">createClient</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>()</span><br><span class="line">        .setAccessKeyId(accessKeyId)</span><br><span class="line">        .setAccessKeySecret(accessKeySecret);</span><br><span class="line">        <span class="comment">// Endpoint 请参考 https://api.aliyun.com/product/Dysmsapi</span></span><br><span class="line">        config.endpoint = <span class="string">&quot;dysmsapi.aliyuncs.com&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Client</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用阿里云发送短信</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phoneNumber 手机号码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code  验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  请求返回的状态码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 出现的异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendSms</span><span class="params">(String phoneNumber,String code)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SendSmsRequest</span> <span class="variable">sendSmsRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SendSmsRequest</span>()</span><br><span class="line">        .setSignName(signName)</span><br><span class="line">        .setTemplateCode(templateCode)</span><br><span class="line">        .setPhoneNumbers(phoneNumber)</span><br><span class="line">        .setTemplateParam(<span class="string">&quot;&#123;\&quot;code\&quot;:\&quot;&quot;</span>+ code + <span class="string">&quot;\&quot;&#125;&quot;</span>);</span><br><span class="line">        <span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> createClient();</span><br><span class="line">        com.aliyun.teautil.models.<span class="type">RuntimeOptions</span> <span class="variable">runtime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.aliyun.teautil.models.RuntimeOptions();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 复制代码运行请自行打印 API 的返回值</span></span><br><span class="line">            <span class="type">SendSmsResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.sendSmsWithOptions(sendSmsRequest, runtime);</span><br><span class="line">            <span class="type">SendSmsResponseBody</span> <span class="variable">body</span> <span class="operator">=</span> response.getBody();</span><br><span class="line">            <span class="keyword">return</span> body.getCode();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TeaException error) &#123;</span><br><span class="line">            <span class="comment">// 错误 message</span></span><br><span class="line">            log.error(<span class="string">&quot;错误 message:&quot;</span> + error.getMessage());</span><br><span class="line">            <span class="comment">// 诊断地址</span></span><br><span class="line">            log.error(<span class="string">&quot;诊断地址:&quot;</span> + error.getData().get(<span class="string">&quot;Recommend&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> Common.assertAsString(error.message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception _error) &#123;</span><br><span class="line">            <span class="type">TeaException</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeaException</span>(_error.getMessage(), _error);</span><br><span class="line">            <span class="comment">// 此处仅做打印展示，请谨慎对待异常处理，在工程项目中切勿直接忽略异常。</span></span><br><span class="line">            <span class="comment">// 错误 message</span></span><br><span class="line">            log.error(<span class="string">&quot;错误 message:&quot;</span> + error.getMessage());</span><br><span class="line">            <span class="comment">// 诊断地址</span></span><br><span class="line">            log.error(<span class="string">&quot;诊断地址:&quot;</span> + error.getData().get(<span class="string">&quot;Recommend&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> Common.assertAsString(error.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>验证验证码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证验证码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;validateCode&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">validateCode</span><span class="params">(<span class="meta">@RequestBody</span> Map&lt;String,String&gt; params)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">phoneCode</span> <span class="operator">=</span> params.get(<span class="string">&quot;phoneCode&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> params.get(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource())&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;code:&quot;</span> + phoneCode;</span><br><span class="line">        <span class="comment">// 判断是否过期以及验证码正确与否</span></span><br><span class="line">        <span class="keyword">if</span> (jedis.exists(key))&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">codeNum</span> <span class="operator">=</span> jedis.get(key);</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(code,codeNum))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;验证成功！&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;验证码错误。&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;验证码已过期，请重新发送。&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>TODO: 验证码通过后，需要查询是否已经注册，没有的话就直接注册</em><br>session、cookie、token<br><em>session是用于保存会话信息，通常放在服务器，服务器将sessionID放在cookie中返回给客户端，客户端每次访问请求携带sessionID</em><br><em>session的弊端</em></p></li></ol><ul><li><em>服务器压力增大</em></li></ul><p><em>通常session是存储在内存中的，每个用户通过认证之后都会将session数据保存在服务器的内存中，而当用户量增大时，服务器的压力增大。</em></p><ul><li><em>CSRF跨站伪造请求攻击</em></li></ul><p><em>一般session是基于cookie进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。即使不用cookie，用重写url方式发送sessionId，那就更容易被截获信息了</em></p><ul><li><em>扩展性不强</em></li></ul><p><em>想象这么一个场景，若项目在多个服务器上部署，那我再其中一台登录了，称为A，session也保存到A中，万一下次我访问到另外一台服务器B怎么办？B上没有A的session呢？为了解决这个问题，我们需要将session保存到数据库中，所以每次保存这些session信息就是一个负担了，增加了服务器的存储压力</em><br>_token_是服务端生成的一串加密字符串（服务器端并不进行保存），作为客户端进行请求的一个标识。当用户第一次登录后，服务器生成一个token并将此token返回给客户端浏览器，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。解决了项目在多个服务器部署登录的问题<br>session与token的总结</p><ul><li>token 是无状态的，后端不需要记录信息，每次请求过来进行解密就能得到对应信息。</li><li>session 是有状态的，需要后端每次去检索id的有效性。不同的session都需要进行保存，但也可以设置单点登录，减少保存的数据。</li><li>session与token的选择是空间与时间博弈，为什么这么说呢，是因为token不需要保存，不占存储空间，但每次访问都需要进行解密，消耗了一定的时间。</li><li>在一般的前后端分离项目中，token展现出了它的优势，成为了比session更好的选择</li></ul><p><em>JWT就是token，包含三部分</em><br><em>Header</em><br>_  Header中保存了令牌类型type和所使用的的加密算法，例如：_</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  &#x27;typ&#x27;<span class="punctuation">:</span> &#x27;JWT&#x27;<span class="punctuation">,</span></span><br><span class="line">  &#x27;alg&#x27;<span class="punctuation">:</span> &#x27;HS256&#x27;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><em>Payload</em><br>_  Payload中包含的是请求体和其它一些数据，例如包含了和用户相关的一些信息_</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><em>Signature</em><br>_  Signature签名属于jwt的第三部分。主要是把头部的base64UrlEncode与负载的base64UrlEncode拼接起来，再进行HMACSHA256加密等最终得到的结果作为签名部分。例如：_</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把header和payload拼接起来，用秘钥进行签名</span></span><br><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="keyword">var</span> encodedString = <span class="title function_">base64UrlEncode</span>(header) + <span class="string">&#x27;.&#x27;</span> + <span class="title function_">base64UrlEncode</span>(payload);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> signature = <span class="title class_">HMACSHA256</span>(encodedString, <span class="string">&#x27;secret&#x27;</span>); <span class="comment">// TJVA95OrM7E2cBab30RMHrHDcEfxjo</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;aichat.jwt&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JwtProperties</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 发布者</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String issuer;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 秘钥</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String secret;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 过期时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Long expire;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtProperties jwtProperties;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Algorithm algorithm;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> JWTVerifier verifier;</span><br><span class="line">    UserSessionHelper(JwtProperties jwtProperties)&#123;</span><br><span class="line">        <span class="built_in">this</span>.jwtProperties = jwtProperties;</span><br><span class="line">        <span class="built_in">this</span>.algorithm = Algorithm.HMAC256(jwtProperties.getSecret());</span><br><span class="line">        <span class="built_in">this</span>.verifier = JWT.require(algorithm).withIssuer(jwtProperties.getIssuer()).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成jwt会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">genSession</span><span class="params">(Long userId)</span>&#123;</span><br><span class="line">        <span class="comment">// 生成jwt格式的会话，内部持有有效期，用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">session</span> <span class="operator">=</span> JsonUtil.toStr(MapUtils.create(<span class="string">&quot;u&quot;</span>, userId + <span class="string">&quot;&quot;</span>));</span><br><span class="line">        <span class="comment">// TODO 过期时间设置会变化，导致登录时可以存入多个key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JWT.create().withIssuer(jwtProperties.getIssuer()).withExpiresAt(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + jwtProperties.getExpire()))</span><br><span class="line">                .withPayload(session)</span><br><span class="line">                .sign(algorithm);</span><br><span class="line">        <span class="comment">// 设置token为key，id为value，加上过期时间，做到服务端也可以主动失效某个key</span></span><br><span class="line">        RedisClient.setStrWithExpire(token, String.valueOf(userId),jwtProperties.getExpire() / <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><em>登录流程</em><br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713001518818-54cca9e0-de75-4446-a24b-bbe4bea769f6.png#averageHue=%23f6f6f6&clientId=u5a261cd6-999f-4&from=paste&height=457&id=u290dc3a9&originHeight=856&originWidth=810&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=135250&status=done&style=none&taskId=u3f22d1ea-f8f0-4753-88f5-16703dcab2e&title=&width=432" alt="image.png"></p><h2 id="gateway微服务"><a href="#gateway微服务" class="headerlink" title="gateway微服务"></a>gateway微服务</h2><h3 id="全局登录校验"><a href="#全局登录校验" class="headerlink" title="全局登录校验"></a>全局登录校验</h3><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><blockquote><p>网关校验，接收session，异步调用 -&gt; feign调用user模块验证，返回验证结果 -&gt; 判断是否放行</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ValidationFeign validationFeign;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> request.getURI().getPath();</span><br><span class="line">        <span class="comment">// 判断是否静态资源</span></span><br><span class="line">        <span class="keyword">if</span> (url.contains(<span class="string">&quot;login&quot;</span>) || url.contains(<span class="string">&quot;logout&quot;</span>) || isStaticURI(url))&#123;</span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取session</span></span><br><span class="line">            MultiValueMap&lt;String, HttpCookie&gt; cookies = request.getCookies();</span><br><span class="line">            <span class="type">String</span> <span class="variable">session</span> <span class="operator">=</span> Objects.requireNonNull(cookies.getFirst(SessionConstant.SESSION_KEY.getMsg())).getValue();</span><br><span class="line">            <span class="comment">// 调用feign接口完成校验</span></span><br><span class="line">            <span class="comment">// WebFlux异步调用，同步会报错</span></span><br><span class="line">            <span class="type">Future</span> <span class="variable">future</span> <span class="operator">=</span> executorService.submit((Callable&lt;R&gt;) () -&gt; validationFeign.validation(session));</span><br><span class="line">            <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                r = (R) future.get();</span><br><span class="line">                <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) r.get(<span class="string">&quot;result&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;NOT_LOGIN&quot;</span>.equalsIgnoreCase(result))&#123;</span><br><span class="line">                    <span class="comment">// 校验未通过</span></span><br><span class="line">                    exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">                    <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isStaticURI</span><span class="params">(String url)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  url.endsWith(<span class="string">&quot;css&quot;</span>)</span><br><span class="line">        || url.endsWith(<span class="string">&quot;js&quot;</span>)</span><br><span class="line">        || url.endsWith(<span class="string">&quot;png&quot;</span>)</span><br><span class="line">        || url.endsWith(<span class="string">&quot;ico&quot;</span>)</span><br><span class="line">        || url.endsWith(<span class="string">&quot;svg&quot;</span>)</span><br><span class="line">        || url.endsWith(<span class="string">&quot;min.js.map&quot;</span>)</span><br><span class="line">        || url.endsWith(<span class="string">&quot;min.css.map&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;aichat-user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ValidationFeign</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行校验session是否合法，登录与否</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user/validation&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">validation</span><span class="params">(<span class="meta">@RequestParam(&quot;session&quot;)</span>String session)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;validation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">validation</span><span class="params">(<span class="meta">@RequestParam(&quot;session&quot;)</span>String session)</span>&#123;</span><br><span class="line">    String result;</span><br><span class="line">    <span class="keyword">if</span> (session == <span class="literal">null</span> || StringUtils.isBlank(session) || userSessionHelper.getUserIdBySession(session) == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// session为空，未登录</span></span><br><span class="line">        result = <span class="string">&quot;NOT_LOGIN&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="string">&quot;LOGIN&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R.ok().put(<span class="string">&quot;result&quot;</span>,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="网关过滤器选择"><a href="#网关过滤器选择" class="headerlink" title="网关过滤器选择"></a>网关过滤器选择</h4><p>我们可以通过实现 GatewayFilter 或 GlobalFilter 过滤器接口，前端请求通过gateway时，将过滤校验jwt的合法性，这里实现GlobalFilter 接口。<br>前者需要指定在那个位置使用；后者则对于所有请求都生效<br>所以我们需要的是GlobalFilter<br><a href="https://blog.csdn.net/a1036645146/article/details/109546416">【项目实战】Spring Cloud Gateway 实现JWT &#x2F; Token登录认证流程_springcloud gatwey jwt-CSDN博客</a></p><h4 id="远程调用参数传递方法"><a href="#远程调用参数传递方法" class="headerlink" title="远程调用参数传递方法"></a>远程调用参数传递方法</h4><p>@RequestParam<br>@PathVariable<br>@RequestBody<br><a href="https://blog.csdn.net/weixin_42794008/article/details/106881431">Springcloud中Feign传递参数（总结）_feign传递多个参数-CSDN博客</a></p><h4 id="WebFlux异步调用异常"><a href="#WebFlux异步调用异常" class="headerlink" title="WebFlux异步调用异常"></a>WebFlux异步调用异常</h4><p>在geteway调用远程服务时，报错：<br>java.lang.IllegalStateException: block()&#x2F;blockFirst()&#x2F;blockLast() are blocking, which is not supported in thread reactor-http-nio-3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Decoder <span class="title function_">decoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntityDecoder</span>(<span class="keyword">new</span> <span class="title class_">SpringDecoder</span>(feignHttpMessageConverter()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ObjectFactory&lt;HttpMessageConverters&gt; <span class="title function_">feignHttpMessageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">        HttpMessageConverters httpMessageConverters=<span class="keyword">new</span> <span class="title class_">HttpMessageConverters</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>());</span><br><span class="line">        <span class="keyword">return</span> ()-&gt;httpMessageConverters;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>远程调用看上面代码<br><a href="https://blog.csdn.net/qq_33811736/article/details/115865879">Spring Cloud Gateway 调用Feign异步问题_springcloud gateway feign调用-CSDN博客</a></p><h4 id="类型转换异常"><a href="#类型转换异常" class="headerlink" title="类型转换异常"></a>类型转换异常</h4><p>class java.lang.Integer cannot be cast to class java.lang.String (java.lang.Integer and java.lang.String are in module java.base of loader ‘bootstrap’)<br>String userId &#x3D; (String) JsonUtil.toObj(s, HashMap.class).get(“u”);<br>这里报错，修改保存为String类型<br>String session &#x3D; JsonUtil.toStr(MapUtils.create(“u”, userId + “”));</p><h4 id="RedisTemplate异常"><a href="#RedisTemplate异常" class="headerlink" title="RedisTemplate异常"></a>RedisTemplate异常</h4><p>将Redis操作工具类放在common包下时，无法注入RedisTemplate的Bean实例<br>springboot的启动类，扫描范围为本服务下的包，所以common包的配置不生效<br>@SpringBootApplication(scanBasePackages &#x3D; “com.liu”)<br>增大启动类的扫描范围，或者把Redis的注册配置放在本服务下</p><h2 id="多环境开发配置文件"><a href="#多环境开发配置文件" class="headerlink" title="多环境开发配置文件"></a>多环境开发配置文件</h2><h4 id="单配置文件、多环境（共享配置文件）"><a href="#单配置文件、多环境（共享配置文件）" class="headerlink" title="单配置文件、多环境（共享配置文件）"></a>单配置文件、多环境（共享配置文件）</h4><ul><li>配置文件中，使用—分隔不同的环境，从而实现多环境</li><li>划分出一块环境，作为设置公共配置的应用环境，在当中指定应用哪个环境中的属性配置。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里是公共配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置应用哪个环境(这里应用dev环境)</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment"># 假设这是生产环境</span></span><br><span class="line"><span class="comment"># 过时格式设置环境</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">pro</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体参数设置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment"># 假设这是开发环境</span></span><br><span class="line"><span class="comment"># 标准格式设置环境</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体参数设置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">81</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment"># 假设这是测试环境</span></span><br><span class="line"><span class="comment"># 推荐使用此格式（标准格式）</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体参数设置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">82</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="多配置文件、多环境（独立配置文件）"><a href="#多配置文件、多环境（独立配置文件）" class="headerlink" title="多配置文件、多环境（独立配置文件）"></a>多配置文件、多环境（独立配置文件）</h4><ul><li>主配置文件中设置<strong>公共配置</strong> —— 全局 </li><li>环境分类配置文件中常用于<strong>配置冲突属性</strong> —— 局部</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712413340696-4108c8de-5d7d-4058-814e-d4240c8215f3.png#averageHue=%23394146&clientId=u9ddb2001-9d64-4&from=paste&height=332&id=u47421f9f&originHeight=448&originWidth=633&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=63321&status=done&style=none&taskId=uf4b5386f-2b27-4b0c-9f69-363b9a34fd3&title=&width=468.88892201239423" alt="image.png"></p><ol><li>主启动配置文件application.yml：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置应用哪个环境(这里应用dev环境)</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>使用include属性在激活指定环境的情况下，可以同时对多个环境进行加载使其生效，多个环境间使用逗号分隔：</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">    <span class="attr">include:</span> <span class="string">test,pro</span></span><br><span class="line"><span class="comment"># 这样书写，文件的加载顺序是：test 》 pro 》 dev</span></span><br><span class="line"><span class="comment"># 当主环境dev与其他环境有相同属性时，主环境属性失效；其他环境中有相同的属性时，最后加载的环境属性生效</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="多环境开发-——-properties格式"><a href="#多环境开发-——-properties格式" class="headerlink" title="多环境开发 —— properties格式"></a>多环境开发 —— properties格式</h4><ul><li>properties文件多环境配置<strong>仅支持多文件格式</strong></li><li>主配置文件中设置<strong>公共配置</strong> —— 全局</li><li>环境分类配置文件中常用于<strong>配置冲突属性</strong> —— 局部</li></ul><h4 id="多环境分组管理"><a href="#多环境分组管理" class="headerlink" title="多环境分组管理"></a>多环境分组管理</h4><ul><li><p>使用include属性在激活指定环境的情况下，可以同时对多个环境进行加载使其生效，多个环境间使用逗号分隔 </p></li><li><p>当主环境dev与其他环境有相同属性时，主环境属性<strong>失效</strong>；其他环境中有相同的属性时，最后加载的环境属性<strong>生效</strong></p><p>(分组示例)根据功能对配置文件中的信息进行拆分，并制作成独立的配置文件，命名规则如下：</p></li><li><p>application-devDB.yml</p></li><li><p>application-devRedis.yml</p></li><li><p>application-devMVC.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">      <span class="attr">&quot;dev&quot;:</span> <span class="string">devDB,devRedis,devMVC</span></span><br><span class="line">      <span class="attr">&quot;pro&quot;:</span> <span class="string">proDB,proRedis,proMVC</span></span><br><span class="line">      <span class="attr">&quot;test&quot;:</span> <span class="string">testDB,testRedis,testMVC</span></span><br><span class="line"><span class="comment"># 这里启动dev组，配置文件扫描顺序是：dev 》 devDB 》 devRedis 》 devMVC      </span></span><br><span class="line"><span class="comment"># 当主环境dev与其他环境有相同属性时，主环境属性失效；其他环境中有相同的属性时，最后加载的环境属性生效</span></span><br></pre></td></tr></table></figure><p>多环境开发使用group属性设置配置文件分组，便于线上维护管理</p></li></ul><h4 id="多环境开发控制"><a href="#多环境开发控制" class="headerlink" title="多环境开发控制"></a>多环境开发控制</h4><p>Maven 与 SpringBoot 多环境兼容</p><ol><li><p><strong>Maven中设置多环境属性</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--application-dev.yml配置文件配置的环境--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev_env<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">profile.active</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">profile.active</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用activation标签，配置activeByDefault的默认启动配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--application-pro.yml配置文件配置的环境--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>pro_env<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">profile.active</span>&gt;</span>pro<span class="tag">&lt;/<span class="name">profile.active</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--application-test.yml配置文件配置的环境--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>test_env<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">profile.active</span>&gt;</span>test<span class="tag">&lt;/<span class="name">profile.active</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>SpringBoot中引用Maven属性</strong></p></li></ol><ul><li>使用@@符号将Maven属性括起来表示<strong>引用</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">@profile.active@</span>            <span class="comment"># 因为Maven中为dev配置了activeByDefault的默认启动配置，这里代表dev组</span></span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">      <span class="attr">&quot;dev&quot;:</span> <span class="string">devDB,devRedis,devMVC</span></span><br><span class="line">      <span class="attr">&quot;pro&quot;:</span> <span class="string">proDB,proRedis,proMVC</span></span><br><span class="line">      <span class="attr">&quot;test&quot;:</span> <span class="string">testDB,testRedis,testMVC</span></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>执行Maven打包指令，生成boot工程打包的.jar文件</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn clean</span><br><span class="line">mvn package</span><br></pre></td></tr></table></figure><a href="https://cloud.tencent.com/developer/article/2345174">【SpringBoot】多环境开发、分组管理、开发控制-腾讯云开发者社区-腾讯云</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术派个人总结</title>
      <link href="/2024/05/03/%E6%8A%80%E6%9C%AF%E6%B4%BE/"/>
      <url>/2024/05/03/%E6%8A%80%E6%9C%AF%E6%B4%BE/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="网关实现JWT的认证"><a href="#网关实现JWT的认证" class="headerlink" title="网关实现JWT的认证"></a>网关实现JWT的认证</h3><p>之前就是简单的实现了在网关通过过滤器进行认证，前端发账号密码过来后，进行校验认证，认证成功的话给前端发送生成的<code>JWT</code>令牌，同时设置过期时间后放入Redis中。<br>引入双Token刷新机制，我们可以做如下改变：在生成Token时，同时生成<code>Access_Token</code>和<code>Refresh_Token</code>并返回给前端，其他依旧把<code>Access_Token</code>放入Redis中，作为校验的一种认证手段。<br>刷新过程：前端请求时携带<code>Access_Token</code>访问服务器，当<code>Access_Token</code>过期时，服务器会告诉前端这个Token过期了（401错误），需要进行刷新，这时候前端需要携带<code>Refresh_Token</code>去请求Token刷新接口，获取新的<code>Access_Token</code>，如果没有过期则可以成功获取。</p><ol><li><p>为什么要使用双Token刷新机制？</p><blockquote><p>首先来说，为了安全考虑token的有效期不会很长，但是又不想用户经常进行登录操作，那么就可以使用刷新机制，让用户无感刷新，这样设置可以防止用户长时间使用同一个token，同时Refresh_Token只在网络中传输若干次，减少了令牌泄露的风险。</p></blockquote></li><li><p>为什么不使用单token机制</p><blockquote><p>单令牌在被盗后容易被无限刷新访问资源；<br>而且如果每个请求都进行判断是否要续期会有一部分开销。<br>双token则只需要在过期时才进行续期。</p></blockquote></li></ol><h3 id="会员券抢购功能-缓存问题"><a href="#会员券抢购功能-缓存问题" class="headerlink" title="会员券抢购功能 &amp; 缓存问题"></a>会员券抢购功能 &amp; 缓存问题</h3><ol><li><p>怎么解决数据的一致性</p><blockquote><p>首先对于数据库是采用更新操作，对于缓存则可以选择删除缓存<br><code>删除缓存，更新数据库：</code>可能会出现数据库还未更新就发生缓存重建，可以采取延时双删<br><code>更新数据库，删除缓存：</code>可能会删除缓存失败，可以采取删除重试机制<br>采用先更新数据库再删缓存，可以保证数据的最终一致性</p></blockquote></li><li><p>缓存穿透</p><blockquote><p>查询的数据在缓存和数据库都没有，但是两个都要查一遍<br>可以采取缓存空值或者使用布隆过滤器</p></blockquote></li><li><p>缓存击穿</p><blockquote><p>某个热点key过期，大量请求到达数据库<br>加互斥锁进行缓存重建；设置键逻辑过期<br>两者都有缓存重建过程，前者会重试获取数据，适合数据一致性要求高一些的；后者会返回逻辑过期数据，适合数据一致性要求不高的</p></blockquote></li><li><p>缓存雪崩</p><blockquote><p>同一时间大量key过期<br>设置过期值时添加随机过期时间；使用队列访问，比较慢；采用熔断机制</p></blockquote></li><li><p>超卖问题</p><blockquote><p>采用乐观锁进行判断，但是不能使用CAS进行判断，会只有一个扣减成功应该在扣减库存时判断库存大于0即可</p></blockquote></li><li><p>一人一单</p><blockquote><p>根据用户ID进行加锁，保证用户只能有一次下单机会</p></blockquote></li></ol><h3 id="使用Caffeine加Redis构建多级缓存"><a href="#使用Caffeine加Redis构建多级缓存" class="headerlink" title="使用Caffeine加Redis构建多级缓存"></a>使用Caffeine加Redis构建多级缓存</h3><p>有一些信息（侧边栏信息）访问及其频繁，可以考虑放到<code>Java</code>的本地内存缓存中<br>主要借助<code>Caffeine</code> + <code>@Cacheable</code>来使用，首先构建<code>CacheManager</code>的Bean，将其作为本地缓存，然后在类或者方法上添加注解</p><ol><li><p>为什么要构建多级缓存</p><blockquote><p>对于一些访问频繁且变动及其少的数据，可以选择放入<code>Java</code>内存中，提高响应速度</p></blockquote></li><li><p>还有哪些本地缓存方式</p><blockquote><p>HashMap：实现相对比较简单，需要考虑一些并发问题，不适用与复杂的场景<br>Guava Cache：比较优异的缓存工具，可以认为是<code>Caffeine</code> 前一个版本<br>Encahe：功能更加丰富，扩展性更强，但是性能是最差的<br>总结：对于本地缓存的方案中，推荐Caffeine，性能上遥遥领先。虽然Encache功能更为丰富，甚至提供了持久化和集群的功能，但是这些功能完全可以依靠其他方式实现。真实的业务工程中，建议使用Caffeine作为本地缓存，另外使用Redis或者<code>Memcache</code>作为分布式缓存，构造多级缓存体系，保证性能和可靠性。</p></blockquote></li><li><p>能否放多个 @Cacheable 注解</p><blockquote><p>可以放，访问顺序按照放入的顺序进行访问，最后找不到才执行方法内代码</p></blockquote></li><li><p><code>Caffeine</code> 缓存的过期时间设置</p><blockquote><p>如果需要不同的过期时间策略的缓存，那么可以声明不同的<code>CacheManager</code>的Bean，配合注解指定即可</p></blockquote></li></ol><h3 id="使用-ControllerAdvice-全局异常处理"><a href="#使用-ControllerAdvice-全局异常处理" class="headerlink" title="使用 ControllerAdvice  全局异常处理"></a>使用 ControllerAdvice  全局异常处理</h3><p>使用<code>@RestControllerAdvice</code>和<code>@ExceptionHandler</code>两个注解，进行全局异常处理<br>将所有异常放在某个规范类中，按照不同的异常类型分开写为枚举类型<br><code>@ExceptionHandler</code>将自动进行拦截对应的异常类型，从而进行对应的代码处理</p><ol><li>你还知道什么处理方案吗<blockquote><p>继承<code>ResponseEntityExceptionHandler</code>重写里面的异常处理方法，但是只能处理Spring内部抛出的异常<br>实现<code>HandlerExceptionResolver</code>重写方法，但是没有那么方便</p></blockquote></li></ol><h3 id="ThreadLocal-封装用户信息"><a href="#ThreadLocal-封装用户信息" class="headerlink" title="ThreadLocal  封装用户信息"></a>ThreadLocal  封装用户信息</h3><p>在项目里面用户进行访问时，会获取用户信息，将这些信息存在<code>ThreadLocal</code>中。</p><ol><li><p>什么是 ThreadLocal  ？为什么要用？</p><blockquote><p> ThreadLocal 是线程本地变量，每个线程都有一个_ThreadLocalMap_，里面存的是<code>Entry ( ThreadLocal &lt;?&gt; k , Object v ) </code>；<br>每个线程操作这个变量时，实际上是操作自己的本地变量，起到线程隔离的作用；<br>从程序上来说，进行用户信息存储后，在全局位置随时可以获取这个信息，更方便。</p></blockquote></li><li><p>将用户信息封装到了 <code>ThreadLocal </code> ，如果线程池并行执行多个操作都要使用用户信息怎么办？</p><blockquote><ul><li>比较简单的就是将这些信息作为参数进行传递</li><li><code>inheritableThreadLocals</code>，父线程的此变量不为空时会赋给子线程的<code>inheritableThreadLocals</code></li></ul></blockquote></li><li><p>ThreadLocal 还有哪些应用场景</p><blockquote><ul><li>数据库连接管理，避免多个线程共享连接时出现的同步问题</li><li>用户会话管理，存储每个请求对应的用户会话数据</li><li>对象池（线程池、数据库连接池…）的线程隔离，为每个线程提供独立的对象池实例</li></ul></blockquote></li></ol><h3 id="日志访问控制"><a href="#日志访问控制" class="headerlink" title="日志访问控制"></a>日志访问控制</h3><p>这个实际上是使用<code>logback</code>进行日志记录，实际上是依赖加配置文件，或许可以去掉。</p><h3 id="RedisTemplate使用"><a href="#RedisTemplate使用" class="headerlink" title="RedisTemplate使用"></a>RedisTemplate使用</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712661589227-b24d1a2c-a425-41aa-8d72-7d0675e0a143.png#averageHue=%23d1bebe&clientId=u11e6c484-f59c-4&from=paste&height=236&id=u61e36f70&originHeight=389&originWidth=1122&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=241494&status=done&style=none&taskId=u6139ae5f-f6f8-4b66-9717-0a4e970cc6d&title=&width=680" alt="image.png"><br>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">10.166</span><span class="number">.33</span><span class="number">.175</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTemplateConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span>&#123;</span><br><span class="line">        RedisTemplate&lt;String,Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">// 设置序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置key的序列化为string</span></span><br><span class="line">        redisTemplate.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        redisTemplate.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置value的序列化为JSON</span></span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置序列化工具，防止序列化为乱码</span></span><br><span class="line"><span class="comment">// 这种方式不行，存的内容还包括类的包名，占空间</span></span><br><span class="line"><span class="comment">// 进行手动的序列化和反序列化</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate; <span class="comment">// key和value序列化都是string</span></span><br><span class="line"><span class="comment">// 序列化工具</span></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">MAPPER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>(); </span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> MAPPER.writeValueAsString(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;liu&quot;</span>, <span class="number">18</span>));</span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> MAPPER.readValue(s, User.class);</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AichatUserApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712661458669-c6cd546f-767f-4dac-b4a7-22e705deda35.png#averageHue=%23f6f6f6&clientId=u11e6c484-f59c-4&from=paste&height=290&id=u0d62d42b&originHeight=479&originWidth=783&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=94432&status=done&style=none&taskId=uc7a64295-672d-4cd3-9e1d-aae8ab563ae&title=&width=474.5454271174675" alt="image.png"></p><h3 id="短信登录"><a href="#短信登录" class="headerlink" title="短信登录"></a>短信登录</h3><ol><li>发送验证码</li></ol><ul><li>校验手机号<ul><li>不正确返回错误信息</li><li>正确校验验证码<ul><li>将验证码存入Redis并设置有效期</li></ul></li></ul></li></ul><ol start="2"><li>验证码登录、注册</li></ol><ul><li>校验手机号<ul><li>不正确返回错误信息</li><li>正确校验验证码<ul><li>不一致报错</li><li>一致查询用户是否存在<ul><li>用户不存在创建</li><li>存在继续执行程序</li></ul></li><li>保存用户信息到session中</li><li>生成UUID作为token登录令牌，并保存token在Redis有效期</li></ul></li></ul></li></ul><ol start="3"><li>校验登录状态</li></ol><ul><li>cookie中获取token <ul><li>判断用户是否登录或登录是否过期<ul><li>未登录拦截</li><li>登录则保存用户信息到threadLocal，刷新登录过期时间</li></ul></li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/43109882/1712986438427-27d3158e-f0d3-4631-a848-5f93d89b78ed.jpeg"></p><h3 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h3><ul><li>本地用高并发</li></ul><p>Static final ConcurrentHashMap&lt;K,V&gt; map &#x3D; new ConcurrentHashMap&lt;&gt;();</p><ul><li>用于Redis等缓存</li></ul><p>static final Cache&lt;K,V&gt; USER_CACHE &#x3D; CacheBuilder.newBuilder().build();</p><ul><li>本地缓存</li></ul><p>Static final Map&lt;K,V&gt; map &#x3D;  new HashMap();</p><ol><li>缓存作用</li></ol><ul><li>降低后端成本</li><li>提高读写效率，降低响应时间</li></ul><ol start="2"><li>缓存成本</li></ol><ul><li>数据一致性成本</li><li>代码维护成本</li><li>运维成本（服务器集群）</li></ul><p><strong>多级缓存</strong><br>浏览器缓存：要是存在于浏览器端的缓存<br>应用层缓存：可以分为toncat本地缓存，例如之前提到的map或者是使用Redis作为缓存<br>数据库缓存：：在数据库中有一片空间是buffer pool，增改查数据都会先加载到mysql的缓存中<br>CPU缓存：当代计算机最大的问题就是CPU性能提升了，但是内存读写速度没有跟上，所以为了适应当下的情况，增加了CPU的L1，L2，L3级的缓存<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712977565700-eacc0ee6-ca2e-464f-8612-ece22560c1e9.png#averageHue=%23b8aaa7&clientId=ucf8221e1-1d28-4&from=paste&height=275&id=u98f1cc31&originHeight=977&originWidth=937&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=404141&status=done&style=none&taskId=u52a060d1-bae2-43f7-a399-131e4c7e4fc&title=&width=263.87120056152344" alt="image.png"></p><h6 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h6><ul><li>内存淘汰：Redis自动进行，当Redis内存大到我们设定的 max-memery 时，会自动触发淘汰机制，淘汰掉一些不重要的数据（可以自己设置策略方式）</li><li>超时剔除：当我们给Redis设置了过期时间TTL之后，Redis会将超时的数据进行删除，方便我们继续使用缓存</li><li>主动更新：我们可以手动调用方法把缓存删除掉，通常用于解决缓存和数据库不一致问题<blockquote><p>采用双写方案：缓存调用者在更新完数据库之后再更新缓存</p></blockquote></li></ul><p><strong>先删除缓存，再更新数据库</strong><br>线程1删除缓存，还没来得及更新数据库，线程2来查询，缓存没有去数据库查到脏数据<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712978465435-af807914-2033-4e0d-ac32-724cfd35d4c1.png#averageHue=%23bebebe&clientId=ucf8221e1-1d28-4&from=paste&height=324&id=u078123ed&originHeight=940&originWidth=731&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=197478&status=done&style=none&taskId=ueb626447-2310-4921-901e-11f2d8c69a1&title=&width=252.02459716796875" alt="image.png"><br><strong>先更新数据库，再删除缓存</strong><br>删除缓存的操作很快，但是更新数据库的操作相对较慢，如果此时有一个线程2刚好进来查询缓存，由于我们刚刚才删除缓存，所以线程2需要查询数据库，并写入缓存，但是我们更新数据库的操作还未完成，所以线程2查询到的数据是脏数据，出现线程安全问题<br>导致数据不一致，但是这个出现线程安全问题概率较小<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712978489223-427ec784-e887-4410-b9f3-a5ddfc7091e2.png#averageHue=%23bdbdbd&clientId=ucf8221e1-1d28-4&from=paste&height=328&id=uHKeC&originHeight=937&originWidth=715&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=197398&status=done&style=none&taskId=uaa31363d-9778-4faa-8758-a8407539bd4&title=&width=250.32763671875" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712978740327-ae9d6808-9739-4536-99a7-27bfc660ae49.png#averageHue=%235d6262&clientId=ucf8221e1-1d28-4&from=paste&height=140&id=u0ff30755&originHeight=255&originWidth=941&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=110027&status=done&style=none&taskId=u64208416-abb4-494e-8fad-f6411c377b4&title=&width=516.302978515625" alt="image.png"></p><h6 id="缓存穿透问题解决"><a href="#缓存穿透问题解决" class="headerlink" title="缓存穿透问题解决"></a>缓存穿透问题解决</h6><ul><li>缓存穿透：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远都不会生效（只有数据库查到了，才会让redis缓存，但现在的问题是查不到），会频繁的去访问数据库。</li><li>常见的结局方案有两种<ol><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：额外的内存消耗，可能造成短期的不一致</li></ul></li><li>布隆过滤<ul><li>优点：内存占用少，没有多余的key</li><li>缺点：实现复杂，可能存在误判</li></ul></li></ol></li></ul><p>选择缓存空对象：如果数据不存在，则缓存一个空对象在缓存中，并设置有效期<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712978993359-bfb3a95d-6ca2-427b-b707-c648636e450d.png#averageHue=%23bcc4c6&clientId=ucf8221e1-1d28-4&from=paste&height=234&id=uc2af4ef1&originHeight=510&originWidth=1009&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=71445&status=done&style=none&taskId=u2960594c-1528-43f3-99b8-31035a86bcc&title=&width=463.51513671875" alt="image.png"></p><h6 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a>缓存雪崩问题</h6><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712979057893-7792ded9-56d6-46a2-9b80-62360e051222.png#averageHue=%23212221&clientId=ucf8221e1-1d28-4&from=paste&height=216&id=u374f53a9&originHeight=421&originWidth=1248&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=280822&status=done&style=none&taskId=udd04b4ec-380e-48e3-953c-71122426040&title=&width=640.7802734375" alt="image.png"><br>貌似没有代码体现，还是添加过期时间随机值</p><h6 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h6><p>热点key失效，大量请求直接到数据库<br><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/43109882/1712986527420-ac5bcf5d-7ec6-4c53-9d07-cdbb2fb279ef.jpeg"></p><h3 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h3><ul><li>首先提交优惠券id，然后查询优惠券信息</li><li>之后判断秒杀时间是否开始<ul><li>开始了，则判断是否有剩余库存<ul><li>有库存，那么删减一个库存<ul><li>然后创建订单</li></ul></li><li>无库存，则返回一个错误信息</li></ul></li><li>没开始，则返回一个错误信息</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712987104681-c3fbd3dc-a6bf-4b86-a1a8-ce76eff29353.png#averageHue=%23c6c4c4&clientId=u5d98e9b1-cc09-4&from=paste&height=358&id=ua1f8f83a&originHeight=671&originWidth=1127&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=251133&status=done&style=none&taskId=ubea029b5-d163-43c4-b8c3-9f0e1c0ce53&title=&width=601.0666666666667" alt="image.png"></p><ul><li>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案<ol><li>悲观锁<ul><li>悲观锁认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行</li><li>例如Synchronized、Lock等，都是悲观锁</li></ul></li><li>乐观锁<ul><li>乐观锁认为线程安全问题不一定会发生，因此不加锁，只是在更新数据的时候再去判断有没有其他线程对数据进行了修改<ul><li>如果没有修改，则认为自己是安全的，自己才可以更新数据</li><li>如果已经被其他线程修改，则说明发生了安全问题，此时可以重试或者异常</li></ul></li></ul></li></ol></li><li>悲观锁：悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</li><li>乐观锁：乐观锁会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如CAS</li><li>乐观锁的典型代表：就是CAS(Compare-And-Swap)，利用CAS进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 &#x3D;&#x3D; 内存值，则代表中间没有被人修改过，此时就将新值去替换内存值</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/43109882/1712989869230-1bc2f3f1-84c7-42a6-9614-2877443f791c.jpeg"></p><h6 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h6><p>只剩一张优惠券时，多个线程判断库存大于1，同时进行扣减，发生超卖问题<br>乐观锁：</p><ul><li>判断库存查询前后是否发生变化 -&gt; 多个线程拿到同一个库存，扣减成功的只有一个线程（失败）</li><li>修改数据库时判断库存大于0即可（优化）</li></ul><h6 id="一人一单失败"><a href="#一人一单失败" class="headerlink" title="一人一单失败"></a>一人一单失败</h6><p>用户开多个线程，在判断是否存在订单时，都判断不存在，导致一人一单失败<br>优化：把判断订单是否存在以及后续操作进行用户ID加锁<br>问题：集群下这样的锁是独立的，本地锁</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/43109882/1712992735044-a461bd3a-7076-4954-b55a-4b26cb2d8509.jpeg"></p><h6 id="误删锁①"><a href="#误删锁①" class="headerlink" title="误删锁①"></a>误删锁①</h6><p>自己的锁过期了，释放锁时把别人的锁释放了<br>优化：存锁时放入自己的线程标识，释放锁时判断一下</p><h6 id="误删锁②"><a href="#误删锁②" class="headerlink" title="误删锁②"></a>误删锁②</h6><p>极端情况下，在释放锁时判断是自己的锁，发生阻塞，在TTL过期后，其它进程拿到锁，再释放时误删<br>优化：把判断是否自己的锁和删除锁的操作放入lua脚本中</p><h3 id="分布式锁-Redisson"><a href="#分布式锁-Redisson" class="headerlink" title="分布式锁-Redisson"></a>分布式锁-Redisson</h3><p>SETNX存在以下问题</p><ul><li>重入问题：重入问题是指获取锁的线程，可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁</li><li>不可重试：获取锁时缺少重试机制，只能获取一次</li><li>超时释放：锁到时就释放，不能续锁</li><li>如果Redis提供了主从集群，那么当我们向集群写数据时，主机需要异步的将数据同步给从机，万一在同步之前，主机宕机了(主从同步存在延迟，虽然时间很短，但还是发生了)，那么又会出现死锁问题</li></ul><h6 id="解决可重入问题"><a href="#解决可重入问题" class="headerlink" title="解决可重入问题"></a>解决可重入问题</h6><p>利用锁计数计算重入次数；重入锁时，判断是否有锁，有的话就判断是否自己的锁，是的话锁计数加1；释放锁时类似<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712995804828-1b79dc5d-45b0-4b85-8a93-f56f560d4c8c.png#averageHue=%23bab3b3&clientId=u5d98e9b1-cc09-4&from=paste&height=369&id=u54c032ea&originHeight=925&originWidth=857&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=451188&status=done&style=none&taskId=u7f476801-d3d8-4a06-a57d-2ea241e8d59&title=&width=342.0666809082031" alt="image.png"></p><h6 id="Redisson锁重试和WatchDog机制"><a href="#Redisson锁重试和WatchDog机制" class="headerlink" title="Redisson锁重试和WatchDog机制"></a>Redisson锁重试和WatchDog机制</h6><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712996132092-04cf68f8-0c08-4550-ba00-ff84787a9346.png#averageHue=%23c8c5c5&clientId=u5d98e9b1-cc09-4&from=paste&height=319&id=ueacf7d4e&originHeight=599&originWidth=1260&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=291001&status=done&style=none&taskId=u0af0126f-278f-45a7-ba6f-7136300c7e4&title=&width=672" alt="image.png"><br>这部分有源码，复杂。。。</p><h6 id="Redisson锁的MutiLock原理"><a href="#Redisson锁的MutiLock原理" class="headerlink" title="Redisson锁的MutiLock原理"></a>Redisson锁的MutiLock原理</h6><p>使用联锁：<br>我们就需要将加锁的逻辑写入到每一个主从节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获取锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性</p><h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><ol><li>不可重入Redis分布式锁<ul><li>原理：利用SETNX的互斥性；利用EX避免死锁；释放锁时判断线程标识</li><li>缺陷：不可重入、无法重试、锁超时失效</li></ul></li><li>可重入Redis分布式锁<ul><li>原理：利用Hash结构，记录线程标识与重入次数；利用WatchDog延续锁时间；利用信号量控制锁重试等待</li><li>缺陷：Redis宕机引起锁失效问题</li></ul></li><li>Redisson的multiLock<ul><li>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功</li></ul></li></ol><h3 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712996694899-0795ff5b-033a-4871-9939-893034ce9d59.png#averageHue=%23c7c4c4&clientId=u5d98e9b1-cc09-4&from=paste&height=258&id=ucf0546a8&originHeight=572&originWidth=1202&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=299166&status=done&style=none&taskId=ue50006e3-0a93-454e-95f7-9cf69cc3cff&title=&width=541.1333618164062" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1712996826487-c49e8dc7-2c8f-4113-b6cf-efd99c6933f0.png#averageHue=%23c2bebe&clientId=u5d98e9b1-cc09-4&from=paste&height=255&id=u880a2105&originHeight=588&originWidth=1255&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=293812&status=done&style=none&taskId=u3eb2ca76-439a-484b-a5fb-b1759ff1133&title=&width=544.1333618164062" alt="image.png"><br>把判断库存是否充足、判断是否下单过、扣减库存（在Redis的set中表示用户已经下过单了）这几个功能加入lua脚本中，返回结果表示是否下单成功<br>外面调用脚本获得结果，如果下单成功则将订单信息加入Redis缓存，再进行异步下单</p><h6 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h6><ul><li>秒杀业务的优化思路是什么？<ol><li>先利用Redis完成库存容量、一人一单的判断，完成抢单业务</li><li>再将下单业务放入阻塞队列，利用独立线程异步下单</li></ol></li><li>基于阻塞队列的异步秒杀存在哪些问题？<ol><li>内存限制问题：<ul><li>我们现在使用的是JDK里的阻塞队列，它使用的是JVM的内存，如果在高并发的条件下，无数的订单都会放在阻塞队列里，可能就会造成内存溢出，所以我们在创建阻塞队列时，设置了一个长度，但是如果真的存满了，再有新的订单来往里塞，那就塞不进去了，存在内存限制问题</li></ul></li><li>数据安全问题：<ul><li>经典服务器宕机了，用户明明下单了，但是数据库里没看到</li></ul></li></ol></li></ul><h3 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h3><p>基于List、PubSub、Stream的消息队列</p><h6 id="基于List实现消息队列"><a href="#基于List实现消息队列" class="headerlink" title="基于List实现消息队列"></a>基于List实现消息队列</h6><ul><li>基于List结构模拟消息队列</li><li>消息队列(Message Queue)，字面意思就是存放消息的队列，而Redis的list数据结构是一个双向链表，很容易模拟出队列的效果</li><li>队列的入口和出口不在同一边，所以我们可以利用：LPUSH结合RPOP或者RPUSH结合LPOP来实现消息队列。</li><li>不过需要注意的是，当队列中没有消息时，RPOP和LPOP操作会返回NULL，而不像JVM阻塞队列那样会阻塞，并等待消息，所以我们这里应该使用BRPOP或者BLPOP来实现阻塞效果</li><li>基于List的消息队列有哪些优缺点？<ul><li>优点<ol><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保障</li><li>可以满足消息有序性</li></ol></li><li>缺点<ol><li>无法避免消息丢失(经典服务器宕机)</li><li>只支持单消费者(一个消费者把消息拿走了，其他消费者就看不到这条消息了)</li></ol></li></ul></li></ul><h6 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a>基于PubSub的消息队列</h6><ul><li>PubSub(发布订阅)是Redis2.0版本引入的消息传递模型。顾名思义，消费和可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息</li><li>SUBSCRIBE channel [channel]：订阅一个或多个频道</li><li>PUBLISH channel msg：向一个频道发送消息</li><li>PSUBSCRIBE pattern [pattern]：订阅与pattern格式匹配的所有频道</li><li>基于PubSub的消息队列有哪些优缺点<ul><li>优点：<ol><li>采用发布订阅模型，支持多生产，多消费</li></ol></li><li>缺点：<ol><li>不支持数据持久化</li><li>无法避免消息丢失（如果向频道发送了消息，却没有人订阅该频道，那发送的这条消息就丢失了）</li><li>消息堆积有上限，超出时数据丢失（消费者拿到数据的时候处理的太慢，而发送消息发的太快）</li></ol></li></ul></li></ul><h6 id="基于Stream的消息队列–消费者组"><a href="#基于Stream的消息队列–消费者组" class="headerlink" title="基于Stream的消息队列–消费者组"></a>基于Stream的消息队列–消费者组</h6><ul><li>消费者组(Consumer Group)：将多个消费者划分到一个组中，监听同一个队列，具备以下特点<ol><li>消息分流<ul><li>队列中的消息会分留给组内的不同消费者，而不是重复消费者，从而加快消息处理的速度</li></ul></li><li>消息标识<ul><li>消费者会维护一个标识，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标识之后读取消息，确保每一个消息都会被消费</li></ul></li><li>消息确认<ul><li>消费者获取消息后，消息处于pending状态，并存入一个pending-list，当处理完成后，需要通过XACK来确认消息，标记消息为已处理，才会从pending-list中移除</li></ul></li></ol></li></ul><p>前一章将订单信息放入阻塞队列，这一章则放入Redis缓存中</p><h3 id="Caffeine实现多级缓存"><a href="#Caffeine实现多级缓存" class="headerlink" title="Caffeine实现多级缓存"></a>Caffeine实现多级缓存</h3><p> Caffeine + @Cacheable </p><ol><li><p>导入依赖</p></li><li><p>定义CaffeineCacheManager</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义缓存管理器，配合Spring的 <span class="doctag">@Cache</span> 来使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean(&quot;caffeineCacheManager&quot;)</span></span><br><span class="line"><span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="type">CaffeineCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CaffeineCacheManager</span>();</span><br><span class="line"> cacheManager.setCaffeine(Caffeine.newBuilder()</span><br><span class="line"> <span class="comment">// 设置过期时间，写入后五分钟过期</span></span><br><span class="line"> .expireAfterWrite(<span class="number">5</span>, TimeUnit.MINUTES)</span><br><span class="line"> <span class="comment">// 初始化缓存空间大小</span></span><br><span class="line"> .initialCapacity(<span class="number">100</span>)</span><br><span class="line"> <span class="comment">// 最大的缓存条数</span></span><br><span class="line"> .maximumSize(<span class="number">200</span>)</span><br><span class="line"> );</span><br><span class="line"> <span class="keyword">return</span> cacheManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开启 @EnableCaching  注解支持</p></li><li><p>缓存使用实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用caffeine本地缓存，来处理侧边栏不怎么变动的消息</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * cacheNames -&gt; 类似缓存前缀的概念</span></span><br><span class="line"><span class="comment"> * key -&gt; SpEL 表达式，可以从传参中获取，来构建缓存的key</span></span><br><span class="line"><span class="comment"> * cacheManager -&gt; 缓存管理器，如果全局只有一个时，可以省略</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Cacheable(key = &quot;&#x27;homeSidebar&#x27;&quot;, cacheManager = &quot;caffeineCacheManager&quot;, cache</span></span><br><span class="line"><span class="meta">public List&lt;SideBarDTO&gt; queryHomeSidebarList() &#123;</span></span><br><span class="line"><span class="meta"> List&lt;SideBarDTO&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="meta"> list.add(noticeSideBar());</span></span><br><span class="line"><span class="meta"> list.add(columnSideBar());</span></span><br><span class="line"><span class="meta"> list.add(hotArticles());</span></span><br><span class="line"><span class="meta"> return list;</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Cacheable(key = &quot;&#x27;columnSidebar&#x27;&quot;, cacheManager = &quot;caffeineCacheManager&quot;, cac</span></span><br><span class="line"><span class="meta">public List&lt;SideBarDTO&gt; queryColumnSidebarList() &#123;</span></span><br><span class="line"><span class="meta"> List&lt;SideBarDTO&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="meta"> list.add(subscribeSideBar());</span></span><br><span class="line"><span class="meta"> return list;</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">/**</span></span><br><span class="line"><span class="meta"> * 以用户 + 文章维度进行缓存设置</span></span><br><span class="line"><span class="meta"> *</span></span><br><span class="line"><span class="meta"> * @param author 文章作者id</span></span><br><span class="line"><span class="meta"> * @param articleId 文章id</span></span><br><span class="line"><span class="meta"> * @return</span></span><br><span class="line"><span class="meta"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Cacheable(key = &quot;&#x27;sideBar_&#x27; + #articleId&quot;, cacheManager = &quot;caffeineCacheManag</span></span><br><span class="line"><span class="meta">public List&lt;SideBarDTO&gt; queryArticleDetailSidebarList(Long author, Long articl</span></span><br><span class="line"><span class="meta"> List&lt;SideBarDTO&gt; list = new ArrayList&lt;&gt;(2);</span></span><br><span class="line"><span class="meta"> // 不能直接使用 pdfSideBar()的方式调用，会导致缓存不生效</span></span><br><span class="line"><span class="meta"> list.add(SpringUtil.getBean(SidebarServiceImpl.class).pdfSideBar());</span></span><br><span class="line"><span class="meta"> list.add(recommendByAuthor(author, articleId, PageParam.DEFAULT_PAGE_SIZE)</span></span><br><span class="line"><span class="meta"> return list;</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">/**</span></span><br><span class="line"><span class="meta"> * PDF 优质资源</span></span><br><span class="line"><span class="meta"> *</span></span><br><span class="line"><span class="meta"> * @return</span></span><br><span class="line"><span class="meta"> */</span></span><br><span class="line"><span class="meta">@Cacheable(key = &quot;&#x27;sideBar&#x27;&quot;, cacheManager = &quot;caffeineCacheManager&quot;, cacheName</span></span><br><span class="line"><span class="meta">public SideBarDTO pdfSideBar() &#123;</span></span><br><span class="line"><span class="meta"> List&lt;ConfigDTO&gt; pdfList = configService.getConfigList(ConfigTypeEnum.PDF);</span></span><br><span class="line"><span class="meta"> List&lt;SideBarItemDTO&gt; items = new ArrayList&lt;&gt;(pdfList.size());</span></span><br><span class="line"><span class="meta"> .... // 省略</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p> 注意事项1<br>重点注意上面的缓存注解 @Cacheable</p></li></ol><ul><li><p>cacheManager: 指定的就是前面配置类中注册的缓存管理器（so，前面的问题答案是不是有 了？）</p></li><li><p>cacheNames: 可以简单理解为缓存的前缀，比如上面分别是首页侧边栏，专栏侧边栏，文章 详情页侧边栏 </p></li><li><p>key: SpEL表达式，可以基于方法参数来生成对应的缓存key；若是常量字符串，用单引号包裹<br>:::success<br> 这个缓存注解，表明是优先从缓存中获取，缓存没有则执行方法内逻辑，并将返回的结果写入缓 存<br>:::<br> 注意事项2<br>其次需要注意的点是同一个service内部，若想要缓存注解生效，请不要直接内部调用，而是需要像 上面的 SpringUtil.getBean(xxx).xxx 的方式来中转一下，走代理调用<br>其它常用注解</p></li><li><p>@CacheEvict ：删除缓存</p></li><li><p>@CachePut : 方法执行完毕之后，主动将对应的结果写入缓存  </p></li><li><p>@Caching : 可以组合多个缓存注解使用</p></li></ul><p>最后小结一下Caffenine结合SpringBoot的使用姿势，非常简单</p><ol><li>添加jar包依赖</li><li>注册缓存管理器Bean: CacheManager</li><li>启动类上，添加 <a href="/EnableCaching">@EnableCaching </a> 注解 </li><li>在需要缓存的方法上，添加 <a href="/Cacheable">@Cacheable </a> , <a href="/CachePut">@CachePut </a> , <a href="/CacheEvit">@CacheEvit </a> , <a href="/Caching">@Caching </a> 注解 </li><li>然后大功告成</li></ol><h3 id="用户活跃排行榜"><a href="#用户活跃排行榜" class="headerlink" title="用户活跃排行榜"></a>用户活跃排行榜</h3><p>幂等策略：用Redis的hash结构保存记录<br>排行榜：用Redis的Zset实现排行榜<br><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/43109882/1715246501472-3ba46414-c145-45b4-80b9-9f3c70473c90.jpeg"></p><h3 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h3><p>对于一些作者，他的文章发布是不需要审核的，就可以加入白名单<br>利用set结构来实现，具体方法实现不复杂，简单的set操作<br>四个方法： </p><ul><li>判断作者是否在文章发布的白名单中；  </li><li>获取所有的白名单用户  </li><li>将用户添加到白名单中  </li><li>从白名单中移除用户</li></ul><p>主要第一个方法，其他三个是后台管理的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断作者是否再文章发布的白名单中；</span></span><br><span class="line"><span class="comment"> * 这个白名单主要是用于控制作者发文章之后是否需要进行审核</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> authorId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">authorInArticleWhiteList</span><span class="params">(Long authorId)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取所有的白名单用户</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;BaseUserInfoDTO&gt; <span class="title function_">queryAllArticleWhiteListAuthors</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将用户添加到白名单中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addAuthor2ArticleWhitList</span><span class="params">(Long userId)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从白名单中移除用户</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeAuthorFromArticelWhiteList</span><span class="params">(Long userId)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC</title>
      <link href="/2024/04/10/JUC/"/>
      <url>/2024/04/10/JUC/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁&amp;悲观锁"></a>乐观锁&amp;悲观锁</h3><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。（多写场景）<br>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）（多读场景）<br><strong>版本号机制：</strong>每次要更新数据时，会读取一个版本号，在提交更新时，会判断版本号和自己获取的是否相同<br><strong>CAS算法：</strong>比较与替换，CAS（V,E,N）V：表示要更新的变量E：表示预期值N：表示新值；每次更新时比较预期值是否和要更新的变量相等，相等则可以修改，否则说明被其他线程修改了<br><strong>CAS问题：</strong></p><ol><li><p>ABA问题：比较值相等并不一定就是没有修改过，可能修改为其他值又修改回来的。</p><blockquote><p>乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1 操作，否则就执行失败</p></blockquote></li><li><p>循环性能开销：⾃旋CAS，如果⼀直循环执⾏，⼀直不成功，会给CPU带来⾮常⼤的执⾏开销。</p><blockquote><p>设置自旋次数，超过次数就停止自旋</p></blockquote></li><li><p>只能保证一个变量的原子操作</p><blockquote><p>使用加锁或者将多个变量封装成一个对象来操作</p></blockquote></li></ol><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>线程本地变量。如果你创建了⼀个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的⼀个本地拷贝，多个线程操作这个变量的时候，实际是操作⾃⼰本地内存⾥⾯的变量，从⽽起到线程隔离的作⽤，避免了线程安全问题。<br>原理：</p><ul><li>Thread类有⼀个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，每个线程都有⼀个属于自己的ThreadLocalMap。 </li><li>ThreadLocalMap内部维护着Entry数组，每个Entry代表⼀个完整的对象，key是ThreadLocal的弱引⽤，value是ThreadLocal的泛型值。 </li><li>每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap⾥存，读也是以某个ThreadLocal作为引用，在自己的map⾥找对应的key，从而实现了线程隔离。 </li><li>ThreadLocal本身不存储值，它只是作为⼀个key来让线程往ThreadLocalMap里存取值。</li></ul><p>总结：Thread有一个ThreadLocalMap，里面存储了每个线程的Entry&lt;k,v&gt;，k为线程ThreadLocal的弱引用，v为存储的值，设置或者获取值时根据ThreadLocal来，从而实现线程的隔离<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713332259014-253c3378-1ac2-4ecc-bd65-2beb78df6a92.png#averageHue=%23f5f1db&clientId=u799c394e-74a2-4&from=paste&height=291&id=u9ce8aa00&originHeight=436&originWidth=762&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=47771&status=done&style=none&taskId=u156eba00-4cd3-431e-8fad-d694dc73c30&title=&width=508" alt="image.png"><br>内存泄露<br>栈中存储了ThreadLocal、Thread的引用，堆中存储了它们的具体实例</p><blockquote><p>弱引⽤：只要垃圾回收机制一运⾏，不管JVM的内存空间是否充足，都会回收该对象占⽤的内<br>存</p></blockquote><p>ThreadLocalMap存的是ThreadLocal的弱引用，如果ThreadLocal被回收了，value还在，造成内存泄露问题（确保最后一定调用remove（）方法）<br>为什么设计为弱引用<br>如果是强引用，ThreadLocal引用销毁时，key还是强引用指向ThreadLocal，那么垃圾回收器就不能回收ThreadLocal，从而内存泄漏<br>ThreadLocalMap结构<br>并没有实现map接口，而是通过Entry类型的数组储存数据，利用哈希取余法将key映射到对应的数组下标<br>使用线性探测法解决hash冲突（这个位置不行看看下一个位置）<br>扩容机制：先清理过期的Entry，再判断是否扩容；遍历扩容到新数组，两倍扩容</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>定义：线程池是用于管理线程的资源池，它可以使一些线程保持存活状态；有新任务时直接用，而不是需要时创建线程，用完就销毁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">int</span> corePoolSize,//线程池的核心线程数量</span></span><br><span class="line"><span class="params">  <span class="type">int</span> maximumPoolSize,//线程池的最大线程数</span></span><br><span class="line"><span class="params">  <span class="type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><br><span class="line"><span class="params">  TimeUnit unit,//时间单位</span></span><br><span class="line"><span class="params">  BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span><br><span class="line"><span class="params">  ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span><br><span class="line"><span class="params">  RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><br><span class="line"><span class="params">                          )</span></span><br></pre></td></tr></table></figure><p>四种拒绝策略</p><ol><li>直接抛出异常拒绝服务</li><li>调用execute的调用者用自己的线程执行方法，要是线程关闭了就丢弃任务</li><li>直接丢弃</li><li>丢弃最早的没处理的任务</li></ol><p>创建线程池</p><ol><li><p>通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）</p></li><li><p>通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建（提供了一些线程池模板，底层还是使用了<code>ThreadPoolExecutor</code>）<br>原理</p></li><li><p>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</p></li><li><p>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。（队列没满，还不忙，不需要帮手）</p></li><li><p>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。（队列都满了，需要外援，增加线程）</p></li><li><p>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，拒绝策略由创建线程池时决定。</p></li></ol><p>对比</p><ul><li>Runnable 接口不会返回结果或抛出检查异常，但是 Callable 接口可以</li><li>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值</li><li>shutdown（）停止后要把剩下任务执行完毕；shutdownNow（）返回未被执行的任务列表</li><li>isShutDown 当调用 shutdown() 方法后返回为 true；isTerminated 当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true（判断关闭的标准不同，任务是否完全执行完毕）</li></ul><p>常见线程池</p><ul><li>new FixedThreadPool (固定数⽬线程的线程池) </li><li>new CachedThreadPool (可缓存线程的线程池) </li><li>new SingleThreadExecutor (单线程的线程池) </li><li>new ScheduledThreadPool (定时及周期执⾏的线程池)</li></ul><h3 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h3><ul><li>继承<code>Thread</code>类</li><li>实现<code>Runnable</code>接口</li><li>实现<code>Callable</code>接口（有返回值）</li></ul><h3 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h3><p><code>wait()</code>：调用某个共享变量的<code>wait()</code>方法进行线程阻塞挂起<br><code>notify()</code>：唤醒在某个共享变量上阻塞的线程<br><code>sleep()</code>：线程让出执行权，到时间参与CPU调度</p><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>初始状态：线程被创建，未调用start()方法<br>就绪状态：一切都创建好了，等待CPU调度<br>运行状态：正常执行任务过程<br>阻塞状态：线程由于某种原因发生阻塞<br>终止状态：线程已经执行完毕</p><h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><p>主要是指CPU的调度，将CPU分配给其他线程使用</p><h3 id="操作系统知识"><a href="#操作系统知识" class="headerlink" title="操作系统知识"></a>操作系统知识</h3><p><strong>并行</strong>是同一时刻两个线程同时执行，并发是同一时段两个线程进行切换执行<br><strong>进程</strong>是代码在数据集合上的一次运行活动，是操作系统分配资源的最小单位；<strong>线程</strong>是进程的一个执行路径，是CPU分配资源的最小路径<br><strong>线程创建方式</strong>：继承Thread类，实现Runnable接口，实现Callable接口（有返回值，能抛异常）<br>调用<strong>start（）</strong>方法是新建线程调用，<strong>run（）</strong>方法是在主线程中调用<br>子线程调用<strong>join（）</strong>方法，父线程停止等待子线程执行完成<br><strong>线程上下文切换</strong>：CPU分配时间片，挂起线程把资源给别的线程<br><strong>守护线程</strong>是为<strong>用户线程</strong>服务的，比如垃圾回收线程，只有所有用户线程结束，回收线程才会自动结束生命周期<br><strong>线程通信方式</strong>：Thread.join()，ThreadLocal，synchronized实现加锁等</p><h3 id="原子性、可见性、有序性"><a href="#原子性、可见性、有序性" class="headerlink" title="原子性、可见性、有序性"></a>原子性、可见性、有序性</h3><p>原子性：不可再分，要么成功要么失败（synchnized）<br>可见性：修改了某个共享变量后其他的线程是否能够感知（volatile）<br>有序性：单线程没有问题，并发时会发生指令重排（两个关键字都可以）</p><h3 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h3><p>使用该字段的变量在被修改时会被刷新会主内存（存放线程共享变量的地方），读取时也需要从主内存读取</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><strong>synchronized</strong></h3><p>修饰代码块，修饰静态方法，修饰实例方法<br>基于<strong>Monitor</strong>机制实现<br>可见性：加锁前从主内存读取最新数据，加锁后不允许其他线程获取共享数据，解锁前把数据写入主内存<br>有序性：保证执行结果的有序性<br>可重入：在加锁时有一个state变量记录加锁次数，同样解锁也需要根据这个变量来判断</p><h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的<br>情况下，这些线程会⼀直相互等待而无法继续运行下去。<br>互斥条件：资源只能被一个线程使用（无法破坏）<br>请求并持有：在申请其他资源的时被阻塞又不释放自己的资源（可以一次性请求所有资源）<br>不可剥夺：我不释放的资源，别人也别想用（申请其他资源不到就释放所有资源）<br>环路等待：申请资源时出现环（按照资源序号申请）</p><h3 id="CountDownLatch-CyclicBarrier"><a href="#CountDownLatch-CyclicBarrier" class="headerlink" title="CountDownLatch &amp; CyclicBarrier"></a><strong>CountDownLatch &amp; CyclicBarrier</strong></h3><p><strong>CountDownLatch：</strong>用来协调多个线程之间的同步，或者说起到线程之间的通信，比如多个线程同时结束才能通过，或者同步多个线程的执行起点<br><strong>CyclicBarrier：</strong>它可以阻塞多个线程，直到某个事件的发生才能执行后续操作（栅栏）<br>闭锁用于等待事件，而栅栏用于等待其他线程</p><ul><li>CountDownLatch是⼀次性的，⽽CyclicBarrier则可以多次设置屏障，实现重复利⽤； </li><li>CountDownLatch中的各个⼦线程不可以等待其他线程，只能完成⾃⼰的任务；⽽CyclicBarrier 中的各个线程可以等待其他线程</li></ul><p>Semaphore（信号量）是⽤来控制同时访问特定资源的线程数量</p><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>它是一种抽象出来的模型，包括主内存和本地内存<br>主内存存放共享变量，本地内存存放该线程以读&#x2F;写共享变量的副本</p><h3 id="线程交替打印"><a href="#线程交替打印" class="headerlink" title="线程交替打印"></a>线程交替打印</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; <span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;偶数线程&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; <span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;奇数线程&quot;</span>).start();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2024/03/21/Spring/"/>
      <url>/2024/03/21/Spring/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://cyborg2077.github.io/2023/04/28/InQString/">Spring面试题</a></p><h2 id="Autowired和-Resource"><a href="#Autowired和-Resource" class="headerlink" title="@Autowired和@Resource"></a>@Autowired和@Resource</h2><p><strong>联系</strong></p><ul><li>@Autowired和@Resource注解都是作为bean对象注入的时候使用的</li><li>两者都可以声明在字段和setter方法上</li><li>注意：如果声明在字段上，那么就不需要再写setter方法。但是本质上，该对象还是作为set方法的实参，通过执行set方法注入，只是省略了setter方法罢了</li></ul><p><strong>区别</strong></p><ul><li>@Autowired注解是Spring提供的，而@Resource注解是J2EE本身提供的</li><li>@Autowird注解默认通过byType方式注入，而@Resource注解默认通过byName方式注入</li><li>@Autowired注解注入的对象需要在IOC容器中存在，否则需要加上属性required&#x3D;false，表示忽略当前要注入的bean，如果有直接注入，没有跳过，不会报错</li></ul><p>@Autowird默认的注入方式为byType，也就是根据类型匹配，当有多个实现时，则通过byName注入，也可以通过配合@Qualifier注解来显式指定name值，指明要使用哪个具体的实现类（先判断类型是否匹配，再根据name匹配）<br>@Resource默认通过byName注入，如果没有匹配则通过byType注入</p><h2 id="依赖注入的方式"><a href="#依赖注入的方式" class="headerlink" title="依赖注入的方式"></a>依赖注入的方式</h2><ol><li><p><strong>构造器注入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 使用构造器注入方式，将UserRepository类型的依赖项注入到UserService中</span><br><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">    private UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    public UserService(UserRepository userRepository) &#123;</span><br><span class="line">        this.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为构造器的参数，进行传递后复制给局部变量</p></li><li><p>可注入不可变对象；</p></li><li><p>注入对象不会被修改；</p></li><li><p>注入对象会被完全初始化；</p></li><li><p>通用性更好。</p></li><li><p><strong>setter方式注入</strong></p></li></ol><p>类似于构造器注入，不过换成了setter方法，对象创建后手动调用</p><ul><li>无法注入一个不可变的对象（final 修饰的对象）</li><li>注入对象可被修改</li></ul><ol start="3"><li><strong>属性注入</strong></li></ol><p>@Autowired注解使用的方式</p><ul><li>无法注入一个不可变的对象（final 修饰的对象）</li><li>只能适应于 IoC 容器；</li><li>更容易违背单一设计原则</li></ul><h2 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a>Spring是什么</h2><p>Spring是一个轻量级的IoC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发。Spring的核心思想是通过依赖注入和面向切面编程来实现松耦合、可测试和易维护的应用程序<br>控制反转（IoC）, 依赖注入（DI），面向切面编程（AOP），事务管理等</p><h2 id="Spring-MVC是什么"><a href="#Spring-MVC是什么" class="headerlink" title="Spring MVC是什么"></a>Spring MVC是什么</h2><p>SpringMVC是Spring框架的一个模块，它提供了一种基于MVC（Model-View-Controller）架构的web应用程序开发模型，实现了Web应用程序的分层架构和模块化开发<br>DispatcherServlet（前端控制器）接收用户发送过来的请求，由它决定转发给那个Handler（处理器），Handler选择合适的方法，通过model来处理业务逻辑，通过view来返回相应解结果</p><h2 id="SpringMVC常用注解"><a href="#SpringMVC常用注解" class="headerlink" title="SpringMVC常用注解"></a>SpringMVC常用注解</h2><p>@Controller，@RequestMapping，@RequestBody，@RequestParam，@PathVariable，@ResponseBody</p><h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><p>实际上是以下三个注解的组合：<br><code>@Configuration</code>：实际上是<code>@SpringBootConfiguration</code>注解，表明可以包含Spring配置<br><code>@EnableAutoConfiguration</code>：开启自动配置功能<br><code>@ComponentScan</code>：启用Spring组件扫描</p><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p><strong>定义：</strong>它可以在程序运行过程中动态的插入某些功能到代码中，实现更灵活的程序设计</p><ul><li>切点：首先我们要明确在哪些程序进行插入（指定插入范围）</li><li>通知：具体的插入行为，前置，后置，环绕，异常等</li><li>切面：定义切点和通知的代码，可以认为是一种类</li><li>连接点：所有可能出发AOP的连接点（具体的插入位置）</li><li>织入：把切面应用到目标对象并创建新的代理对象的过程</li></ul><p><strong>使用场景：</strong>对于某些比较统一通用的功能（登录验证），在代码中加显得比较繁琐重复，并且和业务还没什么直接关系，不同位置写的代码一样，那么就可以考虑用AOP实现<br><strong>Spring AOP 实现步骤</strong></p><ol><li><p>添加 Spring AOP 框架支持</p></li><li><p>定义切面和切点</p></li><li><p>实现通知</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-aop --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 当前类是一个切面</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAspect</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个切点（设置拦截规则）</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.springaop.controller.UserController.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713065396786-32cb9e69-7b60-456f-8e53-9aacfcf82389.png#averageHue=%233f3938&clientId=uf10fcab4-4e6e-4&from=paste&id=ue9f50842&originHeight=434&originWidth=1539&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u6519d5a7-e783-4fd1-aeca-fbfd3c11057&title="></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 当前类是一个切面</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAspect</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个切点（设置拦截规则）</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.springaop.controller.UserController.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 pointcut 切点的前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBefore</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行前置通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置通知</span></span><br><span class="line">    <span class="meta">@After(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行后置通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回之后通知</span></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行返回之后通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抛出异常之后通知</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterThrowing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行抛出异常之后通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加环绕通知</span></span><br><span class="line">    <span class="meta">@Around(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知：前置方法&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行拦截方法</span></span><br><span class="line">            result = joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知：后置方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>利用AOP统计每个方法的执行时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加环绕通知</span></span><br><span class="line"><span class="meta">@Around(&quot;pointcut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> &#123;</span><br><span class="line">    <span class="comment">// spring 中的时间统计对象</span></span><br><span class="line">    <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stopWatch.start(); <span class="comment">// 统计方法的执行时间，开始计时</span></span><br><span class="line">        <span class="comment">// 执行目标方法，以及目标方法所对应的相应通知</span></span><br><span class="line">        result = joinPoint.proceed();</span><br><span class="line">        stopWatch.stop(); <span class="comment">// 统计方法的执行时间，停止计时</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(joinPoint.getSignature().getDeclaringTypeName() + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">            joinPoint.getSignature().getName() +</span><br><span class="line">            <span class="string">&quot;执行花费的时间：&quot;</span> + stopWatch.getTotalTimeMillis() + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现原理</strong><br>Spring AOP 是构建在<strong>动态代理</strong>基础上，因此 <strong>Spring 对 AOP 的支持局限于方法级别的拦截</strong><br>Spring AOP 动态代理实现：<br>默认情况下，实现了接⼝的类，使⽤ AOP 会基于 JDK ⽣成代理类，没有实现接⼝的类，会基于 CGLIB ⽣成代理类</p></li><li><p>JDK Proxy（JDK 动态代理）</p></li><li><p>CGLIB Proxy：默认情况下 Spring AOP 都会采用 CGLIB 来实现动态代理，因为效率高</p></li></ol><p>CGLIB 实现原理：通过继承代理对象来实现动态代理的（子类拥有父类的所有功能）<br>CGLIB 缺点：不能代理最终类（也就是被 final 修饰的类）<br><strong>JDK动态代理实现</strong><br>JDK动态代理依靠反射实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态代理：使⽤JDK提供的api（InvocationHandler、Proxy实现）</span></span><br><span class="line"><span class="comment">//此种⽅式实现，要求被代理类必须实现接⼝</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayServiceJDKInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//⽬标对象即就是被代理对象</span></span><br><span class="line"> <span class="keyword">private</span> Object target;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">PayServiceJDKInvocationHandler</span><span class="params">( Object target)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.target = target;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//proxy代理对象</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"> <span class="comment">//1.安全检查</span></span><br><span class="line"> System.out.println(<span class="string">&quot;安全检查&quot;</span>);</span><br><span class="line"> <span class="comment">//2.记录⽇志</span></span><br><span class="line"> System.out.println(<span class="string">&quot;记录⽇志&quot;</span>);</span><br><span class="line"> <span class="comment">//3.时间统计开始</span></span><br><span class="line"> System.out.println(<span class="string">&quot;记录开始时间&quot;</span>);</span><br><span class="line"> <span class="comment">//通过反射调⽤被代理类的⽅法</span></span><br><span class="line"> <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"> <span class="comment">//4.时间统计结束</span></span><br><span class="line"> System.out.println(<span class="string">&quot;记录结束时间&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> retVal;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> PayService target= <span class="keyword">new</span> <span class="title class_">AliPayService</span>();</span><br><span class="line"> <span class="comment">//⽅法调⽤处理器</span></span><br><span class="line"> <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PayServiceJDKInvocationHandler</span>(target);</span><br><span class="line"><span class="comment">//创建⼀个代理类：通过被代理类、被代理实现的接⼝、⽅法调⽤处理器来创建</span></span><br><span class="line"> <span class="type">PayService</span> <span class="variable">proxy</span> <span class="operator">=</span> (PayService) Proxy.newProxyInstance(</span><br><span class="line"> target.getClass().getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;PayService.class&#125;,handler);</span><br><span class="line"> proxy.pay();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CGLIB动态代理实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayServiceCGLIBInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"> <span class="comment">//被代理对象</span></span><br><span class="line"> <span class="keyword">private</span> Object target;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">PayServiceCGLIBInterceptor</span><span class="params">(Object target)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.target = target;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span><span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="comment">//1.安全检查</span></span><br><span class="line"> System.out.println(<span class="string">&quot;安全检查&quot;</span>);</span><br><span class="line"> <span class="comment">//2.记录⽇志</span></span><br><span class="line"> System.out.println(<span class="string">&quot;记录⽇志&quot;</span>);</span><br><span class="line"> <span class="comment">//3.时间统计开始</span></span><br><span class="line"> System.out.println(<span class="string">&quot;记录开始时间&quot;</span>);</span><br><span class="line">         <span class="comment">//通过cglib的代理⽅法调⽤</span></span><br><span class="line"> <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> methodProxy.invoke(target, args);</span><br><span class="line"> <span class="comment">//4.时间统计结束</span></span><br><span class="line">System.out.println(<span class="string">&quot;记录结束时间&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> PayService target= <span class="keyword">new</span> <span class="title class_">AliPayService</span>();</span><br><span class="line"> PayService proxy= (PayService) Enhancer.create(target.getClass(),</span><br><span class="line">                   <span class="keyword">new</span> <span class="title class_">PayServiceCGLIBInterceptor</span>(target));</span><br><span class="line">         proxy.pay();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK 和 CGLIB 实现的区别<br>JDK 实现，要求被代理类必须实现接口，之后是通过 InvocationHander 及 Proxy，在运行时动态的在内存中生成了代理对象，该代理对象是通过实现同样的接口实现（类似静态代理接口实现的方式），只是该代理类是在运行期时，动态的织入统一的业务逻辑字节码来完成的<br>CGLIB 实现，被代理类可以不实现接口，是通过继承被代理类，在运行时动态的生成代理类对象，这种方式实现方式效率高<br><a href="https://blog.csdn.net/m0_58761900/article/details/128999827">Spring AOP（AOP概念、组成、Spring AOP实现及实现原理）-CSDN博客</a></p><h2 id="Spring-AOP和AspectJ-AOP"><a href="#Spring-AOP和AspectJ-AOP" class="headerlink" title="Spring AOP和AspectJ AOP"></a>Spring AOP和AspectJ AOP</h2><ul><li>实现方式：SpringAOP是基于JDK动态代理和CGLIB的代理机制实现的，而AspectJ AOP则是基于字节码操纵实现的</li><li>织入的时机：Spring AOP在应用运行时织入，AspectJ AOP在编译时从字节码织入</li><li>适用范围：Spring AOP适用于IoC容器，AspectJ AOP适合Java任何应用程序</li></ul><h2 id="IoC怎么理解"><a href="#IoC怎么理解" class="headerlink" title="IoC怎么理解"></a>IoC怎么理解</h2><ol><li>Spring的IOC(Inversion of Control)是指将对对象的创建、组装、管理的责任交给容器，由容器负责对象之间的依赖关系。</li><li>在Spring中，IOC是通过依赖注入(Dependency Injection, DI)实现的，依赖注入是指容器通过自动或者手动的方式，将对象所依赖的其他对象或者资源注入到对象中，从而达到对象之间的松耦合。</li><li>通过使用IOC容器，可以实现对象之间的解耦，增加代码的灵活性和可维护性。同时IOC容器也提供了很多功能，例如对象的生命周期管理、AOP、事务管理等，可以大大减少开发者的工作量，提高开发效率</li><li>总的来说，Spring的IOC是通过依赖注入实现的，将对象之间的依赖关系交给容器进行管理，从而实现对象之间的松耦合和增强系统的可维护性和可扩展性</li></ol><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><blockquote><p>Bean 的生命周期是指在Spring框架中，Bean从创建到销毁的全过程</p></blockquote><p>Spring的Bean生命周期包括以下阶段</p><ol><li>实例化(Instantiation)：Spring容器根据配置文件或注解创建Bean的实例。</li><li>属性赋值(Populate Properties)：在这个阶段，Spring容器会将配置文件中指定的Bean属性或者引用注入到Bean实例中，通常是 @Autowired 注解的变量</li><li>初始化(Initalization)：在这个阶段，Spring容器会调用Bean的初始化方法(如果有)，并完成Bean的一些初始化操作，用户自定义的一些方法，比如initMethod、afterPropertiesSet方法 </li><li>使用(In Use)：在这个阶段，Bean可以被应用程序使用</li><li>销毁(Destruction)：在这个阶段，Spring容器会调用Bean的销毁方法(如果有)，并完成Bean的销毁操作</li></ol><p>这里会调用@PreDestroy注解标注的销毁前执行的方法，再进行真正的销毁，调用destory()方法完成销毁</p><h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p>Spring支持一下五种Bean作用域</p><ul><li>Singleton(单例)：在整个应用程序中，只存在一个Bean实例。默认情况下，Spring中的Bean都是单例的</li><li>Prototype(原型)：每次通过容器获取Bean时，都会创建一个新的Bean实例</li><li>Request：在一次HTTP请求中，Bean的实例是唯一的</li><li>Session：在一个HTTP Session中，Bean的实例是唯一的</li><li>application：在一个全局的HTTP Session中，Bean的实例是唯一的，后改为application</li></ul><p><a href="https://blog.csdn.net/lzb348110175/article/details/114387477">@Scope注解 详细讲解及示例-CSDN博客</a></p><h2 id="Bean是线程安全的吗"><a href="#Bean是线程安全的吗" class="headerlink" title="Bean是线程安全的吗"></a>Bean是线程安全的吗</h2><p><code>原型Bean</code>：每次获取都生成一个新的对象，所以是线程安全的（如果存在共享变量仍需注意）<br><code>单例Bean</code>：默认是线程不安全的，但是开发中大部分的Bean都是无状态（没有属性对象）的</p><blockquote><ul><li>如果Bean不包含实例变量，或者所有的实例变量是线程安全的，那就线程安全</li><li>如果Bean包含实例变量，并且存在实例变量是线程不安全的，那就线程不安全</li></ul></blockquote><p>实例变量就是类成员变量</p><p><code>Request、Session、Application 和 WebSocket</code>：</p><blockquote><ul><li>这些作用域主要适用于Web应用，其中Request和Session作用域的Bean在多线程环境下通常都是安全的，因为每个请求或会话有其独立的Bean实例。</li><li>Application作用域的Bean与单例Bean类似，因此需要注意其线程安全性。</li></ul></blockquote><p>要解决的话可以用ThreadLocal来解决，为每个线程保存一个副本变量，每个线程只操作自己的副本变量。</p><h2 id="Bean的储存"><a href="#Bean的储存" class="headerlink" title="Bean的储存"></a>Bean的储存</h2><p>bean对象最终存储在spring容器中，我们简单的、狭义上的spring容器，<code>在spring源码底层就是一个map集合</code>，这个map集合存储的key是当前bean的name，如果不指定，默认的是class类型首字母小写作为key，value是bean对象。存储bean的map在DefaultListableBeanFactory类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Map of bean definition objects, keyed by bean name. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure><p>当Spring容器扫描到Bean类时 , 会把这个类的描述信息, 以包名加类名的方式存到beanDefinitionMap 中,<br>Map&lt;String,BeanDefinition&gt; , 其中 String是Key , 默认是类名首字母小写 , BeanDefinition , 存的是类的定义(描述信息) , 我们通常叫BeanDefinition接口为 : bean的定义对象。</p><blockquote><p>Bean的定义信息和实例化好的Bean都是存储在不同的ConcurrentHashMap内，实例Bean时，会从BeanDefinition拿到Bean的定义信息，然后去实例化，最后放到对应的map中去。</p></blockquote><h2 id="Spring循环依赖-三级缓存"><a href="#Spring循环依赖-三级缓存" class="headerlink" title="Spring循环依赖&amp;三级缓存"></a>Spring循环依赖&amp;三级缓存</h2><p><strong>循环依赖</strong>：两个或者多个实例在依赖注入时产生了闭环依赖关系，导致实例无法正确创建<br><strong>三级缓存结构</strong></p><blockquote><ul><li>一级缓存：里面存储完整的Bean实例，这些实例可以直接被使用；</li><li>二级缓存：储存实例化以后但是属性值还没有设置的Bean实例，也就是没有进行依赖注入；可以避免重复创建动态代理；</li><li>三级缓存用来存放Bean工厂，主要用来生成Bean的实例，并且放到第二个缓存里面</li></ul></blockquote><p><strong>整个流程大致如下</strong>：</p><blockquote><ol><li>首先A完成初始化后会将A的工厂（用于生成A实例的方式）放入三级缓存中，并将A的早期引用放入二级缓存中去，此时需要依赖B，但是B没有创建出来</li><li>初始化B，做类似的操作，发现依赖A，从一级缓存至二级缓存依次寻找，在二级缓存中找到了A进行注入，将完整的B放入一级缓存中去</li><li>回到A的依赖注入过程，完成Bean的创建过程</li></ol></blockquote><p><strong>二级缓存能不能解决循环依赖（了解）</strong></p><blockquote><ol><li>二级缓存也可以，在创建了不完整的bean后放在二级缓存，如果Bean实现了AOP，那么在这个Bean被重复依赖的时候，得到这个Bean需要两次创建动态代理，因为你只有不完整的Bean，如果有三级缓存，那么你就可以把创建动态代理的Bean放入二级缓存，下次取不用再次创建动态代理。</li><li>一级缓存就可以解决循环依赖：无法解决在并发下获取不完整的Bean</li></ol></blockquote><p><strong>Spring有没有解决多例Bean的循环依赖</strong></p><blockquote><p>没有解决，因为每次请求都会创建新的实例（不会使用缓存进行储存，不缓存早期对象就无法解决循环依赖）</p><ul><li>使用Setter方法而不是构造函数</li><li>使用<code>@Lazy</code>注解，延迟初始化Bean</li></ul></blockquote><p><strong>Spring有没有解决构造函数的循环依赖</strong></p><blockquote><p>没有解决</p><ul><li>使用<code>@Lazy</code>注解，延迟初始化Bean</li></ul></blockquote><p>三级缓存的核心思想就是把Bean的实例化和依赖注入进行分离，采用一级缓存储存完整的Bean实例，二级缓存储存不完整的Bean实例，通过不完整的Bean实例作为突破口，从而解决循环依赖问题</p><h2 id="ApplicationContext-BeanFactory"><a href="#ApplicationContext-BeanFactory" class="headerlink" title="ApplicationContext &amp; BeanFactory"></a>ApplicationContext &amp; BeanFactory</h2><ul><li>Spring中的ApplicationContext和BeanFactory都是IOC容器，负责管理和创建Bean实例，但他们之间有一些区别<ol><li>ApplicationContext是BeanFactory的子接口，它提供了更多的功能，例如国际化、事件驱动等</li><li>ApplicationContext会在启动时预先实例化所有的单例Bean，而BeanFactory则是按需创建Bean</li><li>ApplicationContext支持Bean的自动装配、AOP等功能，而BeanFactory需要手动配置</li><li>ApplicationContext支持多种资源加载方式，例如XML、注解、属性文件等，而BeanFactory只支持XML格式的配置文件</li><li>ApplicationContext提供了更多的扩展点，例如BeanPostProcessor、ApplicationListener等，可以对Bean的生命周期和时间进行监听和处理</li></ol></li><li>如果需要使用Spring的更高级特性，例如AOP、国际化、事件驱动等，可以选择使用ApplicationContext；如果只需要简单地创建和管理Bean实例，可以选择使用BeanFactory</li></ul><h2 id="事务的传播级别"><a href="#事务的传播级别" class="headerlink" title="事务的传播级别"></a>事务的传播级别</h2><p><strong>事务传播行为（propagation behavior）指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何运行</strong></p><ol><li>REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新事务，这是默认传播级别</li><li>SUPPORTS：支持当前事务，如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续执行</li><li>MANDATORY：强制要求存在事务，如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常</li><li>REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则挂起当前事务</li><li>NOT_WUPPORTED：以非事务方式执行操作，如果当前存在事务，则挂起当前事务</li><li>NEVER：以非事务方式执行操作，如果当前存在事务，则抛出异常</li><li>NESTEDD：如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则执行与REQUIRED传播级别类似的操作</li></ol><h2 id="Spring的事务实现方式"><a href="#Spring的事务实现方式" class="headerlink" title="Spring的事务实现方式"></a>Spring的事务实现方式</h2><ul><li>Spring中事务的实现方式主要有两种：编程式事务和声明式事务<ol><li>编程式事务：是指通过编写代码来控制事务的提交和回滚。在编程式事务中，开发人员需要手动获取事务管理器，并在需要的地方进行事务的开启、提交和回滚等操作。编程式事务虽然灵活，但是代码侵入性较高，容易造成代码臃肿和难以维护，因此Spring推荐使用声明式事务来实现事务管理</li><li>声明式事务：是指通过配置来控制事务的提交和回滚。在声明式事务中，开发人员只需使用注解或XML配置文件来声明事务的属性和行为即可，具体的事务管理操作则由Spring框架自动完成</li></ol></li><li>声明式事务的优点是代码简洁，易于维护，而且可以灵活切换事务管理方式。Spring中主要通过AOP技术实现声明式事务，其底层实现依赖于DataSourceTransactionManager和TransactionInterceptor等组件</li></ul><h2 id="事务注解的本质和优点"><a href="#事务注解的本质和优点" class="headerlink" title="事务注解的本质和优点"></a>事务注解的本质和优点</h2><p>事务注解的本质是通过Spring AOP机制，在方法执行前后动态创建代理对象，将方法包装在一个事务中。事务注解在执行方法前开启一个事务，如果方法执行成功，则提交事务；如果方法执行过程中发生异常，则回滚事务。通过事务注解，我们可以在方法上标记事务的属性，方便灵活地控制事务的执行行为。同时，由于Spring框架在底层处理事务，因此可以避免一些常见的事务处理问题，比如并发访问、死锁等问题。事务注解的使用简单，可以提高开发效率，降低代码复杂度。</p><ol><li>简化代码：使用Spring框架观念里事务可以大大简化代码量，使代码更易于维护</li><li>降低耦合性：使用Spring框架管理事务可以将业务逻辑与事务处理分离，降低了耦合性</li><li>避免重复代码：使用Spring框架管理事务可以避免在每个业务方法中重复编写事务管理代码</li><li>支持声明式事务：Spring框架支持声明式事务，可以通过注解或XML配置来定义事务的属性和行为</li><li>支持多种事务管理器：Spring框架支持多种事务管理器，包括JDBC事务、Hibernate事务、JPA事务、JTA事务等</li><li>支持事务的回滚和提交：Spring框架可以自动管理事务的提交和回滚，从而保证事务的一致性和完整性</li><li>提高事务的性能：Spring框架使用缓存和批处理等技术来提高事务的性能和效率</li></ol><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{}和${}的区别"></a>#{}和${}的区别</h2><p><code>#&#123;&#125;:</code>MyBatis 会将 <code>#&#123;&#125;</code> 内的内容作为参数绑定到 SQL 语句中，当使用 <code>#&#123;&#125;</code> 时，MyBatis 会自动处理参数的类型（例如，使用 <code>PreparedStatement</code> 的 <code>setXxx</code> 方法）并对数据进行转义。<br><code>$&#123;&#125;:</code>当使用 <code>$&#123;&#125;</code> 时，MyBatis 不会对参数进行任何处理，会将其作为普通字符串直接拼接到 SQL 语句中。<br><code>为什么还需要$&#123;&#125;</code>：某些时候可能需要进行动态的选择表名或者列名；某些场景下需要动态生成SQL语句。</p><h2 id="如何进行分页查询"><a href="#如何进行分页查询" class="headerlink" title="如何进行分页查询"></a>如何进行分页查询</h2><p><code>JDBC</code></p><blockquote><p>通过使用 SQL 的 <code>LIMIT</code> 和 <code>OFFSET</code> 语句（或其他数据库特定的分页功能）进行分页</p></blockquote><p><code>MyBatis</code></p><blockquote><p>可以使用 MyBatis 的 <code>PageHelper</code> 插件来简化分页实现（添加拦截器）</p></blockquote><h2 id="Mybatis缓存机制"><a href="#Mybatis缓存机制" class="headerlink" title="Mybatis缓存机制"></a>Mybatis缓存机制</h2><p><code>SqlSession</code>：是 MyBatis 框架中的一个核心接口，它用于执行 SQL 语句并管理与数据库的交互，相当于一次和数据库的连接。<br><strong>一级缓存</strong></p><blockquote><p><code>定义：</code>一级缓存是 SqlSession 级别的缓存，默认开启。每个 SqlSession 有自己的一级缓存，保存了该 SqlSession 中执行的 SELECT 查询结果<br><code>原理：</code>第一次执行查询会把结果放入一级缓存，再次执行相同的查询会先去缓存中获取结果<br><code>局限性：</code>在同一个 SqlSession 中缓存才会生效</p></blockquote><p>二级缓存</p><blockquote><p><code>定义：</code>跨 SqlSession 共享的缓存，可以在多个 SqlSession 之间共享。<br><code>原理：</code>执行查询时先从二级缓存中获取，否则从数据库中查询放入缓存中</p></blockquote><p>注意事项</p><blockquote><ul><li>使用二级缓存时，某些操作会导致缓存失效（INSERT,UPDATE,DELETE）</li><li>二级缓存需要在存储对象时进行序列化，因此需要确保存入缓存的对象是可序列化的。</li><li>合理地使用缓存可以显著提高性能，但过度依赖缓存也可能导致数据的一致性问题，因此要根据具体场景进行优化。</li></ul></blockquote><h2 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h2><p>@Transactional 实质是使用了 JDBC 的事务来进行事务控制的<br>@Transactional 基于 Spring 的动态代理的机制</p><blockquote><p>@Transactional 实现原理（了解）：</p><ol><li>事务开始时，通过AOP机制，生成一个代理connection对象，<br>并将其放入 DataSource 实例的某个与 DataSourceTransactionManager 相关的某处容器中。<br>在接下来的整个事务中，客户代码都应该使用该 connection 连接数据库，<br>执行所有数据库命令。<br>[不使用该 connection 连接数据库执行的数据库命令，在本事务回滚的时候得不到回滚]<br>  （物理连接 connection 逻辑上新建一个会话session；<br>DataSource 与 TransactionManager 配置相同的数据源）</li><li>事务结束时，回滚在第1步骤中得到的代理 connection 对象上执行的数据库命令，<br>然后关闭该代理 connection 对象。<br>  （事务结束后，回滚操作不会对已执行完毕的SQL操作命令起作用）</li></ol></blockquote><p>@Transactional失效的场景</p><ol><li>非public的方法。原因就是在为该Bean寻找匹配的Advisor时，如果是非public方法加了该注解会忽视掉。</li><li>使用final修饰的方法在使用CGLIB动态代理时。原因就是CGLIB并不会代理final方法。</li><li>类内部的非事务方法调用事务方法。原因就是，事务方法的调用是通过this来完成的，跳过了代理对象。（必须代理对象进行调用才能生效）</li><li>自己捕获了异常，没有抛出产生的异常，导致事务操作不会进行回滚。</li></ol><p><a href="https://blog.csdn.net/jiangyu1013/article/details/84397366">@Transactional 详解-CSDN博客</a></p><h2 id="过滤器和拦截器的区别"><a href="#过滤器和拦截器的区别" class="headerlink" title="过滤器和拦截器的区别"></a>过滤器和拦截器的区别</h2><p><code>过滤器</code></p><blockquote><p>调用层次相对于更加底层一些，可以在请求到达<code>Servlet</code>之前处理请求<br>会影响所有的请求，并且不会影响业务逻辑<br>实现 <code>javax.servlet.Filter</code> 接口，重写 <code>doFilter()</code> 方法</p></blockquote><p><code>拦截器</code></p><blockquote><p>更加偏向于在方法层面调用，对于某些特定业务逻辑方法才会起作用<br>通常实现特定框架的接口，如 Spring 的 <code>HandlerInterceptor</code></p></blockquote><p><code>总结</code></p><blockquote><p><strong>过滤器</strong>：主要用于处理请求和响应的通用功能；适用于 Web 层的预处理和后处理。<br><strong>拦截器</strong>：更适合对具体业务逻辑进行监控和处理，往往同业务逻辑层结合更紧密。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2024/03/20/JVM/"/>
      <url>/2024/03/20/JVM/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM"></a>什么是JVM</h3><p>Java虚拟机，它是一个中间平台，对于任何可以编译为符合规范的字节码文件的语言来说，都可以通过此平台翻译为不同平台的机器指令</p><h3 id="JVM的内存区域"><a href="#JVM的内存区域" class="headerlink" title="JVM的内存区域"></a>JVM的内存区域</h3><ul><li><p>程序计数器</p><blockquote><p>记录当前线程执行字节码文件的执行位置</p></blockquote></li><li><p>虚拟机栈</p><blockquote><p>存放方法执行时产生的栈帧，栈帧中用于存储局部变量表、操作数栈、动态链表、方法出口等信息</p></blockquote></li><li><p>本地方法栈</p><blockquote><p>虚拟机栈为虚拟机执行java方法服务，而本地方法栈为虚拟机执行Native方法服务</p></blockquote></li><li><p>堆</p><blockquote><p>存在的唯一目的就是存放对象实例，几乎所有的对象实例都在这里进行分配内存<br>符合以下条件的存放在堆中：是热点代码，能逃逸，开启标量替换<br><code>逃逸</code>：对象被外部方法调用或者被外部线程访问<br><code>标量替换</code>：如果⼀个数据是基本数据类型，不可拆分，它就被称之为标量。把⼀个 Java 对象拆散，将其⽤到的成员变量恢复为原始类型来访问，这个过程就称为标量替换<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713237977893-73ccdcbf-44aa-4407-bc18-1f33c16324c9.png#averageHue=%23bbd6f5&clientId=u6c303ffd-2b97-4&from=paste&height=333&id=u4bc8df79&originHeight=500&originWidth=825&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=110230&status=done&style=none&taskId=ucf46b2b9-3568-46da-ad90-0c59d1bbf6e&title=&width=550" alt="image.png"></p></blockquote></li><li><p>方法区</p><blockquote><p>此区域是用来存储类的信息(类的名称、字段信息、方法信息)、静态变量、常量以及编译器编译后的代码</p></blockquote></li></ul><p><code>前三个线程私有，后两个线程共享</code></p><h3 id="可达性算法分析"><a href="#可达性算法分析" class="headerlink" title="可达性算法分析"></a>可达性算法分析</h3><p>垃圾回收时，由根节点进行链路分析来判断对象是否可达，如果不可达就是垃圾<br>另外一种算法：引用计数法，通过标记是否存在引用来判断是否垃圾，但是无法解决循环引用对象问题<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713236406325-184a77b1-8a06-4eae-9b39-299decec024a.png#averageHue=%23a7dae7&clientId=u6c303ffd-2b97-4&from=paste&height=242&id=uec0c781e&originHeight=363&originWidth=773&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=139461&status=done&style=none&taskId=ufba4c2bf-6b5c-4f30-9b0c-bfec45e25f7&title=&width=515.3333333333334" alt="image.png"></p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713236522968-a7a00c4b-5fc2-4c59-b979-569363fad0d2.png#averageHue=%23aeb2b0&clientId=u6c303ffd-2b97-4&from=paste&height=328&id=uaf90a356&originHeight=604&originWidth=956&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=344179&status=done&style=none&taskId=ud850b7d3-725b-4735-8c32-dd2cfaffd38&title=&width=519.3333435058594" alt="image.png"></p><ol><li>复制算法：将内存分为两部分，对其中一部分进行垃圾回收时，将可用对象复制到另外一部分，空间利用率不高</li><li>标记清除算法：通过可达性分析去标记，再把垃圾对象进行清除，空间会变得碎片化</li><li>标记整理算法：同样可达性分析，在清除时把可用对象复制到一端，效率比较低</li></ol><h3 id="分代模型"><a href="#分代模型" class="headerlink" title="分代模型"></a>分代模型</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713236894922-63e4adab-21ea-4b97-a66d-f842879a7a3c.png#averageHue=%23d9e7c0&clientId=u6c303ffd-2b97-4&from=paste&height=309&id=uc22806a4&originHeight=464&originWidth=839&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=91032&status=done&style=none&taskId=ud825b377-f8c1-43cb-881a-79ed86d8ac5&title=&width=559.3333333333334" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713238336438-6618e98f-d414-4962-ac97-d4bf8a5e50e1.png#averageHue=%23f2f1f2&clientId=u6c303ffd-2b97-4&from=paste&height=147&id=u7dc2f4eb&originHeight=220&originWidth=719&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=29014&status=done&style=none&taskId=uc1a368df-02c1-499a-b3e4-575f9d626d5&title=&width=479.3333333333333" alt="image.png"><br>新生代：消亡速度比较快，使用复制算法<br>老年代：</p><ul><li>长期存活的对象进入老年代（15次）</li><li>大对象直接进入老年代</li><li>新生代垃圾收集后仍有大量对象存活，把无法容纳的对象直接送入老年代</li></ul><p>，使用两种算法之一</p><h3 id="CMS垃圾回收器"><a href="#CMS垃圾回收器" class="headerlink" title="CMS垃圾回收器"></a>CMS垃圾回收器</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713237053994-9d98a40c-db98-486c-b1d4-5d6794c07ed0.png#averageHue=%23f2f1f2&clientId=u6c303ffd-2b97-4&from=paste&height=360&id=ud4a08c56&originHeight=540&originWidth=701&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=117384&status=done&style=none&taskId=ud7e833bf-aa28-4ddc-9b48-bf2e78bb585&title=&width=467.3333333333333" alt="image.png"><br>两个大阶段：可达性分析、垃圾清理<br>可达性分析：</p><ol><li>初始标记<code>STW</code>，标记和根节点相连的对象</li><li>并发标记，标记与根节点间接相连的对象</li><li>重新标记<code>STW</code>，处理漏标问题</li></ol><p>垃圾清理：清理过程为并发清理<br><strong>问题</strong>：</p><ul><li>并发清理意味着清理的同时会产生新的垃圾，这些垃圾只能在下一次清理</li><li>业务线程和回收线程同时跑，对CPU比较敏感</li><li>采用标记清除算法，空间碎片化</li></ul><h3 id="G1垃圾回收器"><a href="#G1垃圾回收器" class="headerlink" title="G1垃圾回收器"></a>G1垃圾回收器</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713237579359-dc611c65-8afc-4ccf-8086-cbbb5444a902.png#averageHue=%23f3f2f3&clientId=u6c303ffd-2b97-4&from=paste&height=391&id=u5c2f8fa0&originHeight=587&originWidth=805&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=148583&status=done&style=none&taskId=uacb6cc71-a108-4c2b-904c-0f3b4b28092&title=&width=536.6666666666666" alt="image.png"></p><blockquote><p>对内存进行区域划分，筛选出垃圾最多的区域进行清理，减少垃圾回收器的暂停时间</p></blockquote><p>特点：</p><ul><li>空间整合，优先回收垃圾占比最高的区域</li><li>使用多个GC线程（GC线程），可预测停顿（给定停顿时间，根据前面分区和线程并发尽可能的减少暂停时间）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713250633953-4b593873-88f0-447a-a967-b9881f953ece.png#averageHue=%23f2f1f2&clientId=uac086589-dfec-4&from=paste&height=267&id=ub0dae7b7&originHeight=400&originWidth=1020&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=120259&status=done&style=none&taskId=u9c2e53e9-621f-426d-9510-a7d518b35ff&title=&width=680" alt="image.png"></p><h3 id="内存溢出和泄露"><a href="#内存溢出和泄露" class="headerlink" title="内存溢出和泄露"></a>内存溢出和泄露</h3><p><strong>内存溢出</strong>（OOM-OutOfMemory）是指JVM可用内存不足。<br>JVM运行需要使用的内存超出最大可用值，会导致JVM出现异常<br>常见的OOM有以下几种。</p><ul><li>栈溢出（循环递归）</li><li>堆溢出（定义一个超过堆内存大小的数组）</li><li>方法区溢出</li></ul><p><strong>内存泄漏</strong>：不再使用的对象却继续占用内存，没有释放，这就叫内存泄漏</p><ul><li>静态集合类，其生命周期和JVM一致</li><li>单例模式，和静态集合类类似</li><li>连接未释放，数据库连接、IO连接等</li><li>ThreadLocal使用不当，未及时释放</li></ul><p><strong>与内存溢出的关系</strong><br>如果存在严重的内存泄漏问题，随着时间的推移，则必然会引起内存溢出。<br>内存泄漏一般是资源管理问题和程序BUG，内存溢出则是内存空间不足和内存泄漏的最终结果。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>储存布局为：对象头、实例数据、对齐填充<br><code>对象头</code>：</p><ul><li>第一部分存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等；</li><li>第二部分指向它是那一个类所创建的</li><li>如果是数组则包括用于记录数组长度的数据</li></ul><p><code>实例数据</code>：存放类的数据信息，父类的信息，对象字段属性信息<br><code>对齐填充</code>：占位填充符<br><a href="https://www.cnblogs.com/jajian/p/13681781.html">Java对象的内存布局 - JaJian - 博客园</a></p><h3 id="Java8默认垃圾回收器"><a href="#Java8默认垃圾回收器" class="headerlink" title="Java8默认垃圾回收器"></a>Java8默认垃圾回收器</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713239833891-47b2cba5-8365-4648-891a-fc0ff685dc61.png#averageHue=%2359d677&clientId=u6c303ffd-2b97-4&from=paste&height=326&id=u1b63bbab&originHeight=489&originWidth=1094&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=155269&status=done&style=none&taskId=u421707e9-bad6-4796-9c3a-c289f63bdd8&title=&width=729.3333333333334" alt="image.png"></p><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1713250171906-ef6f23ba-8928-46c1-8d60-525be01f2c1b.png#averageHue=%23fefdfd&clientId=uac086589-dfec-4&from=paste&height=256&id=ub4154b2f&originHeight=384&originWidth=649&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=64739&status=done&style=none&taskId=udc0bde1c-3897-4b8c-b760-e00b8b28d68&title=&width=432.6666666666667" alt="image.png"><br>Bootstrap：加载Java的核心类库<br>Extension：加载Java api的扩展<br>Application：加载程序员编写的一些代码以及一些第三方类库<br>Custom：用户自定义加载器<br><code>定义：</code>除了顶层的类加载器，其他的加载器在加载某个类时，都会按照优先级向上询问是否已经加载了，没有的话会依次尝试进行加载。</p><blockquote><p>为什么有此机制：</p><ul><li>带有优先级的加载过程可以避免类的重复加载</li><li>可以保证一些核心api不会被随意替换（object），保证Java程序稳定运行</li></ul></blockquote><p><code>打破机制：</code>可以通过重写ClassLoader 类中的loadClass方法，根据全限定名来用Custom加载器来加载；或者连接数据库时，出现了Bootstrap 委托Application进行加载的情况。<br><code>三次破坏（**略**）：</code></p><blockquote><ol><li>引入双亲委派模型之后的代码兼容</li><li>加载一些SPI服务代码</li><li>用户需求模块热部署等</li></ol></blockquote><p><a href="https://www.cnblogs.com/crazymakercircle/p/15554725.html">面试必备：什么时候要打破双亲委派机制？什么是双亲委派？ （图解+秒懂+史上最全） - 疯狂创客圈 - 博客园</a></p><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><ol><li>加载类的字节码文件将其转化为某种静态储存结构储存在方法区，并在堆中生成一个便于用户调用的<code>java.lang.Class</code>类型的对象</li><li>验证，验证Class文件的合法性</li><li>准备，为类变量进行内存分配和初始化零值（实例变量不会初始化）</li><li>解析，替换常量池中的符号引用为直接引用，让其有实际的引用指向</li><li>初始化静态代码块和静态变量</li></ol><p><a href="https://www.bilibili.com/video/BV14U4y1L75q/?spm_id_from=333.788&vd_source=76d07b2ac50fbbf69b312cadf6d1d849">【JVM】Java类加载机制这块算是玩明白了_哔哩哔哩_bilibili</a><br><a href="https://blog.csdn.net/qq_48508278/article/details/122929631">类加载机制(整个过程详解)-CSDN博客</a></p><h3 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h3><ol><li>首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用对应的类是否已经被加载，解析和初始化过。如果没有，先要进行类加载过程。</li><li>为对象分配内存：</li></ol><ul><li>如果内存空间是<code>规整</code>的，则通过<code>**指针碰撞**</code>来为对象分配内存，未被使用和已被使用堆内存分开来放置在两侧，中间通过一个指针来作为分界的指示器，分配内存时只需将分界指针往未使用内存空间移动出对象所需空间即可。</li><li>如果内存空间是<code>不规整</code>的，则通过<code>**空闲列表**</code>来分配内存，虚拟机维护一个列表来记录哪些内存空间是未使用的，分配时在列表中找一个足够大的空间划分给该对象。</li></ul><ol start="3"><li>并初始化内存的变量值为零值</li><li>设置对象头，设置类型指针指向方法区的类型元数据，java虚拟机通过这个指针可以知道这个对象是哪个类的实例。</li><li>执行构造方法</li></ol><p><a href="https://zhuanlan.zhihu.com/p/240458901">安全验证 - 知乎</a></p><h3 id="JVM常见参数设置（了解）"><a href="#JVM常见参数设置（了解）" class="headerlink" title="JVM常见参数设置（了解）"></a>JVM常见参数设置（了解）</h3><ul><li>-Xms：初始堆大小</li><li>-Xmx：最大堆大小</li><li>-Xss：每个线程堆栈大小</li><li>-XX：垃圾回收器设置</li></ul><h3 id="对象引用类型"><a href="#对象引用类型" class="headerlink" title="对象引用类型"></a>对象引用类型</h3><ul><li>强引用：即使内存不够，也不会回收（常用的）</li><li>软引用：只在内存不够时才回收</li><li>弱引用：触发GC时，就回收</li><li>虚引用：基本等于没有，连根据引用获取对象都做不到，用于垃圾回收时的通知</li></ul><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p>用于线程回收前最后执行的函数</p><h3 id="垃圾收集方式"><a href="#垃圾收集方式" class="headerlink" title="垃圾收集方式"></a>垃圾收集方式</h3><ul><li>Minor&#x2F;Young GC：新生代的垃圾收集（Eden区没有空间时触发）</li><li>Major&#x2F;Old GC：老年代的垃圾收集，只有CMS</li><li>Mixed GC：收集整个新生代和部分老年代的垃圾，只有G1</li><li>Full GC：收集整个堆和方法区的垃圾<ul><li>新生代收集之前老年代内存不足</li><li>新生代收集之后老年代内存空间不足</li><li>老年代内存空间不足</li><li>System.gc()命令触发</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL八股文（完善中）</title>
      <link href="/2024/03/20/MySql/"/>
      <url>/2024/03/20/MySql/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h3><p>索引是数据库中的一种数据结构，包含了对数据表所有记录的引用，可以帮助我们快速查找、更新数据，类似于书里面的目录。<br>优点：</p><ul><li>可以大大提高检索效率</li><li>提高系统的性能</li><li>通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p>缺点：</p><ul><li>创建和维护索引需要花费时间</li><li>索引需要真实物理空间来储存</li><li>数据进行修改时，索引也要进行改变</li></ul><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><ul><li>普通索引：是MySQL中的基本索引类型，允许在定义索引的列中插入重复值和空值</li><li>唯一索引：要求索引列的值必须唯一，但允许有空值。</li><li>主键索引：是一种特殊的唯一索引，在唯一索引上增加不为空约束，不允许有空值</li><li>组合索引：则列值的组合必须唯一</li><li>全文索引：全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值</li><li>空间索引：创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MyISAM的表中创建</li></ul><h3 id="索引的底层实现"><a href="#索引的底层实现" class="headerlink" title="索引的底层实现"></a>索引的底层实现</h3><ul><li>Hash索引：为索引列计算哈希码，将哈希码存储在索引中，以及指向每个数据的指针<ul><li>等值查询速度很快，但是不支持范围查找</li><li>大量键重复时效率会很低，哈希碰撞</li></ul></li><li>二叉查找树：可以解决范围查找问题，但是极端情况会退化成链表，无法自己调整</li><li>红黑树：如果插入的数据是顺序插入时，树的高度随着数据量增加而增加</li><li>AVL树：可以范围查找，高度可以调整，但是调整成本比较高，而且一个节点存一个数据，会增加磁盘的IO</li><li>B-Tree索引：一个节点可以存多个数据<ul><li>树的高度相对于B+树更高一些</li><li>节点存的是数据，所能存的数据就更少一些 </li><li>IO次数高（通常高度更高）</li></ul></li><li>B+Tree索引：在B-Tree索引改进，数据都在叶子结点，叶子结点依据关键字大小进行顺序连接<ul><li>B+树存储的是索引（地址）</li><li>B+树的叶子节点是数据阶段用了一个链表串联起来，便于范围查找</li><li>一个节点存着大量索引，降低树的高度，减少I&#x2F;O</li><li>一颗B+树能存两千万行数据</li></ul></li></ul><p><a href="https://zhuanlan.zhihu.com/p/113917726">深入理解 Mysql 索引底层原理</a></p><h3 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h3><p>主键索引叶子节点的值存储的就是MySQL的数据行，普通索引的叶子节点的值存储的是主键值，这是了解聚簇索引和非聚簇索引的前提</p><ul><li><p>聚簇索引</p><blockquote><p>找到了索引就找到了需要的数据，那么这个索引就是聚簇索引，所以主键就是聚簇索引，修改聚簇索引其实就是修改主键</p></blockquote></li><li><p>非聚簇索引</p><blockquote><p>索引的存储和数据的存储是分离的，也就是说找到了索引但没找到数据，需要根据索引上的值(主键)再次回表查询,非聚簇索引也叫做辅助索引</p></blockquote></li><li><p>非聚簇索引不一定会回表查询</p><blockquote><p>如果查询语句的所有的查询字段都命中了索引，就不用进行回表查询了。</p></blockquote></li></ul><p><a href="https://zhuanlan.zhihu.com/p/142139541">给我一分钟，让你彻底明白MySQL聚簇索引和非聚簇索引</a></p><h3 id="怎么判断要不要加索引"><a href="#怎么判断要不要加索引" class="headerlink" title="怎么判断要不要加索引"></a>怎么判断要不要加索引</h3><p>考虑加的一些情况：</p><blockquote><ol><li>根据数据特性，如果是唯一的，可以加唯一索引</li><li>对频繁排序和分组的列进行索引，多列就组合索引</li></ol></blockquote><p>不考虑加索引：</p><blockquote><ol><li>数据量小的表不用索引</li><li>索引的列应该尽量的少</li><li>值的范围较少的列上不要添加</li><li>经常更新的表少加索引</li></ol></blockquote><h3 id="创建了索引，一定走索引吗"><a href="#创建了索引，一定走索引吗" class="headerlink" title="创建了索引，一定走索引吗"></a>创建了索引，一定走索引吗</h3><ol><li>首先我们要知道，索引可能会有多个，我们在进行查询时数据库会进行优化选择最佳的索引，这个时候就会存在某些索引用不上的情况</li><li>再有就是因为某些原因导致索引失效，比如在SQL语句中使用了不恰当的语句顺序（！&#x3D;，模糊查询等），或者说使用组合索引的时候不符合最左匹配原则，导致索引无法使用</li></ol><h3 id="如何判断索引是否生效，越多越好？"><a href="#如何判断索引是否生效，越多越好？" class="headerlink" title="如何判断索引是否生效，越多越好？"></a>如何判断索引是否生效，越多越好？</h3><p>可以使用EXPLAIN语句查看索引是否正在使用</p><blockquote><p>有一些关键字需要进行注意：</p><ul><li><code>type</code>：判断查询是否高效的依据，最差的就是全表扫描<code>ALL</code>，其他的多少都会用到索引</li><li><code>possible_keys</code>：表示查询时，可以用到的索引</li><li><code>key</code>：查询时真正用到的索引</li><li><code>key_len</code>：表示使用的索引字节数，和字段的类型相关，可以用于组合索引时看是否使用了所有字段</li><li><code>rows</code>：MYSQL事先估计需要查询的记录条数</li></ul></blockquote><p><a href="https://blog.csdn.net/gaochenglong1/article/details/106123041">MySQL 性能优化神器 Explain 使用教程_explain 分页-CSDN博客</a><br>不是越多越好，如果表进行经常性的更新操作，同时的也会更新索引，性能降低。</p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>使用多个字段建立的索引 &#x3D; 组合索引<br>为什么要注意顺序：</p><blockquote><p>联合索引依次按照建立索引的字段顺序进行排序，查询也要按照这个顺序来进行，所以建议把经常使用的字段放前面<br><a href="https://blog.csdn.net/zjjcchina/article/details/132421529">联合索引是什么?为什么需要注意联合索引中的顺序?-CSDN博客</a></p></blockquote><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>最左优先，建立索引时把最常用的一列放最左边<br>mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D;1 and b&#x3D;2 and c &gt;3 and d&#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整<br>&#x3D;和in可以乱序，比如a &#x3D; 1 and b &#x3D; 2 and c&#x3D; 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p><strong>关键词：“索引优化”</strong><br>减少回表次数，InnoDB只适用于二级索引<br>没有索引下推时，查到了数据会查询整条数据返回给MySQL服务器来判断是否满足条件；有索引下推后，会使用索引中的列来判断是否满足部分条件，满足才会回表查询，否则过滤。<br><a href="https://juejin.cn/post/7005794550862053412">五分钟搞懂MySQL索引下推 - 掘金</a><br>在 people_table中有一个二级索引(zipcode，lastname，address)，查询是SELECT*FROM peopleWHERE zipcode&#x3D;’95054’ AND lastname LIKE “%etrunia%’ AND address LIKE “%Main Street%”</p><ul><li>如果没有使用索引下推技术，则MySQL会通过zipcode&#x3D;’95054’从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastnameLIKE‘%etrunia%’and address LIKE”%MainStreet%’来判断数据是否符合条件</li><li>如果使用了索引下推技术，则MYSQL首先会返回符合zipcode&#x3D;’95054’的索引，然后根据lastnameLIKE”%etrunia%’andaddressLIKE”%MainStreet%’来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。</li></ul><h3 id="创建索引的方式"><a href="#创建索引的方式" class="headerlink" title="创建索引的方式"></a>创建索引的方式</h3><ol><li>创建表时进行创建</li><li>ALTER TABLE进行增加索引</li><li>CREATE INDEX创建索引</li></ol><h3 id="使用索引一定能提高查询的性能吗"><a href="#使用索引一定能提高查询的性能吗" class="headerlink" title="使用索引一定能提高查询的性能吗"></a>使用索引一定能提高查询的性能吗</h3><p>不一定，在进行更新操作时，相应的索引也要进行IO处理，这样反而会变慢<br>使用情况：</p><ul><li>基于一个范围的检索，查询结果集小于表中记录数据的30%</li><li>基于非唯一性索引的检索</li></ul><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ul><li>使用!&#x3D;或者&lt;&gt;</li><li>模糊查询放在匹配字段前</li><li>NOT IN、NOT EXISTS</li><li>OR连接的不是同一个字段</li><li>对条件进行加减乘除的操作</li><li>使用了函数</li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>将SQL代码拼接到服务器执行的SQL语句中，是的SQL语句达到攻击者想要的结果</p><ol><li>对具有固定格式的参数进行严格的检验</li><li>SQL的预编译，将参数填充到占位符上<blockquote><p>为什么可以防止SQL注入：<code>Statement</code>会发生注入是因为语句结构发生了变化，比如账号密码登录时，<code>select*from tablename where username=&#39;&#39;or true or&#39;&#39; and password=&#39;&#39;</code>，SQL语句的逻辑变成了或的逻辑关系；而<code>PrepareStatement</code>会进行预编译，参数始终是参数，无法成为语句的一部分</p></blockquote></li></ol><h3 id="如何将一张表的部分数据更新到另一张表？（略）"><a href="#如何将一张表的部分数据更新到另一张表？（略）" class="headerlink" title="如何将一张表的部分数据更新到另一张表？（略）"></a>如何将一张表的部分数据更新到另一张表？（略）</h3><p>可以采用关联更新的方式，将一张表的部分数据，更新到另一张表内。参考如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update b set b.col=a.col from a,b where a.id=b.id;</span><br><span class="line">update b set col=a.col from b inner join a on a.id=b.id;</span><br><span class="line">update b set b.col=a.col from b left Join a on b.id = a.id;</span><br></pre></td></tr></table></figure><h3 id="WHERE和HAVING有什么区别？"><a href="#WHERE和HAVING有什么区别？" class="headerlink" title="WHERE和HAVING有什么区别？"></a>WHERE和HAVING有什么区别？</h3><ol><li>WHERE是一个约束声明，使用WHERE约束来自数据库的数据，WHERE是在<code>结果返回之前</code>起作用的，WHERE中<code>不能使用</code>聚合函数。</li><li>HAVING是一个过滤声明，是在查询<code>返回结果集以后</code>对查询结果进行的过滤操作，在HAVING中<code>可以使用</code>聚合函数。另一方面，HAVING子句中不能使用除了分组字段和聚合函数之外的其他字段。</li><li>从性能的角度来说，HAVING子句中如果使用了分组字段作为过滤条件，应该替换成WHERE子句。因为WHERE可以在执行分组操作和计算聚合函数之前过滤掉不需要的数据，性能会更好。（<strong>了解即可</strong>）</li></ol><h3 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h3><ol><li>列不可再分，存储的数据具有不可再分特性</li><li>每一行数据可以唯一区分，比如添加主键约束，非主键列完全依赖主键而不是依赖其一部分</li><li>非主属性不能依赖于表的其它非主属性，只能依赖主键</li></ol><h3 id="InnoDB和MyISAM的区别"><a href="#InnoDB和MyISAM的区别" class="headerlink" title="InnoDB和MyISAM的区别"></a>InnoDB和MyISAM的区别</h3><ul><li>InnoDB支持事务…</li><li>InnoDB支持行级锁和表级锁…</li><li>InnoDB不支持全文搜索</li><li>InnoDB不保存表的行数</li><li>InnoDB支持外键</li></ul><h3 id="什么是存储过程"><a href="#什么是存储过程" class="headerlink" title="什么是存储过程"></a>什么是存储过程</h3><p>存储过程是一些预编译的SQL语句，类似于一个写好的方法</p><ul><li>实现效率高，在一定程度上保证数据安全</li><li>调试麻烦</li><li>代码可移植性低</li></ul><h3 id="mysql执行查询的过程"><a href="#mysql执行查询的过程" class="headerlink" title="mysql执行查询的过程"></a>mysql执行查询的过程</h3><ol><li>进行权限验证</li><li>查缓存</li><li>SQL语句分析</li><li>优化，是否使用索引</li><li>执行器执行语句</li></ol><p> 更新语句执行会复杂一点。需要检查表是否有排它锁，写 binlog，刷盘，是否执行 commit。</p><h3 id="in和exists关键字"><a href="#in和exists关键字" class="headerlink" title="in和exists关键字"></a>in和exists关键字</h3><blockquote><p><a href="https://so.csdn.net/so/search?q=%E5%AD%90%E6%9F%A5%E8%AF%A2&spm=1001.2101.3001.7020">子查询</a>表小的用in，子查询表大的用exists。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 where <span class="title function_">exists</span> <span class="params">(select <span class="number">1</span> from t2 where t1.id = t2.id)</span>;</span><br><span class="line">select * from t1 where id <span class="title function_">in</span> <span class="params">(select id from t2)</span>;</span><br></pre></td></tr></table></figure><p>exists子句会对外表（即t1）用loop逐条记录查询，每次查询都会查看exists中的select语句，如果select子句返回记录行（无论返回记录行是多少，只要能返回），exists就会返回true，则外表中的当前记录就会被检索出来；如果select子句没有返回记录行，exists就会返回false，则外表中的当前记录就会被丢弃。——exist子句循环每次取出外表中的一条记录用来执行exists中的语句查内表，是先查外表，再查内表（相关子查询）。<br>in查询相当于多个or条件的叠加。in子句需要先将子查询的记录全部查出来。注意in子句中的子查询返回的结果集必须只有一个字段。假设子查询返回的结果集有m条记录，在进行m次查询。——in子句是先执行in中的子句查出来内表的结果，然后外表针对内表查出来的结果一个个遍历匹配。即先查内表，再查外表（不相关子查询）。</p><h3 id="视图是什么"><a href="#视图是什么" class="headerlink" title="视图是什么"></a>视图是什么</h3><p><strong>视图</strong>（View）是数据库中的一种虚拟表，它基于SQL查询的结果集，并将其表示为一个表格。与实际存储数据的表不同，视图不存储数据，存放SQL·查询定义，动态地生成结果集，每次访问时都会重新计算。  </p><h3 id="触发器是什么"><a href="#触发器是什么" class="headerlink" title="触发器是什么"></a>触发器是什么</h3><p><strong>触发器</strong>（Trigger）是数据库中的一种特殊的存储过程，它在指定的事件发生时自动执行。触发器通常用于在对数据库表进行 <strong>INSERT</strong>、<strong>UPDATE</strong> 或 <strong>DELETE</strong> 操作时，自动执行某些逻辑，例如数据验证、日志记录、复杂的约束等。  </p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务和其特性"><a href="#事务和其特性" class="headerlink" title="事务和其特性"></a>事务和其特性</h3><p>事务就是多条SQL语句，这些操作要么都成功，要么都失败。</p><ul><li>原子性：整个事务是原子的，即成功失败都是一体的<ul><li>利用undo log实现事务的回滚</li></ul></li><li>一致性：不管事务执行成功与否，保证数据的一致性<ul><li>保证其它三个特性的完成</li></ul></li><li>隔离性：事务在执行时不受其它事务的干扰<ul><li>(一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性。</li><li>(一个事务)写操作对(另一个事务)读操作的影响：MVCC保证隔离性。</li></ul></li><li>持久性：事务的操作结果可以持久化到数据库中<ul><li>利用Buffer Pool来进行和读取，结合redo log实现持久化</li></ul></li></ul><h3 id="谈谈MySQL的事务隔离级别"><a href="#谈谈MySQL的事务隔离级别" class="headerlink" title="谈谈MySQL的事务隔离级别"></a>谈谈MySQL的事务隔离级别</h3><ul><li>读未提交（READ UNCOMMITTED）<ul><li>所有事务都可以看到其他未提交事务的执行结果，脏读</li></ul></li><li>读提交 （READ COMMITTED）<ul><li>一个事务只能看到已经提交了的事务的改变，不可重复读</li></ul></li><li>可重复读 （REPEATABLE READ）<ul><li>一个事务执行过程中看到的数据和事务启动时看到的数据是一致的</li></ul></li><li>串行化 （SERIALIZABLE）<ul><li>强制事务排序，不可能冲突，导致大量的超时现象和锁竞争</li></ul></li></ul><ol><li>脏读：当前事务(A)中可以读到其他事务(B)未提交的数据（脏数据），这种现象是脏读。</li><li>不可重复读：在事务A中先后两次读取同一个数据，两次读取的结果不一样，这种现象称为不可重复读。脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。</li><li>幻读：在事务A中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。</li></ol><p>脏读是一个事务的回滚影响另外一个事务；不可重复读则是侧重于数据的修改，两次读取数据不一致；幻读则是数据的行数发生了增加或者减少。</p><h3 id="MySQL隔离级别的实现机制"><a href="#MySQL隔离级别的实现机制" class="headerlink" title="MySQL隔离级别的实现机制"></a>MySQL隔离级别的实现机制</h3><ol><li>READ UNCOMMITTED：</li></ol><p>读不加锁原理，写的时候加锁但是不妨碍读</p><ol start="2"><li>READ COMMITTED：</li></ol><p>通过Record Lock算法实现了行锁，但READ UNCOMMITTED允许读取未提交数据，所以存在脏读问题。而READ COMMITTED允许读取提交数据，所以不存在脏读问题，但存在不可重复读问题。</p><ol start="3"><li>REPEATABLE READ：</li></ol><p>快照读读的是这个事务开启时数据的一个快照版本；当前读读的是最新的一个数据，所以需要进行加锁处理<br>利用ReadView和MVCC，第一次读取数据时生成一个ReadView<br>使用Next-Key Lock算法实现了记录锁和间隙锁，并且不允许读取已提交的数据，所以解决了不可重复读的问题。另外，该算法包含了间隙锁，会锁定一个范围，因此也解决了幻读的问题。<br>幻读问题：部分解决，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id &#x3D; 5 的记录并提交。接着，事务 A 对 id &#x3D; 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A  再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读<br>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。<br><a href="https://blog.csdn.net/m0_71777195/article/details/126968432">美团三面：一直追问我， MySQL 幻读被彻底解决了吗？_mysql如何解决幻读-CSDN博客</a></p><ol start="4"><li>SERIALIZABLE：</li></ol><p>即为每个读取操作加一个共享锁。因此在这个事务隔离级别下，读占用了锁，对一致性的非锁定读不再予以支持。</p><h3 id="如何实现可重复读和解决幻读问题"><a href="#如何实现可重复读和解决幻读问题" class="headerlink" title="如何实现可重复读和解决幻读问题"></a>如何实现可重复读和解决幻读问题</h3><p>MySQL的InnoDB引擎，在默认的REPEATABLE READ的隔离级别下，实现了可重复读，同时也解决了幻读问题。它使用Next-Key Lock算法实现了行锁，并且不允许读取已提交的数据，所以解决了不可重复读的问题。另外，该算法包含了间隙锁，会锁定一个范围，因此也解决了幻读的问题。</p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>多版本并发控制，通过维护数据历史版本来解决并发访问情况下读一致性问题<br>InnoDB每一行数据都有两个隐藏的指针，分别指向当前修改的事务ID，上一个历史版本，每次更新时都会修改指针，从而形成了一个历史版本的版本链<br>ReadView：</p><ul><li>当前活跃的事务ID</li><li>当前活跃事务的最小ID</li><li>分配给下一个事务的ID</li><li>生成ReadView的事务ID</li></ul><p>判断流程：</p><ul><li>被访问数据的事务ID等于生成ReadView的事务ID，可以访问</li><li>被访问数据的事务ID小于最小事务ID，已经提交可以访问</li><li>被访问数据的事务ID大于下一个事务ID，不能访问</li><li>在两者范围之间，判断是否在活跃的事务ID内，在的话不能访问</li></ul><p>如果不能访问的话，那就根据版本链去查询历史版本<br>READ COMMITTED每次读取数据都创建ReadView，REPEATABLE READ第一次读取数据时生成一个ReadView</p><h3 id="MySQL的日志文件"><a href="#MySQL的日志文件" class="headerlink" title="MySQL的日志文件"></a>MySQL的日志文件</h3><ol><li><code>Redo Log</code>：主要用于系统故障后的数据恢复和持久性保障  ,确保事务的持久性 （系统崩溃恢复）</li><li><code>Undo Log</code>：事务开始之后，把事务的所有更新操作记录下来，用于事务的回滚和提供一致性（也叫事务日志）</li><li><code>Binlog</code>：记录所有数据库所有更改操作，用于数据备份，恢复的二进制日志</li><li><code>慢查询日志</code>：记录查询时间长的查询语句</li><li><code>一般查询日志</code>：记录了对数据库所有的请求</li><li><code>错误日志</code>：对MySQL的运行错误进行了记录</li></ol><p><code>Binlog</code> &amp; <code>Redo Log</code>：</p><ul><li>Binlog 记录所有与数据库相关的日志记录，Redo Log只记录InnoDB储存引擎的日志</li><li>Binlog 用于数据备份恢复，Redo Log用于事务的持久和崩溃恢复</li><li>Binlog是逻辑日志（等同于SQL语句），Redo Log是物理日志</li><li>Binlog 在事务提交时写入，Redo Log事务执行过程中不断写入</li></ul><h3 id="MySQL两阶段提交事务（略）"><a href="#MySQL两阶段提交事务（略）" class="headerlink" title="MySQL两阶段提交事务（略）"></a>MySQL两阶段提交事务（略）</h3><blockquote><p>两阶段提交是为了实现Binlog和Redo Log的数据一致性</p></blockquote><p>不管是先写Binlog还是Redo Log，都会造成数据的不一致；在主从架构中主节点使用Redo Log恢复数据，从节点使用Binlog恢复数据<br><a href="https://zhuanlan.zhihu.com/p/343449447">MySQL两阶段提交串讲</a></p><h3 id="数据库中的锁"><a href="#数据库中的锁" class="headerlink" title="数据库中的锁"></a>数据库中的锁</h3><p>锁是数据库系统区别于文件系统的一个关键特性，锁机制用于管理对共享资源的并发访问<br>下面我们以MySQL数据库的InnoDB引擎为例，来说明锁的一些特点。</p><ol><li>锁的类型</li></ol><p>InnoDB存储引擎实现了如下两种标准的行级锁：</p><ul><li>共享锁（S Lock），允许事务读一行数据。</li><li>排他锁（X Lock），允许事务删除或更新一行数据。</li></ul><p>X和任何锁都不兼容，S只和S锁兼容</p><ol start="2"><li>锁的粒度</li></ol><p>InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式，称之为意向锁。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。</p><ul><li>意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁。</li><li>意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁。</li></ul><ol start="3"><li>锁的算法</li></ol><p>InnoDB存储引擎有3种行锁的算法，其分别是：</p><ul><li>Record Lock：单个行记录上的锁。</li><li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。</li><li>Next-Key Lock∶Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。</li></ul><ol start="4"><li>关于死锁</li></ol><p>死锁是两个或以上的事务，为争夺锁资源而互相等待的现象，通常没有外力无法推进下去<br>最简单的就是超时方法，等其中每一个事务超时后，进行了回滚，那么其他事务就能获得锁<br>wait-for graph（等待图）进行主动的检测是否有死锁</p><h3 id="介绍下间隙锁"><a href="#介绍下间隙锁" class="headerlink" title="介绍下间隙锁"></a>介绍下间隙锁</h3><p>间隙锁是数据库实现的三种行锁算法之一，它用于对某个范围进行加锁，防止多个事务对同一个范围内的数据进行修改，导致幻读的发生。</p><h3 id="InnoDB中行级锁是怎么实现的？"><a href="#InnoDB中行级锁是怎么实现的？" class="headerlink" title="InnoDB中行级锁是怎么实现的？"></a>InnoDB中行级锁是怎么实现的？</h3><p>对索引添加锁来实现，只有使用索引查找，才能使用行锁，否则使用表级锁<br>当表中锁定其中的某几行时，不同的事务可以使用不同的索引锁定不同的行。另外，不论使用主键索引、唯一索引还是普通索引，InnoDB都会使用行锁来对数据加锁。</p><h3 id="隔离级别和锁的关系"><a href="#隔离级别和锁的关系" class="headerlink" title="隔离级别和锁的关系"></a>隔离级别和锁的关系</h3><ul><li>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</li><li>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁； </li><li>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</li><li>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</li></ul><h3 id="锁优化的意见"><a href="#锁优化的意见" class="headerlink" title="锁优化的意见"></a>锁优化的意见</h3><ul><li>不要使用超过实际要求级别的锁</li><li>尽量使用索引访问数据，加锁更加精确</li><li>数据查询非必要不加锁</li></ul><h3 id="意向锁是什么"><a href="#意向锁是什么" class="headerlink" title="意向锁是什么"></a>意向锁是什么</h3><p>意向锁是表级锁，用于给表加表锁时，判断有没有数据行被锁定<br>意向插入锁表示事务想在表中某个位置插入数据</p><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="分表分库"><a href="#分表分库" class="headerlink" title="分表分库"></a>分表分库</h3><ol><li>分表</li></ol><p>将一个表的数据按照某个字段分成不同的表</p><ol start="2"><li>分库</li></ol><p>将一个库的数据分成几个库来存储<br>都是为了提到SQL语句的执行性能，提高并发量</p><h3 id="水平拆分和垂直拆分"><a href="#水平拆分和垂直拆分" class="headerlink" title="水平拆分和垂直拆分"></a>水平拆分和垂直拆分</h3><ol><li>水平拆分</li></ol><p>水平拆分的意思，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不 过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义，就是将数据均 匀放更多的库里，然后用多个库来抗更高的并发，还有就是用多个库的存储容量来进行扩容。</p><ol start="2"><li>垂直拆分</li></ol><p>垂直拆分的意思，就是把一个有很多字段的表给拆分成多个表，或者是多个库上去。每个库表的结 构都不一样，每个库表都包含部分字段。一般来说，会将较少的访问频率很高的字段放到一个表里 去，然后将较多的访问频率很低的字段放到另外一个表里去。因为数据库是有缓存的，你访问频率 高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="数据库优化是什么"><a href="#数据库优化是什么" class="headerlink" title="数据库优化是什么"></a>数据库优化是什么</h3><p>MySQL数据库优化是多方面的，原则是减少系统的瓶颈，减少资源的占用，增加系统的反应速度</p><h3 id="该如何优化MySQL的查询？"><a href="#该如何优化MySQL的查询？" class="headerlink" title="该如何优化MySQL的查询？"></a>该如何优化MySQL的查询？</h3><ol><li>使用索引查询</li><li>使用连接或子查询来优化</li></ol><h3 id="怎样插入数据才能更高效？"><a href="#怎样插入数据才能更高效？" class="headerlink" title="怎样插入数据才能更高效？"></a>怎样插入数据才能更高效？</h3><p>对于InnoDB引擎的表，常见的优化方法如下：</p><ol><li>禁用唯一性检查</li></ol><p>插入数据之前执行set unique_checks&#x3D;0来禁止对唯一索引的检查，数据导入完成之后再运行set unique_checks&#x3D;1。这个和MyISAM引擎的使用方法一样。</p><ol start="2"><li>禁用外键检查插入</li></ol><p>数据之前执行禁止对外键的检查，数据插入完成之后再恢复对外键的检查。</p><ol start="3"><li>禁用自动提交</li></ol><p>插入数据之前禁止事务的自动提交，数据导入完成之后，执行恢复自动提交操作。</p><h3 id="表中包含几千万条数据该怎么办？"><a href="#表中包含几千万条数据该怎么办？" class="headerlink" title="表中包含几千万条数据该怎么办？"></a>表中包含几千万条数据该怎么办？</h3><ol><li>优化SQL和索引；</li><li>增加缓存，如memcached、redis；</li><li>读写分离，可以采用主从复制，也可以采用主主复制；</li><li>使用MySQL自带的分区表，这对应用是透明的，无需改代码，但SQL语句是要针对分区表做优化的；</li><li>做垂直拆分，即根据模块的耦合度，将一个大的系统分为多个小的系统；</li><li>做水平拆分，要选择一个合理的sharding key，为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表。</li></ol><h3 id="MySQL的慢查询优化有了解吗？"><a href="#MySQL的慢查询优化有了解吗？" class="headerlink" title="MySQL的慢查询优化有了解吗？"></a>MySQL的慢查询优化有了解吗？</h3><ol><li>开启慢查询日志</li></ol><p>在配置中设置</p><ol start="2"><li>分析慢查询日志</li></ol><p>直接分析mysql慢查询日志，利用explain关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句。</p><ol start="3"><li>优化慢查询<ul><li>通过explain查看索引起没起作用，没有的话考虑增加索引</li><li>索引是否合理，可以建立联合索引，实现覆盖索引优化</li><li>优化表的结构，把一些使用频率比较低的字段分开来</li><li>分解联表查询，进行单表查询</li><li>优化LIMIT分页，不要直接查所有字段，而是根据索引查范围，再查所有字段</li></ul></li></ol><p>总结：</p><ol><li>开启慢查询配置</li><li>通过explain关键字进行慢查询分析</li><li>分析是否使用索引，索引失效的原因</li><li>索引是否合理</li></ol><h3 id="优化慢SQL的方式"><a href="#优化慢SQL的方式" class="headerlink" title="优化慢SQL的方式"></a>优化慢SQL的方式</h3><ol><li>只查询需要的列</li><li>正确使用索引，确保索引生效</li><li>数据量比较大时采用分页查询</li></ol><h2 id="高可用（略）"><a href="#高可用（略）" class="headerlink" title="高可用（略）"></a>高可用（略）</h2><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>将数据库的读写操作分散到不同的节点上<br>搭建主从集群，主机负责读写操作，从机负责读操作</p>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis（更新中）</title>
      <link href="/2024/03/11/Redis/"/>
      <url>/2024/03/11/Redis/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>redis的事务是一系列串行化的命令，在执行过程中不受其它事务的影响。<br><strong>四个命令来实现：</strong><br>MULTI：它标记了一个事务块的开始。MULTI命令之后的所有命令不会立即执行，而是缓存在服务器的一个事务队列中，然后当EXEC命令被调用时一次性、按顺序地执行。<br>EXEC：它标记事务的提交，它的作用是触发服务器执行所有在MULTI之后入队的命令。<br>DISCARD：如果客户端在MULTI之后决定取消事务，那么它可以调用DISCARD命令来做这件事。调用DISCARD之后，服务器会清空事务队列，并将客户端的状态从事务状态调整回非事务状态。<br>WATCHkey[key.]：WATCH命令用于在执行事务前监控一个或多个键，以此来达到乐观锁的效果。如果在调用EXEC命令执行事务之前，有其他客户端抢先对任何一个被监视的键进行了替换、更新、删除等操作，那么当客户端尝试执行事务时，服务器将返回一个错误，客户端可以在这时选择重试事务或者放弃事务。<br><strong>事务可能的两种情况：</strong></p><ul><li>事务过程出现语法错误，事务提交时无法执行。</li><li>事务过程出现非语法错误，比如set值不存在，则跳过错误语句，其他的语句执行不受影响。</li></ul><p><strong>watch命令：</strong>提供乐观锁机制；事务开启前监控key，如果发生了改变，那么对于这个key操作的事务将不会成功。</p><h3 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁&amp;悲观锁"></a>乐观锁&amp;悲观锁</h3><p><strong>乐观锁：</strong>事务开始前先假设没有人会修改，在提交时则检查是否存在修改，事务回滚耗费时间。<br><strong>悲观锁：</strong>事务一开始就进行加锁，认定一定会有人修改，对于并发不友好。</p><h3 id="Redis操作方式"><a href="#Redis操作方式" class="headerlink" title="Redis操作方式"></a>Redis操作方式</h3><ol><li>jedis方式</li></ol><p>查看AI助手手机验证登录功能<br><a href="https://www.yuque.com/yuqueyonghu00040s/ikkvco/hpbrb4h4k13hu75k">AI助手</a></p><ol start="2"><li>redisTemplate</li></ol><p>底层实现：在SpringBoot2.x版本以后，从原来的jedis替换成了lettuce，所以2.x以后开始默认使用Lettuce作为Redis客户端，Lettuce客户端基于Netty的NIO框架实现，只需要维持单一的连接即可高效支持业务端并发请求。同时，Lettuce支持的特性更加全面，其性能表现并不逊于，甚至优于Jedis。<br>简单理解：</p><ul><li>Jedis：采用的直连，多个线程操作的话，是不安全的，如果想要避免线程安全问题，就需要使用jedisPool连接池，但是也会有一些线程过多等其他问题，类似于BIO</li><li>Lettuce：底层采用Netty，实例可以在多个线程中进行共享，不存在线程安全问题！类似NIO</li></ul><p><a href="https://zhuanlan.zhihu.com/p/419345478">JAVA BIO与NIO、AIO的区别(容易理解)</a></p><h3 id="Redis有哪些数据类型？"><a href="#Redis有哪些数据类型？" class="headerlink" title="Redis有哪些数据类型？"></a>Redis有哪些数据类型？</h3><p><a href="https://blog.csdn.net/qq_31960623/article/details/117911710">Redis八种数据类型及应用场景介绍_redis中数据类型的应用场景-CSDN博客</a></p><ol><li><p>String</p><blockquote><p>最基本也是最常用的数据类型就是String。get和set命令就是String的操作命令<br><strong>应用场景</strong>：热点数据的缓存、分布式锁、分布式数据的共享（session）、计数器 </p></blockquote></li><li><p>Hash</p><blockquote><p>(map_key,map_value)<br>优点：</p><ul><li>把所有相关的值聚集到一个Key中，节省内存空间</li><li>只使用一个Key，减少Key冲突</li><li>当需要批量获取值的时候，只需要使用一个命令，减少内存&#x2F;IO&#x2F;CPU的消耗</li></ul></blockquote><p>缺点：</p><blockquote><ul><li>Field不能单独设置过期时间</li><li>需要考虑数据量分布的问题（field非常多的时候，无法分布到多个节点）</li></ul></blockquote><p><strong>应用场景</strong>：购物车、String的功能</p></li><li><p>List</p><blockquote><p>使用双向链表的结构，可以两端进行出队进队<br><strong>应用场景：</strong>列表，存储消息列表；队列&#x2F;栈，当作分布式环境的队列&#x2F;栈使用 </p></blockquote></li><li><p>Set</p><blockquote><p>存储 String 类型的无序集合，不含重复元素的list，底层是一个value为null的hash表<br><strong>应用场景：</strong>抽奖、签到、点赞 </p></blockquote></li><li><p>ZSet</p><blockquote><p>有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集<br>不同之处是有序集合的每个成员都关联了一个评分（score），这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复的<br>可以很快的访问中间元素<br><strong>应用场景：</strong>排行榜<br>zset底层使用了hash和跳跃表两种结构，其中跳表是由原列表不同区间元素组成的，元素包含少但是涵盖一定范围，多个这样的链表组成了跳跃表，查找时首先在区间范围最大的跳表查找，逐渐缩小范围</p></blockquote></li><li><p>BitMaps</p><blockquote><p>BitMaps是在字符串类型上定义的位操作，一个字节由8个二进制位组成，应用于在线用户统计等 </p></blockquote></li><li><p>Hyperloglog</p><blockquote><p>Hyperloglog 提供了一种不太精确的基数统计方法，用来统计一个集合中不重复的元素个数，比如统计网站的UV，或者应用的日活、月活，存在一定的误差 </p></blockquote></li><li><p>Geospatial</p><blockquote><p>保存经纬度，地理位置信息 </p></blockquote></li><li><p>Streams</p><blockquote><p>5.0推出的数据类型。支持多播的可持久化的消息队列，用于实现发布订阅功能，借鉴了Kafka的设计</p></blockquote></li></ol><h3 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h3><ul><li>Redis是基于内存操作，需要的时候需要我们手动持久化到硬盘中（<strong>主要原因</strong>）</li><li>Redis数据结构比较高效，对数据的操作也比较简单 </li><li>Redis是单线程模型，从而避开了多线程中上下文频繁切换的操作 </li><li>使用多路I&#x2F;O复用模型，非阻塞I&#x2F;O </li><li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求</li></ul><h3 id="SET和ZSET有什么区别？"><a href="#SET和ZSET有什么区别？" class="headerlink" title="SET和ZSET有什么区别？"></a>SET和ZSET有什么区别？</h3><p>SET：</p><ul><li>集合中的元素是无序、不可重复的，一个集合最多能存储232-1个元素；</li><li>集合除了支持对元素的增删改查之外，还支持对多个集合取交集、并集、差集。</li></ul><p>ZSET：</p><ul><li>有序集合会给每个元素设置一个分数，并以此作为排序的依据（<strong>有序</strong>）；</li><li>有序集合不能包含相同的元素，但是不同元素的分数可以相同。<blockquote><p>总结：ZSET相比于SET多了一个分数因而是有序的，SET 适合需要快速操作和存储无序数据的场景，ZSET 适合需要按分数排序存储和查询数据的场景。</p></blockquote></li></ul><h3 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h3><ol><li>缓存雪崩</li></ol><p>同一时间内出现了大量缓存的key过期</p><blockquote><p>使用队列的请求顺序；<br>最简单的控制失效时间错开，加上一个随机值；<br>真的一定发生雪崩，可以使用熔断机制，不响应部分用户的请求，保证一部分用户可用</p></blockquote><ol start="2"><li>缓存穿透</li></ol><p>用户要查询的数据在数据库中就没有，缓存中自然也没有，但是请求还是会分别查缓存和数据库一次。</p><blockquote><ol><li>把无效的Key存进Redis中，设置value&#x3D;”null”，并设置一个短时间的过期时间，如果每次key不一样则此方法有问题。 </li><li>使用布隆过滤器，先进行筛选，它认为不存在的key那就一定不存在。引入k&gt;1个hash函数，有一个hash函数说不存在，那就不存在，所有的hash函数说存在，才存在。<br><a href="https://blog.csdn.net/qq_41125219/article/details/119982158">布隆(Bloom Filter)过滤器——全面讲解，建议收藏-CSDN博客</a></li></ol></blockquote><ol start="3"><li>缓存击穿</li></ol><p>某个热点的key失效了，导致大量请求直接打在数据库上。</p><blockquote><ul><li>如果可以，设置热点key永不失效</li><li>缓存重建时加互斥锁</li></ul></blockquote><p>缓存预热（略）<br>系统上线后，提前将一些数据加入到缓存中。</p><ol><li>手写缓存刷新页面，手工操作</li><li>项目启动的时候自动加载</li><li>定时缓存刷新</li></ol><p>缓存更新（略）<br>自定义缓存更新策略</p><ol><li>定期清理过期的缓存，维护大量的key比较麻烦。</li><li>请求过来时再更新缓存，每次请求都要判断比较麻烦。</li></ol><p>缓存降级（略）<br>访问量剧增或服务出现问题时，保证核心业务可以继续使用，降低一些服务的级别</p><h3 id="Redis怎么实现分布式锁"><a href="#Redis怎么实现分布式锁" class="headerlink" title="Redis怎么实现分布式锁"></a>Redis怎么实现分布式锁</h3><p>setnx命令返回整数值，当返回1时表示设置值成功，当返回0时表示设置值失败（key已存在）。<br>加锁：<br>第一版，这种方式的缺点是容易产生死锁，因为客户端有可能忘记解锁，或者解锁失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx key value</span><br></pre></td></tr></table></figure><p>第二版，给锁增加了过期时间，避免出现死锁。但这两个命令不是原子的，第二步可能会失败，依然无法避免死锁问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx key value expire key seconds</span><br></pre></td></tr></table></figure><p>第三版，通过“set…nx…”命令，将加锁、过期命令编排到一起，它们是原子操作了，可以避免死锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value nx ex seconds</span><br></pre></td></tr></table></figure><p>解锁：<br>解锁就是删除代表锁的那份数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure><p>还存在问题就是会释放别人的锁<br>想要解决这个问题，我们需要解决两件事情：</p><ol><li>在加锁时就要给锁设置一个标识，进程要记住这个标识。当进程解锁的时候，要进行判断，是自己持有的锁才能释放，否则不能释放。可以为key赋一个随机值，来充当进程的标识。</li><li>解锁时要先判断、再释放，这两步需要保证原子性，否则第二步失败的话，就会出现死锁。而获取和删除命令不是原子的，这就需要采用Lua脚本，通过Lua脚本将两个命令编排在一起，而整个Lua脚本的执行是原子的。</li></ol><p>按照以上思路，优化后的命令如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 加锁 set key random-value nx ex seconds   # 解锁 <span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then     <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>]) e</span><br></pre></td></tr></table></figure><p>这个不是很详细，建议看语雀笔记<br>基于RedLock算法的分布式锁：<br>上述分布式锁的实现方案，是建立在单个主节点之上的。它的潜在问题如下图所示，如果进程A在主节点上加锁成功，然后这个主节点宕机了，则从节点将会晋升为主节点。若此时进程B在新的主节点上加锁成功，之后原主节点重启，成为了从节点，系统中将同时出现两把锁，这是违背锁的唯一性原则的。<br>总之，就是在单个主节点的架构上实现分布式锁，是无法保证高可用的。若要保证分布式锁的高可用，则可以采用多个节点的实现方案。这种方案有很多，而Redis的官方给出的建议是采用RedLock算法的实现方案。该算法基于多个Redis节点，它的基本逻辑如下：</p><ul><li>这些节点相互独立，不存在主从复制或者集群协调机制；</li><li>加锁：以相同的KEY向N个实例加锁，只要超过一半节点成功，则认定加锁成功；</li><li>解锁：向所有的实例发送DEL命令，进行解锁；</li></ul><p>RedLock是对多个节点一起加锁，解锁也是一起解锁。</p><h3 id="Redis的持久化策略"><a href="#Redis的持久化策略" class="headerlink" title="Redis的持久化策略"></a>Redis的持久化策略</h3><p>为了能够重用Redis的数据，或者防止系统故障，我们需要将数据写入到磁盘空间中，即持久化<br>快照<code>RDB</code>，只追加文件<code>AOF</code>。<br>RDB<br>RDB持久化策略是指在一定的时间间隔内，将Redis内存中的数据以二进制文件的形式保存到硬盘上。这个二进制文件就是一个快照，它记录了某个时刻Redis内存中的所有数据。RDB持久化策略可以通过配置文件或者命令来触发，配置文件中可以设置多个条件，当任意一个条件满足时，就会执行一次快照操作。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1 # 900秒内执行一次 set 操作 则持久化1次</span><br><span class="line">save 300 10 # 300秒内执行10次 set 操作,则持久化1次</span><br><span class="line">save 60 10000 # 60秒内执行10000次 set 操作,则持久化1次</span><br></pre></td></tr></table></figure><p>命令有两种：</p><ul><li><strong>save</strong>：不建议使用，会阻塞redis服务的进程，直到成功创建RDB文件</li><li><strong>bgsave</strong>：父进程创建一个子进程生成RDB文件，父进程可以正常处理客户端的指令，<strong>不影响主进程</strong>的服务</li></ul><p>RDB持久化策略的优点有：</p><ul><li>RDB文件是一个紧凑的二进制文件，占用空间小，传输速度快，适合做备份和灾难恢复</li><li>RDB文件恢复数据的速度比AOF快，因为只需要加载一次文件即可</li><li>RDB持久化对Redis服务器的性能影响较小，因为大部分工作由子进程完成</li></ul><p>RDB持久化策略的缺点有：</p><ul><li>如果在两次快照之间发生故障，可能会丢失一部分数据</li><li>RDB文件在生成过程中可能会占用较多的内存和CPU资源，因为需要复制主进程的内存并执行压缩操作</li></ul><p>AOF<br>以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，Redis启动之初会读取该文件重新构建数据，换言之，Redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。<br>AOF采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集.。<br>三种刷盘策略： </p><ul><li>每修改同步：appendfsync always 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好</li><li>每秒同步：appendfsync everysec 异步操作，每秒记录，如果一秒内宕机，有数据丢失</li><li>不同步：appendfsync no从不同步，刷盘时间由redis决定</li></ul><p>AOF持久化策略的优点有：</p><ul><li>AOF文件可以实时或者近实时地记录Redis内存中的数据，因为它是每次写命令或者每秒钟同步一次。如果在同步之间发生故障，可能会丢失一部分数据，但是数据丢失的概率比RDB小。</li><li>AOF文件是一个文本文件，可以方便地查看和编辑。AOF文件中的命令是Redis协议格式的，可以直接用Redis客户端来执行。</li><li>AOF文件可以自动进行重写，以减少冗余命令和文件体积。重写过程不影响Redis服务器的正常服务，也不会丢失任何数据。</li></ul><p>AOF持久化策略的缺点有：</p><ul><li>AOF文件通常比RDB文件大，占用更多的磁盘空间</li><li>AOF文件恢复数据的速度比RDB慢，因为需要重新执行所有的命令</li><li>AOF文件在写入过程中可能会出现数据不一致的情况，例如命令只写入了一半或者写入了错误的命令。这种情况下需要用redis-check-aof工具来修复AOF文件</li></ul><p><strong>AOF重写机制：</strong>Redis会创建一个新的AOF文件，然后根据内存中的当前数据状态，生成相应的写命令，并写入到新的AOF文件中。这样新的AOF文件就只包含了最终数据的写命令，而不包含任何无效或者冗余的命令。<br>在重写期间，会将接收到的写命令写到缓冲区，在执行完毕后追加到新的AOF文件，最后替换旧的AOF文件</p><ul><li><p>自动触发：通过参数设置</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 文件大小超过上次AOF重写之后的文件的百分比。默认<span class="number">100</span></span><br><span class="line"># 也就是默认达到上一次AOF重写文件的<span class="number">2</span>倍之后会再次触发AOF重写</span><br><span class="line"><span class="keyword">auto</span>-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line"># 设置允许重写的最小AOF文件大小,默认是<span class="number">64</span>M</span><br><span class="line"># 主要是避免满足了上面的百分比，但是文件还是很小的情况。</span><br><span class="line"><span class="keyword">auto</span>-aof-rewrite-min-size <span class="number">64</span>mb</span><br></pre></td></tr></table></figure></li><li><p>手动触发：bgrewriteaof命令</p></li></ul><p>RDB-AOF混合持久化<br>Redis从4.0开始引入RDB-AOF混合持久化模式，这种模式是基于AOF持久化构建而来的。用户可以通过配置文件中的“aof-use-rdb-preamble yes”配置项开启AOF混合持久化。Redis服务器在执行AOF重写操作时，会按照如下原则处理数据： </p><ul><li>像执行BGSAVE命令一样，根据数据库当前的状态生成相应的RDB数据，并将其写入AOF文件中；</li><li>对于重写之后执行的Redis命令，则以协议文本的方式追加到AOF文件的末尾，即RDB数据之后。</li></ul><p>通过使用RDB-AOF混合持久化，用户可以同时获得RDB持久化和AOF持久化的优点，服务器既可以通过AOF文件包含的RDB数据来实现快速的数据恢复操作，又可以通过AOF文件包含的AOF数据来将丢失数据的时间窗口限制在1s之内。 </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/reim/p/17387751.html">Redis的三种持久化策略及选取建议 - 阿磊聊软件 - 博客园</a></p><h3 id="7-Redis的高可用实现方案（略）"><a href="#7-Redis的高可用实现方案（略）" class="headerlink" title="7.Redis的高可用实现方案（略）"></a>7.Redis的高可用实现方案（略）</h3><p>哨兵<br>Redis Sentinel（哨兵）是一个分布式架构，它包含若干个哨兵节点和数据节点。每个哨兵节点会对数据节点和其余的哨兵节点进行监控，当发现节点不可达时，会对节点做下线标识。如果被标识的是主节点，它就会与其他的哨兵节点进行协商，当多数哨兵节点都认为主节点不可达时，它们便会选举出一个哨兵节点来完成自动故障转移的工作，同时还会将这个变化实时地通知给应用方。整个过程是自动的，不需要人工介入，有效地解决了Redis的高可用问题！<br>哨兵节点包含如下的特征：</p><ol><li><strong>哨兵节点会定期监控数据节点，其他哨兵节点是否可达</strong>；</li><li>哨兵节点会将故障转移的结果通知给应用方；</li><li><strong>哨兵节点可以将从节点晋升为主节点，并维护后续正确的主从关系</strong>；</li><li>哨兵模式下，客户端连接的是哨兵节点集合，从中获取主节点信息；</li><li>节点的故障判断是由多个哨兵节点共同完成的，可有效地防止误判；</li><li>哨兵节点集合是由多个哨兵节点组成的，即使个别哨兵节点不可用，整个集合依然是健壮的；</li><li>哨兵节点也是独立的Redis节点，是特殊的Redis节点，它们不存储数据，只支持部分命令。</li></ol><p>主节点和从节点都储存一样的信息，主节点有读写权限，从节点只有读权限，造成内存的浪费<br>集群<br>Redis集群采用虚拟槽分区来实现数据分片，每一个节点负责维护一部分槽以及槽所映射的键值数据。最小配置6个节点以上，主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。<br>哨兵是整个的数据库作为主从，集群则进行分片，对于每一片保留一个备份，大大减少了内存使用。</p><h3 id="8-Redis的主从同步是如何实现的"><a href="#8-Redis的主从同步是如何实现的" class="headerlink" title="8.Redis的主从同步是如何实现的"></a>8.Redis的主从同步是如何实现的</h3><p>从2.8版本开始，Redis使用psync命令完成主从数据同步，同步过程分为全量复制和部分复制。前者一般是用于初次复制的场景，部分复制则用于处理因网络中断等原因造成数据丢失的场景。<br>复制过程：</p><ul><li>从节点发送给主节点psync命令，返回全量复制</li><li>主节点接收到SYNC命令后，可以执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令。</li><li>主节点生成快照后发送给从节点，并记录所有写操作。</li><li>在从节点载入快照后，执行来自主节点缓冲区的写命令</li><li>出现断开重连后，2.8之后的版本会将断线期间的命令传给从数据库，增量复制。</li><li><strong>主从刚刚连接的时候，进行全量同步;全同步结束后，进行增量同步</strong>。当然，如果有需要，slave在任何时候都可以发起全量同步。Redis的策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</li></ul><h3 id="9-Redis过期键的删除策略"><a href="#9-Redis过期键的删除策略" class="headerlink" title="9.Redis过期键的删除策略"></a>9.Redis过期键的删除策略</h3><p>Redis支持如下两种过期策略：<br>惰性删除：客户端访问一个key的时候，Redis会先检查它的过期时间，如果发现过期就立刻删除这个key。<br>定期删除：Redis会将设置了过期时间的key放到一个独立的字典中，并对该字典进行每秒10次的过期扫描<br>1、定时删除<br>在设置某个key的过期时间同时，我们创建一个定时器，让定时器在该过期时间到来时，立即执行对其进行删除的操作。<br>优点：定时删除对内存是最友好的，能够保存内存的key一旦过期就能立即从内存中删除。<br>缺点：对CPU最不友好，在过期键比较多的时候，删除过期键会占用一部分CPU时间，对服务器的响应时间和吞吐量造成影响。<br>2、惰性删除<br>设置该key过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key。</p><blockquote><p>访问或修改前，都会调用expireIfNeeded函数检查key是否过期，如果过期就删除key，同步还是异步删除由参数配置决定</p></blockquote><p>优点：对CPU友好，我们只会在使用该键时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。<br>缺点：对内存不友好，如果一个键已经过期，但是一直没有使用，那么该键就会一直存在内存中，如果数据库中有很多这种使用不到的过期键，这些键便永远不会被删除，内存永远不会释放。从而造成内存泄漏。<br>3、定期删除<br>每隔一段时间，随机从数据库中取出一定数量的key进行检查，并删除里面过期的key。（间隔检查时间是一个参数设置hz，随机抽查数量写死在代码：20）<br>优点：可以通过限制删除操作执行的时长和频率来减少删除操作对CPU 的影响。另外定期删除，也能有效释放过期键占用的内存。</p><h3 id="10-如何保证缓存与数据库的双写一致性？"><a href="#10-如何保证缓存与数据库的双写一致性？" class="headerlink" title="10.如何保证缓存与数据库的双写一致性？"></a>10.如何保证缓存与数据库的双写一致性？</h3><ol><li>先更新缓存，再更新数据库；</li><li>先更新数据库，再更新缓存；</li><li>先删除缓存，再更新数据库；</li><li>先更新数据库，再删除缓存。</li></ol><p>第一种如果更新缓冲成功，更新数据库失败，数据不一致<br>第二种在并发场景下，会把脏数据更新到数据库<br>第三种，A进行写操作，删除缓存；B进行查操作，缓存没查到，去数据库查，并写到缓存中；A把数据写入到数据库中，出现数据不一致。<br>延时双删：在更新数据库后，sleep一下（给B的查询更新缓存操作留时间），再进行缓存删除<br>第四种，A更新数据库成功，删除缓存失败，数据不一致。<br>重试机制，再次进行删除缓存<br>通常我们选择直接删除缓存，因为缓存的更新成本更高（很多情况下并不是直接写入缓存的，而是经过一系列复杂的计算再写入缓存）<br>通常我们选择先操作数据库，再删除缓存，虽然这两种都会可能出现数值不一致性问题，但是前面这种更能保证数据的最终一致性，不同的顺序都会出现不一样的问题，详细可以看上面的解释<br><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/43109882/1715159198724-beb74ce3-b9af-4317-9403-6b9e4d6e6432.jpeg"><br><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/43109882/1715159487542-95bb79fa-b554-4d04-a4fe-4e94afd1e092.jpeg"></p><h3 id="11-Redis集群"><a href="#11-Redis集群" class="headerlink" title="11.Redis集群"></a>11.Redis集群</h3><p>分区方案<br>Redis集群采用虚拟槽分区来实现数据分片，它把所有的键根据哈希函数映射到0-16383整数槽内，计算公式为slot&#x3D;CRC16(key)&amp;16383，每一个节点负责维护一部分槽以及槽所映射的键值数据。虚拟槽分区具有如下特点：</p><ol><li>解耦数据和节点之间的关系，简化了节点扩容和收缩的难度；</li><li>节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据；</li><li>支持节点、槽、键之间的映射查询，用于数据路由，在线伸缩等场景。</li></ol><p>通信方案<br>Redis cluster节点间采取gossip协议进行通信，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更之后不断地将元数据发送给其他节点让其他节点进行数据变更。<br>这种机制的好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新，有一定的延时，降低了压力;<br>缺点，元数据更新有延时，可能导致集群的一些操作会有一些滞后。<br>优势<br>Redis Cluster是Redis的分布式解决方案，在3.0版本正式推出，有效地解决了Redis分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用Cluster架构方案达到负载均衡的目的。<br>劣势</p><ul><li>key批量操作支持有限，只支持映射为相同slot的操作</li><li>只支持同一节点的事务操作</li><li>单机Redis有16个数据库，集群下只有一个，DB0</li><li>…</li></ul><h3 id="12-说一说hash和zset类型底层的数据结构"><a href="#12-说一说hash和zset类型底层的数据结构" class="headerlink" title="12.说一说hash和zset类型底层的数据结构"></a>12.说一说hash和zset类型底层的数据结构</h3><p>哈希对象有两种编码方案，当同时满足以下条件时，哈希对象采用ziplist编码，否则采用hashtable编码：</p><ul><li>哈希对象保存的键值对数量小于512个；</li><li>哈希对象保存的所有键值对中的键和值，其字符串长度都小于64字节。</li></ul><p>其中，ziplist编码采用压缩列表作为底层实现，而hashtable编码采用字典作为底层实现。<br>压缩列表：<br>压缩列表（ziplist），是Redis为了节约内存而设计的一种线性数据结构，它是由一系列具有特殊编码的连续内存块构成的。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或一个整数值。<br>字典：<br>字典（dict）又称为散列表，是一种用来存储键值对的数据结构。</p><p>有序集合对象有2种编码方案，当同时满足以下条件时，集合对象采用ziplist编码，否则采用skiplist编码：</p><ul><li>有序集合保存的元素数量不超过128个；</li><li>有序集合保存的所有元素的成员长度都小于64字节。</li></ul><p>其中，ziplist编码的有序集合采用压缩列表作为底层实现，skiplist编码的有序集合采用zset结构作为底层实现。zset对象的底层数据结构包括：压缩列表、字典、跳跃表。</p><h3 id="13-布隆过滤器的理解"><a href="#13-布隆过滤器的理解" class="headerlink" title="13.布隆过滤器的理解"></a>13.布隆过滤器的理解</h3><p>布隆过滤器可以用很低的代价，估算出数据是否真实存在。例如：给用户推荐新闻时，要去掉重复的新闻，就可以利用布隆过滤器，判断该新闻是否已经推荐过。<br>布隆过滤器的核心包括两部分：</p><ol><li>一个大型的位数组；</li><li>若干个不一样的哈希函数，每个哈希函数都能将哈希值算的比较均匀。</li></ol><p>布隆过滤器的工作原理：</p><ol><li>添加key时，每个哈希函数都利用这个key计算出一个哈希值，再根据哈希值计算一个位置，并将位数组中这个位置的值设置为1。</li><li>询问key时，每个哈希函数都利用这个key计算出一个哈希值，再根据哈希值计算一个位置。然后对比这些哈希函数在位数组中对应位置的数值：<ul><li>如果这几个位置中，有一个位置的值是0，就说明这个布隆过滤器中，不存在这个key。</li><li>如果这几个位置中，所有位置的值都是1，就说明这个布隆过滤器中，极有可能存在这个key。之所以不是百分之百确定，是因为也可能是其他的key运算导致该位置为1。</li></ul></li></ol><h3 id="14-Redis抗高并发访问怎么设计-如果并发量超过30万，怎么设计Redis架构？"><a href="#14-Redis抗高并发访问怎么设计-如果并发量超过30万，怎么设计Redis架构？" class="headerlink" title="14.Redis抗高并发访问怎么设计 &amp; 如果并发量超过30万，怎么设计Redis架构？"></a>14.Redis抗高并发访问怎么设计 &amp; 如果并发量超过30万，怎么设计Redis架构？</h3><p>使用集群架构方案，将Redis分为不同的槽，由不同的节点进行负责，高并发访问时将key映射到不同的节点，防止对同一节点进行高并发访问冲击。</p><h3 id="15-Redis的缓存淘汰策略"><a href="#15-Redis的缓存淘汰策略" class="headerlink" title="15.Redis的缓存淘汰策略"></a>15.Redis的缓存淘汰策略</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/43109882/1715683513000-9f204e56-0474-42b2-835b-ce12211fbc14.jpeg"><br>个人总结</p><ul><li>利用LRU算法，淘汰哪些设置了过期时间的最近被使用的key</li><li>利用LFU算法，淘汰哪些设置了过期时间的最近最少被使用的key</li><li>从设置了过期时间的key中挑选即将过期的数据淘汰</li><li>从数据集中挑选任意key淘汰</li><li>不允许写</li></ul><h3 id="16-Redis为何选择单线程"><a href="#16-Redis为何选择单线程" class="headerlink" title="16.Redis为何选择单线程"></a>16.Redis为何选择单线程</h3><ul><li>单线程避免多线程切换开销</li><li>避免了同步机制的开销，比如锁</li><li>实现简单，底层结构不用设置成线程安全的</li></ul><h3 id="17-Redis不是真的是单线程"><a href="#17-Redis不是真的是单线程" class="headerlink" title="17.Redis不是真的是单线程"></a>17.Redis不是真的是单线程</h3><p>1.Redisv4.0（引入多线程处理异步任务）<br>2.Redis6.0（在网络模型中实现多线程I&#x2F;O）<br>所以，网络上说的Redis是单线程，通常是指在Redis 6.0之前，其核心网络模型使用的是单线程<br>且Redis6.0引入多线程I&#x2F;O，只是用来处理网络数据的读写和协议的解析，而执行命令依旧是单线程。<br>例如进行持久时，会先fork()一个子进程，单进程只是说Redis的网络IO和键值对读写是由一个线程来完成的，而其他的功能则是依赖于其他线程来实现的。</p><h3 id="18-Redis6-0开启多线程后，是否会存在线程并发安全问题？"><a href="#18-Redis6-0开启多线程后，是否会存在线程并发安全问题？" class="headerlink" title="18.Redis6.0开启多线程后，是否会存在线程并发安全问题？"></a>18.Redis6.0开启多线程后，是否会存在线程并发安全问题？</h3><p>从实现机制可以看出，Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。<br>所以我们不需要去考虑控制Key、Lua、事务，LPUSH&#x2F;LPOP 等等的并发及线程安全问题。</p><h3 id="19-Redis事务的概念"><a href="#19-Redis事务的概念" class="headerlink" title="19.Redis事务的概念"></a>19.Redis事务的概念</h3><ol><li>Redis事务中如果有某一条命令执行失败，之前的命令不会回滚，其后的命令仍然会被继续执行。鉴于这个原因，所以说Redis的事务严格意义上来说是不具备原子性的。</li><li>Redis事务中所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li><li>在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行。</li></ol><h3 id="20-Redis事务的三个阶段"><a href="#20-Redis事务的三个阶段" class="headerlink" title="20.Redis事务的三个阶段"></a>20.Redis事务的三个阶段</h3><ol><li>multi开启事务</li><li>大量指令入队</li><li>exec执行事务块内命令，截止此处一个事务已经结束</li><li>discard 取消事务</li><li>watch 监视一个或多个key，如果事务执行前key被改动，事务将打断。unwatch 取消监视</li></ol><p>事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队</p><h3 id="21-Redis事务支持隔离性吗"><a href="#21-Redis事务支持隔离性吗" class="headerlink" title="21.Redis事务支持隔离性吗"></a>21.Redis事务支持隔离性吗</h3><p>Redis是单进程的，并且保证在执行命令时不会被其他命令打断，可以完整的执行完一个事务的所有命令，所以天然的具有隔离性</p><h3 id="22-Redis事务的其他实现"><a href="#22-Redis事务的其他实现" class="headerlink" title="22.Redis事务的其他实现"></a>22.Redis事务的其他实现</h3><ul><li>基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完。</li><li>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐。</li></ul><h3 id="23-Redis为什么不支持事务回滚"><a href="#23-Redis为什么不支持事务回滚" class="headerlink" title="23.Redis为什么不支持事务回滚"></a>23.Redis为什么不支持事务回滚</h3><ul><li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li><li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li></ul><p>watch 机制实现乐观锁，来监视一个或多个 key，如果被监视的 key 在事务执行前被修改过那么本次事务将会被取消，也就是所谓的回滚。</p><h3 id="24-由于主从延迟导致读取到过期数据怎么处理"><a href="#24-由于主从延迟导致读取到过期数据怎么处理" class="headerlink" title="24.由于主从延迟导致读取到过期数据怎么处理"></a>24.由于主从延迟导致读取到过期数据怎么处理</h3><ol><li>通过scan命令扫库：当Redis中的key被scan的时候，相当于访问了该key，同样也会做过期检测，充分发挥Redis惰性删除的策略。这个方法能大大降低了脏数据读取的概率，但缺点也比较明显，会造成一定的数据库压力，否则影响线上业务的效率。</li><li>Redis加入了一个新特性来解决主从不一致导致读取到过期数据问题，增加了key是否过期以及对主从库的判断，如果key已过期，当前访问的master则返回null；当前访问的是从库，且执行的是只读命令也返回null。</li></ol><p>总结：经常扫描，实现类似惰性删除的效果，处理过期数据，这样就降低了访问到过期数据的概率；新特性，访问从节点时，即使key没有过期，返回null。</p><h3 id="25-主从复制的过程中如果因为网络原因停止复制了会怎么样？"><a href="#25-主从复制的过程中如果因为网络原因停止复制了会怎么样？" class="headerlink" title="25.主从复制的过程中如果因为网络原因停止复制了会怎么样？"></a>25.主从复制的过程中如果因为网络原因停止复制了会怎么样？</h3><p>自动重连，从上次复制的地方继续复制下去，如果找不到上次复制的地方（偏移量offset），就进行一次全量复制</p><h3 id="26-主从架构会数据丢失吗？"><a href="#26-主从架构会数据丢失吗？" class="headerlink" title="26.主从架构会数据丢失吗？"></a>26.主从架构会数据丢失吗？</h3><p>脑裂导致的丢失：master突然脱离网络，哨兵认为master出故障了，就选了个新master，然后旧的master回来了，但是它只能作为slave节点加入连接，所以就把数据清空进行全量复制。<br>解决方式：不能避免，只能减少；减少主从节点的连接延迟阈值，超过的话master就不会再接收任何数据了。</p><h3 id="27-RedLock"><a href="#27-RedLock" class="headerlink" title="27.RedLock"></a>27.RedLock</h3><p>RedLock 算法旨在解决单个 Redis 实例作为分布式锁时可能出现的单点故障问题，通过在多个独立运行的 Redis 实例上同时获取锁的方式来提高锁服务的可用性和安全性。<br>RedLock 具备以下主要特性：</p><ul><li><strong>互斥性</strong>：在任何时间，只有一个客户端可以获得锁，确保了资源的互斥访问。</li><li><strong>避免死锁</strong>：通过为锁设置一个较短的过期时间，即使客户端在获得锁后由于网络故障等原因未能按时释放锁，锁也会因为过期而自动释放，避免了死锁的发生。</li><li><strong>容错性</strong>：即使一部分 Redis 节点宕机，只要大多数节点（即过半数以上的节点）仍在线，RedLock 算法就能继续提供服务，并确保锁的正确性。</li></ul><p>RedLock 实现思路<br>RedLock 是对集群的每个节点进行加锁，如果大多数节点（N&#x2F;2+1）加锁成功，则才会认为加锁成功。<br>这样即使集群中有某个节点挂掉了，因为大部分集群节点都加锁成功了，所以分布式锁还是可以继续使用的。<br>工作流程<br>RedLock 算法的工作流程大致如下：</p><ul><li>客户端向多个独立的 Redis 实例尝试获取锁，设置锁的过期时间非常短。</li><li>如果客户端能在大部分节点上成功获取锁，并且所花费的时间小于锁的过期时间的一半，那么认为客户端成功获取到了分布式锁。</li><li>当客户端完成对受保护资源的操作后，它需要向所有曾获取锁的 Redis 实例释放锁。</li><li>若在释放锁的过程中，客户端因故无法完成，由于设置了锁的过期时间，锁最终会自动过期释放，避免了死锁。</li></ul><p>在 Java 开发中，可以使用 Redisson 框架很方便的实现 RedLock。</p>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2024/03/09/JAVA/"/>
      <url>/2024/03/09/JAVA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Java-C"><a href="#Java-C" class="headerlink" title="Java &amp; C++"></a>Java &amp; C++</h3><ul><li>内存管理：Java有自动的垃圾回收机制，C++需要手动管理；虽然说手动进行垃圾回收会更精准，但是大部分时候是比较繁琐且容易出错的</li><li>跨平台：通过将Java源代码编译成字节码文件，通过JVM进行解释执行，因此在各个系统都可用，移植性好</li><li>生态好：Java的生态极其好，从第三方类库，到丰富的企业框架和资料，再到各种中间件</li><li>安全性：Java具有强大的安全机制，字节码验证、访问控制等（这点不是很清晰，可以不讲）</li></ul><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><p>Java 中将实参传递给方法（或函数）的方式是 <strong>值传递</strong>：</p><ul><li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li><li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。<blockquote><p>引用类型的对象引用放在栈中，而对象实际存放在堆中<br>基本数据类型的位置存在两种情况：</p><ol><li>在方法中声明的变量及值存放在方法栈中；</li><li>在类中声明的变量及值存放在堆中</li></ol></blockquote>总的来说还是值传递</li></ul><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul><li><strong>序列化</strong>：将数据结构或对象转换成二进制字节流的过程</li><li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><p>序列化的主要目的是方便通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中</p><ol><li>JDK自带序列化，实现 java.io.Serializable 接口即可（起标记作用）</li><li>serialVersionUID：用于反序列化时检查是否一致的版本号，不一致就报错</li><li>使用 transient 进行阻止序列化</li><li>static修饰的变量不会被序列化，在序列化时不会包含进去</li></ol><p>可选序列化方式：</p><ol><li>Java对象序列化，实现上述接口</li><li>JSON序列化，通过ObjectMapper进行序列化（引入外部库）</li><li>ProtoBuff 序列化（不是很熟悉）</li></ol><h3 id="自动拆箱-装箱"><a href="#自动拆箱-装箱" class="headerlink" title="自动拆箱&#x2F;装箱"></a>自动拆箱&#x2F;装箱</h3><p>装箱：将基本类型⽤它们对应的引⽤类型包装起来，调用valueOf()方法；<br>拆箱：将包装类型转换为基本数据类型，调用xxxValue()方法（比如intValue() ）；</p><blockquote><p>自动拆箱装箱是为了获取对象的相关特性，拥有属性和方法，比如进行传参时可以将基本数据类型作为对象进行传参，这样的话会更加的方便一些</p></blockquote><h3 id="面向过程和面向对象"><a href="#面向过程和面向对象" class="headerlink" title="面向过程和面向对象"></a>面向过程和面向对象</h3><p>面向过程：把解决问题的过程分为多个步骤，分别实现每个步骤后再调用解决问题；这更专注于一种流程化的过程，一步步的执行下去，直到最后一步<br>面向对象：抽象出问题的实体，为每个实体分配职责并编写专属的行为（方法），解决问题时调用对象方法即可，各自干好自己的事</p><blockquote><p>面向过程总的来说，更加偏向于人类的思维，从指定每一步干什么（面向过程）到指定各个实体应有的职责（面向对象），更像是人类的分工合作来完成一件事</p></blockquote><h3 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h3><p>封装：抽取实体的共同属性和方法，封装成对象，将一些方法的接口进行暴露出去，隐藏其中的属性和具体的方法实现细节<br>继承：子类继承父类的属性方法，并扩展出自己的特有属性方法；通过继承，可以复用、扩展和修改父类的行为<br>多态：运行时确定，引用指向的实例对象与编译时类不一致；编译看左边，运行看右边，这种多态也可以说是继承带来的改变，表现为子类和父类的重写后方法的实现方式不同</p><h3 id="重载-重写"><a href="#重载-重写" class="headerlink" title="重载 &amp; 重写"></a>重载 &amp; 重写</h3><p>重载：一个类中的同名方法改写，修改参数列表（参数类型、数量和顺序，与返回值无关）保证方法调用不同，主要是为了提供相同功能的不同实现<br>重写：子类对父类方法的重写，以提供不同实现形成多态，方法名和参数类型等都得一致，抛出异常不能大于父类方法，方法可见范围不能大于父类方法</p><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>this 是⾃⾝的⼀个对象，代表对象本⾝，可以理解为：指向对象本⾝的⼀个指针</p><ol><li>普通的直接引⽤，this 相当于是指向当前对象本⾝</li><li>形参与成员变量名字重名，⽤ this 来区分</li><li>引⽤本类的构造函数<blockquote><p>这个可能不会被问到，但是复习的时候可以看一眼</p></blockquote></li></ol><h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><p><strong>共同点</strong>：</p><ul><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li>都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。</li></ul><p><strong>区别</strong>：</p><ul><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为（接口先行，like-a）。抽象类主要用于代码复用，强调的是所属关系（is-a）</li><li>接口更多的是规范行为在先，抽象类则是我们在编写过程中发现一些方法是可以复用的，于是有了抽象类</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li></ul><h3 id="理解-String-类型值的不可变"><a href="#理解-String-类型值的不可变" class="headerlink" title="理解 String 类型值的不可变"></a>理解 String 类型值的不可变</h3><p>首先String是不可继承的，其次存储数据的value数组是使用final修饰的</p><ul><li>多线程下更安全</li><li>保证哈希值的唯一性和一致性</li><li>修改时不是直接修改String对象，性能更好</li><li>字符串常量池共用字符串，如果可变会出现问题</li></ul><h3 id="Java创建对象的方式"><a href="#Java创建对象的方式" class="headerlink" title="Java创建对象的方式"></a>Java创建对象的方式</h3><ol><li>new关键字</li><li>反射机制</li><li>clone机制</li><li>序列化方式</li></ol><h3 id="讲讲你对反射的理解"><a href="#讲讲你对反射的理解" class="headerlink" title="讲讲你对反射的理解"></a>讲讲你对反射的理解</h3><p>反射是Java语言的一个特性，它允许程序在运行时，对于任意一个类，能够动态知道这个类的所有属性和方法,对于任意一个对象，都能够调用它的任意方法和属性，这种在运行期动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。<br>原理：类在加载完成后会生成一个Class对象，我们平常的话都是通过new关键字调用这个对象来获取属性和方法，属于是硬编码，反射就由程序员来指定要加载哪些属性和方法。<br>应用：动态配置，Spring AOP，IOC容器，最具体的就是数据库连接根据不同的驱动通过反射来创建不同的连接对象。如果对于一个集合的类型存在改变，今天HashMap，明天LinkedHashMap，你大可以用选择分支来判断使用那个进行new出来，但是你也可以使用反射，传类的全限定名来动态获取属性和方法。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>抽象策略类；具体策略类；环境类<br>定义抽象策略类接口和环境类，环境类包括抽象策略和策略调用方法，具体策略类是具体策略实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        <span class="type">Strategy</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>();</span><br><span class="line">        c.setStrategy(s);</span><br><span class="line">        c.strategyMethod();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        s = <span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>();</span><br><span class="line">        c.setStrategy(s);</span><br><span class="line">        c.strategyMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象策略类</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">strategyMethod</span><span class="params">()</span>;    <span class="comment">//策略方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">strategyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体策略A的策略方法被访问！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">strategyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体策略B的策略方法被访问！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="keyword">public</span> Strategy <span class="title function_">getStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrategy</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">strategyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        strategy.strategyMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样还是没有消除if-else以及策略类过多的问题<br>可以使用枚举类+Map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    A&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exe</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行具体策略A&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    B&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">exe</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行具体策略B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">exe</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Strategy&gt; map=<span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;A&quot;</span>,Strategy.A);</span><br><span class="line">        map.put(<span class="string">&quot;B&quot;</span>,Strategy.B);</span><br><span class="line"></span><br><span class="line">        String str=<span class="string">&quot;A&quot;</span>;</span><br><span class="line">        map.get(str).exe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>应用场景：</p><ol><li>用户登录的时候，根据不同的登录验证方式，获取不同的校验实现类</li><li>支付的时候，根据选择的不同支付方式，调用不同的支付接口实现</li></ol></blockquote><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>子类利用父类的模板化方法，不同的子类分别实现模板方法中的抽象方法，从而实例化出不同的子类对象<br>您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>一个原型类，通过克隆这个原型类来进行创建新对象<br>浅克隆：对于基本数据类型，直接复制数值，引用数据类型则复制一份地址<br>深克隆：完完全全的进行复制一份，复制品和原型类之间没有关系</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>使用代理对象来代替对真实对象的访问，在不修改原对象的前提下提供额外的操作，扩展对象的目标功能<br>静态代理：在编译时就进行代理模类的实现，成为字节码文件<br>动态代理：<br>JDK动态代理（只能代理实现了接口的类）InvocationHandler 接口和 Proxy 类是核心。<br>CGLIB动态代理方式（通过继承来代理类）MethodInterceptor 接口和 Enhancer 类是核心</p><h3 id="模版模式"><a href="#模版模式" class="headerlink" title="模版模式"></a>模版模式</h3><p>抽象类定义一些抽象方法，由子类去实现，也就是把一些通用算法抽象出来，举个例子来说：某个抽象类有一个默认方法定义了一系列流程，其中某些流程的执行结果的形式一致但是具体逻辑是不同的，那么就抽象出来成一个抽象方法，具体逻辑代码用子类去实现</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="常见集合有哪些"><a href="#常见集合有哪些" class="headerlink" title="常见集合有哪些"></a>常见集合有哪些</h3><ul><li>List：存储的元素有序，可重复</li><li>Set：存储的元素不无序，不可重复</li><li>Map：是另外的接口，是键值对映射结构的集合</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1714140809280-aeee1de8-fbdb-4a20-9bcc-6d705d18a189.png#averageHue=%23fcfaf6&clientId=ud49fd56c-bc74-4&from=paste&height=333&id=u0c8a6d9b&originHeight=499&originWidth=1310&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=399622&status=done&style=none&taskId=u9e66286c-2760-43c0-8c4b-2b25f27230c&title=&width=873.3333333333334" alt="image.png"></p><h3 id="线程安全的集合有哪些"><a href="#线程安全的集合有哪些" class="headerlink" title="线程安全的集合有哪些"></a>线程安全的集合有哪些</h3><ul><li>Vector：synchronized 关键字来实现线程安全</li><li>HashTable：synchronized 关键字来实现线程安全</li><li>ConcurrentHashMap：分版本，后面笔记介绍</li><li>CopyOnWriteArrayList：写操作时进行复制</li><li>ConcurrentLinkedQueue：不清楚，可以不说</li></ul><h3 id="ArrayList和LinkedList有什么区别"><a href="#ArrayList和LinkedList有什么区别" class="headerlink" title="ArrayList和LinkedList有什么区别"></a>ArrayList和LinkedList有什么区别</h3><ol><li>数据结构不同：ArrayList 基于数组，LinkedList基于链表</li><li>多数情况下，ArrayList更利于查找，LinkedList更利于增删</li><li>是否支持随机访问：ArrayList实现了RandomAccess接口，支持通过序号获取元素对象实现随机访问</li><li>内存占用：ArrayList会预留一部分内存给预定义长度，LinkedList的指针会消耗内存</li></ol><h3 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h3><p>ArrayList的扩容是创建⼀个<strong>1.5</strong>倍的新数组，然后把原数组的值拷贝过去。</p><h3 id="ArrayList的序列化"><a href="#ArrayList的序列化" class="headerlink" title="ArrayList的序列化"></a>ArrayList的序列化</h3><p>它使用 transient 修饰存储元素的数组，防止其被序列化<br>因为有些空间可能没用到，不进行序列化可以提高效率</p><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>线程安全版本的ArrayList，实现读写分离<br>允许并发读，无锁限制；写的时候，就复制一份内容，在副本上进行加锁修改，改完后修改原容器的引用</p><h3 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h3><p>1.7是数组+链表<br>1.8是数据+链表+红黑树<br>在链表长度大于8时，转换为红黑树，但是需要先判断数组长度是否小于64，小于的话就先扩容数组，大于就转换为红黑树（这里的还有一些扩容后元素移动的问题）</p><h3 id="红黑树-二叉树-平衡树"><a href="#红黑树-二叉树-平衡树" class="headerlink" title="红黑树 &amp; 二叉树 &amp; 平衡树"></a>红黑树 &amp; 二叉树 &amp; 平衡树</h3><p>红黑树本质是一种平衡的二叉查找树</p><ol><li>每个节点要么是红色，要么是黑色；</li><li>根节点永远是黑色的；</li><li>所有的叶子节点都是是黑色的（注意这⾥说叶⼦节点其实是图中的 NULL 节点）；</li><li>每个红色节点的两个子节点⼀定都是黑色；</li><li>从任⼀节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；</li></ol><p>不用二叉树：红黑树各种时间复杂度为logn，二叉树为n<br>不用平衡二叉树：平衡二叉树为了保持更严格的平衡，需要进行更多的旋转次数<br>通过旋转和节点染色来保持平衡</p><h3 id="HashMap的put方法"><a href="#HashMap的put方法" class="headerlink" title="HashMap的put方法"></a>HashMap的put方法</h3><ol><li>根据key值计算哈希值</li><li>判断map是否为空，为空就扩容（开始不分配空间？）</li><li>计算数组下标</li><li>下标位置为空？不为空判断key是否相同，为空添加元素</li><li>key相同则覆盖元素，否则判断是否树节点来判断是根据链表插入还是红黑树插入</li><li>插入的时候判断扩容条件是否满足</li></ol><h3 id="HashMap的查找"><a href="#HashMap的查找" class="headerlink" title="HashMap的查找"></a>HashMap的查找</h3><ol><li>计算哈希值，判断map是否为空</li><li>计算在数组中的位置，判断是否为查找节点</li><li>判断该位置连接的是链表还是红黑树，进行查找</li><li>返回结果</li></ol><h3 id="HashMap容量为什么是2的倍数"><a href="#HashMap容量为什么是2的倍数" class="headerlink" title="HashMap容量为什么是2的倍数"></a>HashMap容量为什么是2的倍数</h3><blockquote><p>进行哈希取余时，可以得到<code>哈希码 % 数组长度</code>，而当数组长度是是2的n次幂时，以上公式可以转换为<code>哈希码 &amp; (数组长度 - 1)</code>位运算更快</p></blockquote><ol><li>方便哈希取余，位运算比求余%更快</li><li>扩容时，利用扩容后的⼤小也是2的倍数，将已经产生hash碰撞的元素完美的转移到新的table中去（如何转移需要深入解析）</li></ol><h3 id="解决哈希冲突的方法"><a href="#解决哈希冲突的方法" class="headerlink" title="解决哈希冲突的方法"></a>解决哈希冲突的方法</h3><ul><li>链地址法</li><li>线性（平方）探查法</li><li>再哈希法，换哈希函数计算</li><li>建立公共溢出区，把冲突元素放进去</li></ul><h3 id="jdk1-8做了那些优化"><a href="#jdk1-8做了那些优化" class="headerlink" title="jdk1.8做了那些优化"></a>jdk1.8做了那些优化</h3><ol><li>数据结构变为数组+链表+红黑树</li><li>链表改为尾插法</li><li>扩容时不需重新进行哈希定位计算</li><li>1.8在插入完成后才判断是否需要扩容</li></ol><h3 id="HashMap多线程下问题"><a href="#HashMap多线程下问题" class="headerlink" title="HashMap多线程下问题"></a>HashMap多线程下问题</h3><ol><li>扩容死循环，1.7使用头插法可能会出现循环链表</li><li>put造成元素丢失，如果计算出来的索引位置是相同的，那会造成前⼀个 key 被后⼀个 key 覆盖</li><li>put 和 get 并发时，可能导致 get 为 null</li></ol><h3 id="解决线程不安全问题"><a href="#解决线程不安全问题" class="headerlink" title="解决线程不安全问题"></a>解决线程不安全问题</h3><ul><li>HashTable 是直接在操作方法上加 synchronized 关键字，锁住整个table数组，粒度比较大</li><li>ConcurrentHashMap 在jdk1.7中使⽤分段锁，在jdk1.8中使⽤CAS+synchronized<ul><li>分段锁：一个ConcurrentHashMap分为不同的Segment，每个Segment都是一个HashMap，通过在不同的Segment上加锁实现线程安全</li><li>CAS + synchronized：数据结构和HashMap一致，通常使用CAS进行写操作，在某些关键操作（树化、扩容等）就加上synchronized关键字</li></ul></li></ul><h3 id="LinkedHashMap-TreeMap实现有序"><a href="#LinkedHashMap-TreeMap实现有序" class="headerlink" title="LinkedHashMap &amp; TreeMap实现有序"></a>LinkedHashMap &amp; TreeMap实现有序</h3><p>LinkedHashMap：在HashMap基础上，维护了一个双向链表<br>TreeMap：按照key来排序，维护了一个红黑树</p><h3 id="HashSet怎么保证key唯一"><a href="#HashSet怎么保证key唯一" class="headerlink" title="HashSet怎么保证key唯一"></a>HashSet怎么保证key唯一</h3><p>重写元素的hashCode和equals方法，在插入时会先判断哈希值是否相等，再由equals方法判断内容是否相同，相同则不进行插入</p><h3 id="ArrayBlockingQueue-和-LinkedBlockingQueue"><a href="#ArrayBlockingQueue-和-LinkedBlockingQueue" class="headerlink" title="ArrayBlockingQueue 和 LinkedBlockingQueue"></a><a href="https://javaguide.cn/java/collection/java-collection-questions-01.html#arrayblockingqueue-%E5%92%8C-linkedblockingqueue-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">ArrayBlockingQueue 和 LinkedBlockingQueue</a></h3><ul><li>底层数据结构不同</li><li>ArrayBlockingQueue是有界的，LinkedBlockingQueue默认是无界的，也可以设置有界</li><li>ArrayBlockingQueue的生产者消费者共用一把锁，LinkedBlockingQueue的锁是分离的</li><li>ArrayBlockingQueue预先分配空间，LinkedBlockingQueue随节点数增加而增加</li></ul><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><ul><li><strong>InputStream</strong>：read(), skip() 忽略n个字符, available() 可以读取的字节数, close()<ul><li>FileInputStream(读取文件)</li><li>ObjectInputStream(序列化)</li><li>DataInputStream(读取指定类型)</li></ul></li><li><strong>OutputStream</strong>：write(), flush() 刷新并写出缓冲中所有字节, close()<ul><li>FileOutputStream(输出文件文件)</li><li>ObjectOutputStream(反序列化)</li><li>DataOutputStream(写入指定类型数据)</li></ul></li></ul><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><ul><li><strong>Reader</strong>：read(), skip(), close()</li></ul><p>InputStreamReader是字节流转换为字符流的桥梁，其子类 FileReader 是基于该基础上的封装</p><ul><li><strong>Writer</strong>：write(), append(), flush(), close()</li></ul><p>OutputStreamWriter 是字符流转换为字节流的桥梁，其子类 FileWriter 是基于该基础上的封装</p><h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><p>字节缓冲流这里采用了装饰器模式来增强 InputStream 和OutputStream子类对象的功能</p><ul><li>BufferedInputStream：先将读取到的字节放入缓存中，再从缓存读取</li><li>BufferedOutputStream：先把字节写在缓存中，再一次性写入磁盘，减少IO</li></ul><h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><p>类似于字节缓冲流</p><ul><li>BufferedReader</li><li>BufferedWriter</li></ul><h3 id="IO设计模式"><a href="#IO设计模式" class="headerlink" title="IO设计模式"></a>IO设计模式</h3><ol><li>装饰器模式</li></ol><p> 可以在不改变原有对象的情况下拓展其功能<br>举个例子，我们可以通过 BufferedInputStream（字节缓冲输入流）来增强 FileInputStream 的功能</p><ol start="2"><li>适配器模式</li></ol><p>主要用于接口互不兼容的类的协调工作<br>InputStreamReader 和 OutputStreamWriter 就是两个适配器(Adapter)， 同时，它们两个也是字节流和字符流之间的桥梁，他们实现了字节流和字符流之间的转换</p><ol start="3"><li>工厂模式</li></ol><p>用于创建对象，例子不是很熟</p><ol start="4"><li>观察者模式</li></ol><p>NIO 中的文件目录监听服务使用到了观察者模式<br>也不是很熟，讲讲前两种就差不多了</p><h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><ol><li>BIO (Blocking I&#x2F;O)</li></ol><p>同步阻塞I&#x2F;O模型<br>发起I&#x2F;O请求后就阻塞自己等到I&#x2F;O完成再继续执行</p><blockquote><p>客户端数量连接数比较少的情况下</p></blockquote><ol start="2"><li>NIO (Non-blocking I&#x2F;O)</li></ol><p>属于是IO多路复用模型，同步非阻塞模型<br>client -&gt; buffer -&gt; channel -&gt; selector<br>selector不断轮询channel是否有准备好的读写事件，有就执行</p><blockquote><p>高负载、高并发的应用使用这个<br>但是这种轮询过程十分消耗CPU资源</p></blockquote><ol start="3"><li>AIO (Asynchronous I&#x2F;O)</li></ol><p>异步非阻塞模型，基于事件和回调机制实现，当操作完成后会通知相应线程进行后续的操作<br>总结：同步异步主要是看结果执行完成后，是线程自己查看是否完成还是会回调线程通知线程已经完成；阻塞和非阻塞就是看线程会一直等任务执行完成还是先做自己的事，时不时询问有没有执行完成</p><blockquote><p>应用场景并不是很广泛，Netty之前使用过，但是因为性能并没有提升多少，所以就弃用了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2024/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="OSI七层模型-TCP-IP"><a href="#OSI七层模型-TCP-IP" class="headerlink" title="OSI七层模型 &amp; TCP&#x2F;IP"></a>OSI七层模型 &amp; TCP&#x2F;IP</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1714029464726-66837f3b-9a56-4fc6-bbd2-7b8783eb057e.png#averageHue=%23f3f1f1&clientId=ud1d43a64-c737-4&from=paste&id=u07857916&originHeight=468&originWidth=631&originalType=url&ratio=1.6500000953674316&rotation=0&showTitle=false&status=done&style=none&taskId=u7bfd6972-34dc-4659-9fb0-9ed9dede4f6&title="></p><table><thead><tr><th><strong>OSI七层模型</strong></th><th><strong>TCP&#x2F;IP四层模型</strong></th><th><strong>协议</strong></th></tr></thead><tbody><tr><td>应用层</td><td></td><td></td></tr><tr><td>表示层</td><td></td><td></td></tr><tr><td>会话层</td><td>应用层</td><td>HTTP、DNS、SMTP、FTP等</td></tr><tr><td>传输层</td><td>传输层</td><td>TCP&#x2F;UDP</td></tr><tr><td>网络层</td><td>网络层</td><td>IP</td></tr><tr><td>数据链路层</td><td></td><td></td></tr><tr><td>物理层</td><td>链路层</td><td>-</td></tr></tbody></table><ul><li>应用层：主要提供两个终端设备上的应用程序之间信息交换的服务</li><li>传输层：向两台终端设备进程之间的通信提供通用的数据传输服务</li><li>网络层：决定你的数据在网络中的游走路径</li><li>数据链路层：用来进行数据在物理硬件中的传输流程</li></ul><h3 id="输入URL到页面"><a href="#输入URL到页面" class="headerlink" title="输入URL到页面"></a>输入URL到页面</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/43109882/1714029669775-e28fa169-303f-452c-9e29-804b23a96bdd.jpeg#averageHue=%23f7f7f7&clientId=ud1d43a64-c737-4&from=paste&height=462&id=u7ac95ca0&originHeight=914&originWidth=1160&originalType=url&ratio=1.6500000953674316&rotation=0&showTitle=false&status=done&style=none&taskId=u45427546-8c9e-4d2a-a9d5-17025b758c9&title=&width=586.7802734375"></p><ol><li>在浏览器中输入指定网页的 URL。</li><li>浏览器通过 DNS 协议，获取域名对应的 IP 地址。</li><li>浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。</li><li>浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。</li><li>服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。</li><li>浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。</li><li>浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。</li></ol><h3 id="TCP-三次握手四次挥手"><a href="#TCP-三次握手四次挥手" class="headerlink" title="TCP 三次握手四次挥手"></a>TCP 三次握手四次挥手</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1714033482877-6d21e37d-37d5-43e3-a7cd-36cf597e9b68.png#averageHue=%23f3fcf5&clientId=ud1d43a64-c737-4&from=paste&height=401&id=ua10e1e91&originHeight=583&originWidth=499&originalType=url&ratio=1.6500000953674316&rotation=0&showTitle=false&status=done&style=none&taskId=ue5ec7590-c31d-4937-9f63-1e1498af46f&title=&width=342.9961853027344"><br><strong>为什么三次握手</strong></p><ul><li>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li><li>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li><li>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li></ul><p><strong>三次握手的目的</strong><br>为了防止已失效的连接请求<a href="https://www.zhihu.com/search?q=%E6%8A%A5%E6%96%87%E6%AE%B5&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:63668444%7D">报文段</a>突然又传送到了服务端，因而产生错误<br>四次握手属于是重复，两次握手不行，因为服务端不能确认客户端是否收到了自己的同步信号<br><img src="https://cdn.nlark.com/yuque/0/2024/png/43109882/1714034009205-61c8c7e9-163f-48e4-83f6-d5fa23f3959e.png#averageHue=%23f3fcf5&clientId=ud1d43a64-c737-4&from=paste&height=373&id=u63a0ec51&originHeight=583&originWidth=499&originalType=url&ratio=1.6500000953674316&rotation=0&showTitle=false&status=done&style=none&taskId=uc34c179f-9ac7-4cdd-b685-30a28e1fcba&title=&width=318.9961853027344"></p><ul><li>第一次挥手：客户端说我要断开连接</li><li>第二次挥手：服务端知道了并表示可能还有数据传输</li><li>第三次挥手：服务器说我传输完了，可以断开连接</li><li>第四次挥手：客户端表示那就断开连接吧</li></ul><p><strong>不能三次挥手</strong>：因为可能还有数据没传输完<br><strong>第四次挥手客户端需等待2MSL：</strong>防止ack传输失败，服务器会重发，客户端需要重新确认</p><h3 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3><ul><li>端口号不同：HTTP 默认是 80，HTTPS 默认是 443。</li><li>URL前缀不同：前者http:&#x2F;&#x2F;，后者https:&#x2F;&#x2F;。</li><li>安全性：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li><li>HTTPS 协议需要申请数字证书来保证服务器的身份是可信的</li><li>搜索引擎：因为安全性，通常使用HTTPS协议的网站会被优先展示</li></ul><h3 id="HTTP建立连接"><a href="#HTTP建立连接" class="headerlink" title="HTTP建立连接"></a>HTTP建立连接</h3><ol><li>用户在浏览器输入URL，客户端准备发起请求</li><li>进行DNS解析，先查本地DNS缓存，没有再查对应的DNS服务器</li><li>进行三次握手建立TCP连接</li><li>发送HTTP请求，携带信息（请求头，请求体）</li><li>服务器处理接收到的HTTP请求并发送HTTP响应</li><li>进行四次挥手关闭TCP连接</li></ol><h3 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h3><ol><li>用户在浏览器输入URL，客户端准备发起请求</li><li>进行DNS解析，先查本地DNS缓存，没有再查对应的DNS服务器</li><li>进行三次握手建立TCP连接</li><li>SSL&#x2F;TLS握手<ol><li>客户端发起请求，连接服务端443端口</li><li>服务端将自己的数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）</li><li>客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密发送给服务端</li><li>服务器用私钥解密得到秘钥，至此完成握手</li></ol></li><li>发送<code>close_notify</code>消息关闭<code>TLS</code>连接，再四次挥手关闭<code>TCP</code>连接</li></ol><h3 id="HTTP-1-0-vs-HTTP-1-1"><a href="#HTTP-1-0-vs-HTTP-1-1" class="headerlink" title="HTTP 1.0 vs HTTP 1.1"></a>HTTP 1.0 vs HTTP 1.1</h3><ul><li>状态码：后者增加了大量的状态码</li><li>连接方式：前者短连接，进行一次HTTP操作就建立连接一次；后者长连接，首次建立连接后不会立即关闭，而是会保持一段时间</li><li>Host头：1.1在请求头中增加了host字段，允许多个主机名绑定到一个IP地址上</li></ul><h3 id="HTTP-1-1-vs-HTTP-2-0"><a href="#HTTP-1-1-vs-HTTP-2-0" class="headerlink" title="HTTP 1.1 vs HTTP 2.0"></a>HTTP 1.1 vs HTTP 2.0</h3><ul><li>头部压缩：发送多个请求时，头中重复的部分会被客户端和服务器维护起来，不进行重复发送</li><li>二进制格式：1.1采用文本形式的报文，2.0采用二进制</li><li>并发传输：2.0可以在一个连接上同时传输多个请求和响应</li><li>服务器推送：2.0会将相关资源一起推送给客户端</li></ul><h3 id="HTTP-3-0"><a href="#HTTP-3-0" class="headerlink" title="HTTP 3.0"></a>HTTP 3.0</h3><p>传输层基于UDP协议，并在应用层实现QUIC协议保证UDP传输变为可靠传输<br><a href="https://xiaolincoding.com/network/2_http/http3.html#%E6%80%BB%E7%BB%93">3.7 HTTP&#x2F;3 强势来袭</a></p><h3 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h3><ul><li>根 DNS 服务器。根 DNS 服务器提供 TLD 服务器的 IP 地址。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。</li><li>顶级域 DNS 服务器（TLD 服务器）。顶级域是指域名的后缀，如com、org、net和edu等。国家也有自己的顶级域，如uk、fr和ca。TLD 服务器提供了权威 DNS 服务器的 IP 地址。</li><li>权威 DNS 服务器。在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。</li><li>本地 DNS 服务器。每个 ISP（互联网服务提供商）都有一个自己的本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 层次结构中。严格说来，不属于 DNS 层级结构。</li></ul><h3 id="TCP传输可靠性保障"><a href="#TCP传输可靠性保障" class="headerlink" title="TCP传输可靠性保障"></a>TCP传输可靠性保障</h3><ol><li>基于数据块传输</li><li>对数据包进行编号排序并按照序号去重</li><li>校验和，验证数据是否被篡改</li><li>重传机制，没有收到ACK的包会重传</li></ol><ul><li>超时重传：指定时间没没有收到ACK就重传</li><li>快速重传：收到连续三个ACK就重传，问题：重传一个还是重传所有的</li><li>SACK：在快速重传机制上加上SACK，表示已经收到数据信息，这样就只需要重传丢失的即可</li><li>D-SACK：可以告诉发送方哪些包是重复发送的</li></ul><ol start="5"><li>流量控制，利用滑动窗口实现</li></ol><ul><li>窗口数据分为四个部分</li><li>窗口大小由接收方决定，两端共同维护</li></ul><ol start="6"><li>拥塞控制</li></ol><ul><li>避免发送方的数据填满整个网络</li><li>发送方维护</li><li>发送窗口等于拥塞窗口和接收窗口的最小值</li><li>四个算法<ul><li>慢启动：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1，指数级别的</li><li>拥塞避免：每轮拥塞窗口数量增加1</li><li>拥塞发生：使用超时重传和快速重传机制</li><li>快速恢复：问到就死</li></ul></li></ul><p><a href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0">4.2 TCP 重传、滑动窗口、流量控制、拥塞控制</a></p><h3 id="半包和粘包"><a href="#半包和粘包" class="headerlink" title="半包和粘包"></a>半包和粘包</h3><p>粘包：指数据在传输时，在一条消息中读取到了另一条消息的部分数据，这种现象就叫做粘包<br>半包：接收端只收到了部分数据，而非完整的数据的情况就叫做半包<br>为什么：因为 TCP 是面向连接的传输协议，它是以“流”的形式传输数据的，而“流”数据是没有明确的开始和结尾边界的，所以就会出现粘包问题<br>解决方案：</p><ul><li>固定数据大小，如果数据不够就用字符填充</li><li>自定义请求协议：发送数据的大小 + 具体数据</li><li>通过特殊字符来表示流的边界</li></ul><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>ARP 协议解决了 IP 地址转 MAC 地址的一些问题<br><strong>IP地址和MAC地址</strong><br>MAC相当于一台设备的真正标识，它是不会变的，而IP地址则是告诉你这个设备的不重复位置，当设备更换网络时，IP也就会发生变化</p><h3 id="GET-POST"><a href="#GET-POST" class="headerlink" title="GET &amp; POST"></a>GET &amp; POST</h3><ul><li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li><li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</li></ul><p>GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。<br>POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。</p><h3 id="session-cookie"><a href="#session-cookie" class="headerlink" title="session &amp; cookie"></a>session &amp; cookie</h3><p>cookie：保存在客户端的一部分数据<br>session：用来表示服务器和客户端的会话状态（是谁在会话）<br>区别：</p><ol><li>Cookie 保存在客户端，Session 保存在服务器端</li><li>Cookie 可设置为长时间保持，Session 一般有效时间较短，客户端关闭或者 Session 超时都会失效</li><li>session的安全性要更好一些</li></ol><p>联系：可以使用cookie记录session的 SessionID，每次请求前会携带这个信息</p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><blockquote><p>WebSocket是一种网络通信协议，提供了在单个TCP连接上进行全双工通信的能力，伴随H5出的协议</p></blockquote><p>特点</p><blockquote><ol><li>全双工通信，允许服务器和客户端之间进行双向实时通信，双方随时可以发送和接受消息</li><li>使用持久的连接，减少维护连接的开销</li><li>初次连接后后续连接不需要<code>HTTP</code>头，节省带宽</li><li>长连接，一旦建立连接保持一段时间</li></ol></blockquote><p>工作流程</p><blockquote><ol><li>建立连接：客户端发送一个HTTP请求至服务器，要求升级为WebSocket协议</li><li>协议升级：服务器接受请求并升级协议，连接建立成功</li><li>数据交换：客户端和服务器随时互相发送数据</li><li>关闭连接：任何一方发起关闭连接的请求</li></ol></blockquote><p>应用场景</p><blockquote><ul><li>实时聊天</li><li>在线游戏</li><li>实时数据推送</li></ul></blockquote><h3 id="WebSocket-Socket"><a href="#WebSocket-Socket" class="headerlink" title="WebSocket &amp; Socket"></a>WebSocket &amp; Socket</h3><p>Socket &#x3D; IP + 端口 + 协议，具体来说，Socket 是一套标准，它完成了对 TCP&#x2F;IP 的⾼度封装，屏蔽网络细节，以⽅便开发者 更好地进⾏⽹络编程<br>WebSocket 是⼀个持久化的协议，它是伴随 H5 而出的协议，⽤来解决 http 不支持持久化连接的问题<br>Socket ⼀个是网编编程的标准接口，而 WebSocket 则是应用层通信协议</p>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
